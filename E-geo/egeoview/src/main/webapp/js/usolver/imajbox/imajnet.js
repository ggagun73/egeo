(function(c) {
    function b(a, c) {
        if (!(1 < a.originalEvent.touches.length)) {
            a.preventDefault();
            var b = a.originalEvent.changedTouches[0],
                d = document.createEvent("MouseEvents");
            d.initMouseEvent(c, !0, !0, window, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1, !1, !1, !1, 0, null);
            a.target.dispatchEvent(d)
        }
    }
    c.support.touch = "ontouchend" in document;
    if (c.support.touch) {
        var d = c.ui.mouse.prototype,
            f = d._mouseInit,
            g = d._mouseDestroy,
            e;
        d._touchStart = function(a) {
            e || !this._mouseCapture(a.originalEvent.changedTouches[0]) || a.target.className &&
                a.target.className.indexOf && -1 !== a.target.className.indexOf("closethick") || a.target.parentNode && a.target.parentNode.className && a.target.parentNode.className.indexOf && -1 !== a.target.parentNode.className.indexOf("dialogButtonsItem") || (e = !0, this._touchMoved = !1, b(a, "mouseover"), b(a, "mousemove"), b(a, "mousedown"))
        };
        d._touchMove = function(a) {
            !e || a.target.className && a.target.className.indexOf && -1 !== a.target.className.indexOf("closethick") || a.target.parentNode && a.target.parentNode.className && a.target.parentNode.className.indexOf &&
                -1 !== a.target.parentNode.className.indexOf("dialogButtonsItem") || (this._touchMoved = !0, b(a, "mousemove"))
        };
        d._touchEnd = function(a) {
            e && (b(a, "mouseup"), b(a, "mouseout"), b(a, "click"), e = !1)
        };
        d._mouseInit = function() {
            this.element.bind({
                touchstart: c.proxy(this, "_touchStart"),
                touchmove: c.proxy(this, "_touchMove"),
                touchend: c.proxy(this, "_touchEnd")
            });
            f.call(this)
        };
        d._mouseDestroy = function() {
            this.element.unbind({
                touchstart: c.proxy(this, "_touchStart"),
                touchmove: c.proxy(this, "_touchMove"),
                touchend: c.proxy(this, "_touchEnd")
            });
            g.call(this)
        }
    }
})(jQuery);
(function(a) {
    a.idleTimer = function b(c) {
        var d = !1,
            g = !0,
            e = 3E4,
            f = function() {
                d = !d;
                b.olddate = +new Date;
                a(document).trigger(a.data(document, "idleTimer", d ? "idle" : "active") + ".idleTimer")
            };
        b.olddate = b.olddate || +new Date;
        if ("number" == typeof c) e = c;
        else {
            if ("destroy" === c) return g = !1, clearTimeout(a.idleTimer.tId), a(document).unbind(".idleTimer"), this;
            if ("getElapsedTime" === c) return +new Date - b.olddate
        }
        a(document).bind(a.trim("mousemove keydown DOMMouseScroll mousewheel mousedown ".split(" ").join(".idleTimer ")),
            function() {
                clearTimeout(a.idleTimer.tId);
                g && (d && f(), a.idleTimer.tId = setTimeout(f, e))
            });
        a.idleTimer.tId = setTimeout(f, e);
        a.data(document, "idleTimer", "active")
    }
})(jQuery);
(function(a, f) {
    var g = {
        init: function(e, d, b) {
            var c = this;
            this.warning = e = a(e);
            this.resume = a(d);
            this.options = b;
            this.countdownOpen = !1;
            this.failedRequests = b.failedRequests;
            this._startTimer();
            this.title = document.title;
            a.data(e[0], "idletimeout", this);
            a.idleTimer(1E3 * b.idleAfter);
            a(document).bind("idle.idleTimer", function() {
                "idle" !== a.data(document, "idleTimer") || c.countdownOpen || (c._stopTimer(), c.countdownOpen = !0, c._idle())
            });
            this.resume.bind("click", function(a) {
                a.preventDefault();
                f.clearInterval(c.countdown);
                c.countdownOpen = !1;
                c._startTimer();
                c._keepAlive(!1);
                b.onResume.call(c.warning)
            })
        },
        _idle: function() {
            var a = this,
                d = this.options,
                b = this.warning[0],
                c = d.warningLength;
            d.onIdle.call(b);
            d.onCountdown.call(b, c);
            this.countdown = f.setInterval(function() {
                0 === --c ? (window.clearInterval(a.countdown), d.onTimeout.call(b)) : (d.onCountdown.call(b, c), document.title = d.titleMessage.replace("%s", c) + a.title)
            }, 1E3)
        },
        _startTimer: function() {
            var a = this;
            this.timer = f.setTimeout(function() {
                a._keepAlive()
            }, 1E3 * this.options.pollingInterval)
        },
        _stopTimer: function() {
            this.failedRequests = this.options.failedRequests;
            f.clearTimeout(this.timer)
        },
        _keepAlive: function(e) {
            var d = this,
                b = this.options;
            document.title = d.title;
            "undefined" === typeof e && (e = !0);
            this.failedRequests ? a.ajax({
                timeout: b.AJAXTimeout,
                url: b.keepAliveURL,
                error: function() {
                    d.failedRequests--
                },
                success: function(c) {
                    a.trim(c) !== b.serverResponseEquals && d.failedRequests--
                },
                complete: function() {
                    e && d._startTimer()
                }
            }) : (this._stopTimer(), b.onAbort.call(this.warning[0]))
        }
    };
    a.idleTimeout = function(e,
        d, b) {
        g.init(e, d, a.extend(a.idleTimeout.options, b));
        return this
    };
    a.idleTimeout.options = {
        warningLength: 30,
        keepAliveURL: "",
        serverResponseEquals: "OK",
        idleAfter: 600,
        pollingInterval: 60,
        failedRequests: 5,
        AJAXTimeout: 250,
        titleMessage: "Warning: %s seconds until log out | ",
        onTimeout: a.noop,
        onIdle: a.noop,
        onCountdown: a.noop,
        onResume: a.noop,
        onAbort: a.noop
    }
})(jQuery, window);
window.jQuery && function(f) {
    f.extend({
        xml2json: function(a, l) {
            function g(e, a) {
                if (!e) return null;
                var c = "",
                    b = null;
                k(e.localName || e.nodeName);
                e.childNodes && 0 < e.childNodes.length && f.each(e.childNodes, function(e, a) {
                    var n = a.nodeType,
                        d = k(a.localName || a.nodeName),
                        f = a.text || a.nodeValue || "";
                    8 != n && (3 != n && 4 != n && d ? (b = b || {}, b[d] ? (b[d].length || (b[d] = m(b[d])), b[d] = m(b[d]), b[d][b[d].length] = g(a, !0), b[d].length = b[d].length) : b[d] = g(a)) : f.match(/^\s+$/) || (c += f.replace(/^\s+/, "").replace(/\s+$/, "")))
                });
                e.attributes && 0 <
                    e.attributes.length && (b = b || {}, f.each(e.attributes, function(a, e) {
                        var c = k(e.name),
                            d = e.value;
                        b[c] ? (b[cnn] = m(b[cnn]), b[c][b[c].length] = d, b[c].length = b[c].length) : b[c] = d
                    }));
                if (b) {
                    b = f.extend("" != c ? new String(c) : {}, b || {});
                    if (c = b.text ? ("object" == typeof b.text ? b.text : [b.text || ""]).concat([c]) : c) b.text = c;
                    c = ""
                }
                var h = b || c;
                if (l) {
                    c && (h = {});
                    if (c = h.text || c || "") h.text = c;
                    a || (h = m(h))
                }
                return h
            }
            if (!a) return {};
            var k = function(a) {
                    return String(a || "").replace(/-/g, "_")
                },
                m = function(a) {
                    f.isArray(a) || (a = [a]);
                    a.length = a.length;
                    return a
                };
            "string" == typeof a && (a = f.text2xml(a));
            if (a.nodeType) {
                if (3 == a.nodeType || 4 == a.nodeType) return a.nodeValue;
                var p = 9 == a.nodeType ? a.documentElement : a,
                    q = g(p, !0),
                    p = a = null;
                return q
            }
        },
        text2xml: function(a) {
            var l;
            try {
                var g = f.browser.msie ? new ActiveXObject("Microsoft.XMLDOM") : new DOMParser;
                g.async = !1
            } catch (k) {
                throw Error("XML Parser could not be instantiated");
            }
            try {
                l = f.browser.msie ? g.loadXML(a) ? g : !1 : g.parseFromString(a, "text/xml")
            } catch (k) {
                throw Error("Error parsing XML string");
            }
            return l
        }
    })
}(jQuery);
(function(g) {
    g.cookie = function(h, b, a) {
        if (1 < arguments.length && (!/Object/.test(Object.prototype.toString.call(b)) || null === b || void 0 === b)) {
            a = g.extend({}, a);
            if (null === b || void 0 === b) a.expires = -1;
            if ("number" === typeof a.expires) {
                var d = a.expires,
                    c = a.expires = new Date;
                c.setDate(c.getDate() + d)
            }
            b = String(b);
            return document.cookie = [encodeURIComponent(h), "\x3d", a.raw ? b : encodeURIComponent(b), a.expires ? "; expires\x3d" + a.expires.toUTCString() : "", a.path ? "; path\x3d" + a.path : "", a.domain ? "; domain\x3d" + a.domain : "", a.secure ?
                "; secure" : ""
            ].join("")
        }
        a = b || {};
        for (var d = a.raw ? function(a) {
                return a
            } : decodeURIComponent, c = document.cookie.split("; "), e = 0, f; f = c[e] && c[e].split("\x3d"); e++)
            if (d(f[0]) === h) return d(f[1] || "");
        return null
    }
})(jQuery);
jsgradient = {
    inputA: "",
    inputB: "",
    inputC: "",
    gradientElement: "",
    hexToRgb: function(a) {
        var b, c;
        a = a.replace("#", "");
        if (3 !== a.length && 6 !== a.length) return [255, 255, 255];
        3 == a.length && (a = a[0] + a[0] + a[1] + a[1] + a[2] + a[2]);
        b = parseInt(a.substr(0, 2), 16);
        c = parseInt(a.substr(2, 2), 16);
        a = parseInt(a.substr(4, 2), 16);
        return [b, c, a]
    },
    rgbToHex: function(a) {
        a[0] = 255 < a[0] ? 255 : 0 > a[0] ? 0 : a[0];
        a[1] = 255 < a[1] ? 255 : 0 > a[1] ? 0 : a[1];
        a[2] = 255 < a[2] ? 255 : 0 > a[2] ? 0 : a[2];
        return this.zeroFill(a[0].toString(16), 2) + this.zeroFill(a[1].toString(16), 2) +
            this.zeroFill(a[2].toString(16), 2)
    },
    zeroFill: function(a, b) {
        b -= a.toString().length;
        return 0 < b ? Array(b + (/\./.test(a) ? 2 : 1)).join("0") + a : a
    },
    generateGradient: function(a, b, c) {
        var d = [];
        a = this.hexToRgb(a);
        b = this.hexToRgb(b);
        --c;
        rStep = (Math.max(a[0], b[0]) - Math.min(a[0], b[0])) / c;
        gStep = (Math.max(a[1], b[1]) - Math.min(a[1], b[1])) / c;
        bStep = (Math.max(a[2], b[2]) - Math.min(a[2], b[2])) / c;
        d.push("#" + this.rgbToHex(a));
        for (var e = a[0], f = a[1], g = a[2], h = 0; h < c - 1; h++) e = a[0] < b[0] ? e + Math.round(rStep) : e - Math.round(rStep), f = a[1] <
            b[1] ? f + Math.round(gStep) : f - Math.round(gStep), g = a[2] < b[2] ? g + Math.round(bStep) : g - Math.round(bStep), d.push("#" + this.rgbToHex([e, f, g]));
        d.push("#" + this.rgbToHex(b));
        return d
    },
    gradientList: function(a, b, c) {
        c = "object" === typeof c ? c : $(c);
        c = c.find("li");
        var d = jsgradient.generateGradient(a, b, c.length);
        c.each(function(a) {
            $(this).css("backgroundColor", d[a])
        })
    }
};
(function(d) {
    function h(a, b) {
        var c = this,
            f = a.attr("name") || b.name || "";
        this.options = b;
        this.$el = a.hide();
        this.$label = this.$el.closest("label");
        0 === this.$label.length && this.$el.attr("id") && (this.$label = d(e('label[for\x3d"%s"]', this.$el.attr("id").replace(/:/g, "\\:"))));
        this.$parent = d(e('\x3cdiv class\x3d"ms-parent %s" %s/\x3e', a.attr("class") || "", e('title\x3d"%s"', a.attr("title"))));
        this.$choice = d(e('\x3cbutton type\x3d"button" class\x3d"ms-choice"\x3e\x3cspan class\x3d"placeholder"\x3e%s\x3c/span\x3e\x3cdiv\x3e\x3c/div\x3e\x3c/button\x3e',
            this.options.placeholder));
        this.$drop = d(e('\x3cdiv class\x3d"ms-drop %s"%s\x3e\x3c/div\x3e', this.options.position, e(' style\x3d"width: %s"', this.options.dropWidth)));
        this.$el.after(this.$parent);
        this.$parent.append(this.$choice);
        this.$parent.append(this.$drop);
        this.$el.prop("disabled") && this.$choice.addClass("disabled");
        this.$parent.css("width", this.options.width || this.$el.css("width") || this.$el.outerWidth() + 20);
        this.selectAllName = 'data-name\x3d"selectAll' + f + '"';
        this.selectGroupName = 'data-name\x3d"selectGroup' +
            f + '"';
        this.selectItemName = 'data-name\x3d"selectItem' + f + '"';
        this.options.keepOpen || d(document).click(function(b) {
            d(b.target)[0] !== c.$choice[0] && d(b.target).parents(".ms-choice")[0] !== c.$choice[0] && (d(b.target)[0] === c.$drop[0] || d(b.target).parents(".ms-drop")[0] !== c.$drop[0] && b.target !== a[0]) && c.options.isOpen && c.close()
        })
    }
    var e = function(a) {
            var b = arguments,
                c = !0,
                d = 1;
            a = a.replace(/%s/g, function() {
                var a = b[d++];
                return "undefined" === typeof a ? (c = !1, "") : a
            });
            return c ? a : ""
        },
        n = function(a) {
            for (var b = [{
                        base: "A",
                        letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
                    }, {
                        base: "AA",
                        letters: /[\uA732]/g
                    }, {
                        base: "AE",
                        letters: /[\u00C6\u01FC\u01E2]/g
                    }, {
                        base: "AO",
                        letters: /[\uA734]/g
                    }, {
                        base: "AU",
                        letters: /[\uA736]/g
                    }, {
                        base: "AV",
                        letters: /[\uA738\uA73A]/g
                    }, {
                        base: "AY",
                        letters: /[\uA73C]/g
                    }, {
                        base: "B",
                        letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
                    },
                    {
                        base: "C",
                        letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
                    }, {
                        base: "D",
                        letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
                    }, {
                        base: "DZ",
                        letters: /[\u01F1\u01C4]/g
                    }, {
                        base: "Dz",
                        letters: /[\u01F2\u01C5]/g
                    }, {
                        base: "E",
                        letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
                    }, {
                        base: "F",
                        letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
                    },
                    {
                        base: "G",
                        letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
                    }, {
                        base: "H",
                        letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
                    }, {
                        base: "I",
                        letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
                    }, {
                        base: "J",
                        letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g
                    }, {
                        base: "K",
                        letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
                    },
                    {
                        base: "L",
                        letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
                    }, {
                        base: "LJ",
                        letters: /[\u01C7]/g
                    }, {
                        base: "Lj",
                        letters: /[\u01C8]/g
                    }, {
                        base: "M",
                        letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
                    }, {
                        base: "N",
                        letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
                    }, {
                        base: "NJ",
                        letters: /[\u01CA]/g
                    }, {
                        base: "Nj",
                        letters: /[\u01CB]/g
                    }, {
                        base: "O",
                        letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
                    },
                    {
                        base: "OI",
                        letters: /[\u01A2]/g
                    }, {
                        base: "OO",
                        letters: /[\uA74E]/g
                    }, {
                        base: "OU",
                        letters: /[\u0222]/g
                    }, {
                        base: "P",
                        letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
                    }, {
                        base: "Q",
                        letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
                    }, {
                        base: "R",
                        letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
                    }, {
                        base: "S",
                        letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
                    }, {
                        base: "T",
                        letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
                    }, {
                        base: "TZ",
                        letters: /[\uA728]/g
                    }, {
                        base: "U",
                        letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
                    }, {
                        base: "V",
                        letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
                    }, {
                        base: "VY",
                        letters: /[\uA760]/g
                    }, {
                        base: "W",
                        letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
                    },
                    {
                        base: "X",
                        letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
                    }, {
                        base: "Y",
                        letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
                    }, {
                        base: "Z",
                        letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
                    }, {
                        base: "a",
                        letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
                    },
                    {
                        base: "aa",
                        letters: /[\uA733]/g
                    }, {
                        base: "ae",
                        letters: /[\u00E6\u01FD\u01E3]/g
                    }, {
                        base: "ao",
                        letters: /[\uA735]/g
                    }, {
                        base: "au",
                        letters: /[\uA737]/g
                    }, {
                        base: "av",
                        letters: /[\uA739\uA73B]/g
                    }, {
                        base: "ay",
                        letters: /[\uA73D]/g
                    }, {
                        base: "b",
                        letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
                    }, {
                        base: "c",
                        letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
                    }, {
                        base: "d",
                        letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
                    },
                    {
                        base: "dz",
                        letters: /[\u01F3\u01C6]/g
                    }, {
                        base: "e",
                        letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
                    }, {
                        base: "f",
                        letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
                    }, {
                        base: "g",
                        letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
                    }, {
                        base: "h",
                        letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
                    },
                    {
                        base: "hv",
                        letters: /[\u0195]/g
                    }, {
                        base: "i",
                        letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
                    }, {
                        base: "j",
                        letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
                    }, {
                        base: "k",
                        letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
                    }, {
                        base: "l",
                        letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
                    }, {
                        base: "lj",
                        letters: /[\u01C9]/g
                    },
                    {
                        base: "m",
                        letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
                    }, {
                        base: "n",
                        letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
                    }, {
                        base: "nj",
                        letters: /[\u01CC]/g
                    }, {
                        base: "o",
                        letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
                    },
                    {
                        base: "oi",
                        letters: /[\u01A3]/g
                    }, {
                        base: "ou",
                        letters: /[\u0223]/g
                    }, {
                        base: "oo",
                        letters: /[\uA74F]/g
                    }, {
                        base: "p",
                        letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
                    }, {
                        base: "q",
                        letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
                    }, {
                        base: "r",
                        letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
                    }, {
                        base: "s",
                        letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
                    },
                    {
                        base: "t",
                        letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
                    }, {
                        base: "tz",
                        letters: /[\uA729]/g
                    }, {
                        base: "u",
                        letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
                    }, {
                        base: "v",
                        letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
                    }, {
                        base: "vy",
                        letters: /[\uA761]/g
                    }, {
                        base: "w",
                        letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
                    },
                    {
                        base: "x",
                        letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
                    }, {
                        base: "y",
                        letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
                    }, {
                        base: "z",
                        letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
                    }
                ], c = 0; c < b.length; c++) a = a.replace(b[c].letters, b[c].base);
            return a
        };
    h.prototype = {
        constructor: h,
        init: function() {
            var a = this,
                b = d("\x3cul\x3e\x3c/ul\x3e");
            this.$drop.html("");
            this.options.filter && this.$drop.append('\x3cdiv class\x3d"ms-search"\x3e\x3cinput type\x3d"text" autocomplete\x3d"off" autocorrect\x3d"off" autocapitilize\x3d"off" spellcheck\x3d"false"\x3e\x3c/div\x3e');
            this.options.selectAll && !this.options.single && b.append(['\x3cli class\x3d"ms-select-all"\x3e\x3clabel\x3e', e('\x3cinput type\x3d"checkbox" %s /\x3e ', this.selectAllName), this.options.selectAllDelimiter[0], this.options.selectAllText, this.options.selectAllDelimiter[1], "\x3c/label\x3e\x3c/li\x3e"].join(""));
            d.each(this.$el.children(), function(c, d) {
                b.append(a.optionToHtml(c, d))
            });
            b.append(e('\x3cli class\x3d"ms-no-results"\x3e%s\x3c/li\x3e', this.options.noMatchesFound));
            this.$drop.append(b);
            this.$drop.find("ul").css("max-height",
                this.options.maxHeight + "px");
            this.$drop.find(".multiple").css("width", this.options.multipleWidth + "px");
            this.$searchInput = this.$drop.find(".ms-search input");
            this.$selectAll = this.$drop.find("input[" + this.selectAllName + "]");
            this.$selectGroups = this.$drop.find("input[" + this.selectGroupName + "]");
            this.$selectItems = this.$drop.find("input[" + this.selectItemName + "]:enabled");
            this.$disableItems = this.$drop.find("input[" + this.selectItemName + "]:disabled");
            this.$noResults = this.$drop.find(".ms-no-results");
            this.events();
            this.updateSelectAll(!0);
            this.update(!0);
            this.options.isOpen && this.open()
        },
        optionToHtml: function(a, b, c, f) {
            var m = this;
            b = d(b);
            var k = b.attr("class") || "",
                l = e('title\x3d"%s"', b.attr("title")),
                q = this.options.multiple ? "multiple" : "",
                g, h = this.options.single ? "radio" : "checkbox";
            if (b.is("option")) {
                a = b.val();
                var n = m.options.textTemplate(b),
                    r = b.prop("selected"),
                    t = e('style\x3d"%s"', this.options.styler(a));
                g = f || b.prop("disabled");
                f = d([e('\x3cli class\x3d"%s %s" %s %s\x3e', q, k, l, t), e('\x3clabel class\x3d"%s"\x3e',
                    g ? "disabled" : ""), e('\x3cinput type\x3d"%s" %s%s%s%s\x3e', h, this.selectItemName, r ? ' checked\x3d"checked"' : "", g ? ' disabled\x3d"disabled"' : "", e(' data-group\x3d"%s"', c)), e("\x3cspan\x3e%s\x3c/span\x3e", n), "\x3c/label\x3e\x3c/li\x3e"].join(""));
                f.find("input").val(a);
                return f
            }
            if (b.is("optgroup")) {
                f = m.options.labelTemplate(b);
                var p = d("\x3cdiv/\x3e");
                c = "group_" + a;
                g = b.prop("disabled");
                p.append(['\x3cli class\x3d"group"\x3e', e('\x3clabel class\x3d"optgroup %s" data-group\x3d"%s"\x3e', g ? "disabled" : "", c), this.options.hideOptgroupCheckboxes ||
                    this.options.single ? "" : e('\x3cinput type\x3d"checkbox" %s %s\x3e', this.selectGroupName, g ? 'disabled\x3d"disabled"' : ""), f, "\x3c/label\x3e\x3c/li\x3e"
                ].join(""));
                d.each(b.children(), function(a, b) {
                    p.append(m.optionToHtml(a, b, c, g))
                });
                return p.html()
            }
        },
        events: function() {
            var a = this,
                b = function(c) {
                    c.preventDefault();
                    a[a.options.isOpen ? "close" : "open"]()
                };
            if (this.$label) this.$label.off("click").on("click", function(c) {
                "label" === c.target.nodeName.toLowerCase() && c.target === this && (b(c), a.options.filter && a.options.isOpen ||
                    a.focus(), c.stopPropagation())
            });
            this.$choice.off("click").on("click", b).off("focus").on("focus", this.options.onFocus).off("blur").on("blur", this.options.onBlur);
            this.$parent.off("keydown").on("keydown", function(c) {
                switch (c.which) {
                    case 27:
                        a.close(), a.$choice.focus()
                }
            });
            this.$searchInput.off("keydown").on("keydown", function(c) {
                9 === c.keyCode && c.shiftKey && a.close()
            }).off("keyup").on("keyup", function(c) {
                a.options.filterAcceptOnEnter && (13 === c.which || 32 == c.which) && a.$searchInput.val() ? (a.$selectAll.click(),
                    a.close(), a.focus()) : a.filter()
            });
            this.$selectAll.off("click").on("click", function() {
                var c = d(this).prop("checked"),
                    b = a.$selectItems.filter(":visible");
                if (b.length === a.$selectItems.length) a[c ? "checkAll" : "uncheckAll"]();
                else a.$selectGroups.prop("checked", c), b.prop("checked", c), a.options[c ? "onCheckAll" : "onUncheckAll"](), a.update()
            });
            this.$selectGroups.off("click").on("click", function() {
                var c = d(this).parent().attr("data-group"),
                    c = a.$selectItems.filter(":visible").filter(e('[data-group\x3d"%s"]', c)),
                    b = c.length !== c.filter(":checked").length;
                c.prop("checked", b);
                a.updateSelectAll();
                a.update();
                a.options.onOptgroupClick({
                    label: d(this).parent().text(),
                    checked: b,
                    children: c.get(),
                    instance: a
                })
            });
            this.$selectItems.off("click").on("click", function() {
                a.updateSelectAll();
                a.update();
                a.updateOptGroupSelect();
                a.options.onClick({
                    label: d(this).parent().text(),
                    value: d(this).val(),
                    checked: d(this).prop("checked"),
                    instance: a
                });
                a.options.single && a.options.isOpen && !a.options.keepOpen && a.close();
                if (a.options.single) {
                    var c =
                        d(this).val();
                    a.$selectItems.filter(function() {
                        return d(this).val() !== c
                    }).each(function() {
                        d(this).prop("checked", !1)
                    });
                    a.update()
                }
            })
        },
        open: function() {
            if (!this.$choice.hasClass("disabled")) {
                this.options.isOpen = !0;
                this.$choice.find("\x3ediv").addClass("open");
                this.$drop[this.animateMethod("show")]();
                this.$selectAll.parent().show();
                this.$noResults.hide();
                this.$el.children().length || (this.$selectAll.parent().hide(), this.$noResults.show());
                if (this.options.container) {
                    var a = this.$drop.offset();
                    this.$drop.appendTo(d(this.options.container));
                    this.$drop.offset({
                        top: a.top,
                        left: a.left
                    })
                }
                this.options.filter && (this.$searchInput.val(""), this.$searchInput.focus(), this.filter());
                this.options.onOpen()
            }
        },
        close: function() {
            this.options.isOpen = !1;
            this.$choice.find("\x3ediv").removeClass("open");
            this.$drop[this.animateMethod("hide")]();
            this.options.container && (this.$parent.append(this.$drop), this.$drop.css({
                top: "auto",
                left: "auto"
            }));
            this.options.onClose()
        },
        animateMethod: function(a) {
            return {
                show: {
                    fade: "fadeIn",
                    slide: "slideDown"
                },
                hide: {
                    fade: "fadeOut",
                    slide: "slideUp"
                }
            }[a][this.options.animate] || a
        },
        update: function(a) {
            var b = this.options.displayValues ? this.getSelects() : this.getSelects("text"),
                c = this.$choice.find("\x3espan"),
                f = b.length;
            0 === f ? c.addClass("placeholder").html(this.options.placeholder) : this.options.allSelected && f === this.$selectItems.length + this.$disableItems.length ? c.removeClass("placeholder").html(this.options.allSelected) : this.options.ellipsis && f > this.options.minimumCountSelected ? c.removeClass("placeholder").text(b.slice(0, this.options.minimumCountSelected).join(this.options.delimiter) +
                "...") : this.options.countSelected && f > this.options.minimumCountSelected ? c.removeClass("placeholder").html(this.options.countSelected.replace("#", b.length).replace("%", this.$selectItems.length + this.$disableItems.length)) : c.removeClass("placeholder").text(b.join(this.options.delimiter));
            this.options.addTitle && c.prop("title", this.getSelects("text"));
            this.$el.val(this.getSelects()).trigger("change");
            this.$drop.find("li").removeClass("selected");
            this.$drop.find("input:checked").each(function() {
                d(this).parents("li").first().addClass("selected")
            });
            a || this.$el.trigger("change")
        },
        updateSelectAll: function(a) {
            var b = this.$selectItems;
            a || (b = b.filter(":visible"));
            this.$selectAll.prop("checked", b.length && b.length === b.filter(":checked").length);
            if (!a && this.$selectAll.prop("checked")) this.options.onCheckAll()
        },
        updateOptGroupSelect: function() {
            var a = this.$selectItems.filter(":visible");
            d.each(this.$selectGroups, function(b, c) {
                var f = d(c).parent().attr("data-group"),
                    f = a.filter(e('[data-group\x3d"%s"]', f));
                d(c).prop("checked", f.length && f.length === f.filter(":checked").length)
            })
        },
        getSelects: function(a) {
            var b = this,
                c = [],
                f = [];
            this.$drop.find(e("input[%s]:checked", this.selectItemName)).each(function() {
                c.push(d(this).parents("li").first().text());
                f.push(d(this).val())
            });
            "text" === a && this.$selectGroups.length && (c = [], this.$selectGroups.each(function() {
                var a = [],
                    f = d.trim(d(this).parent().text()),
                    l = d(this).parent().data("group"),
                    l = b.$drop.find(e('[%s][data-group\x3d"%s"]', b.selectItemName, l)),
                    h = l.filter(":checked");
                if (h.length) {
                    a.push("[");
                    a.push(f);
                    if (l.length > h.length) {
                        var g = [];
                        h.each(function() {
                            g.push(d(this).parent().text())
                        });
                        a.push(": " + g.join(", "))
                    }
                    a.push("]");
                    c.push(a.join(""))
                }
            }));
            return "text" === a ? c : f
        },
        setSelects: function(a) {
            var b = this;
            this.$selectItems.prop("checked", !1);
            this.$disableItems.prop("checked", !1);
            d.each(a, function(a, d) {
                b.$selectItems.filter(e('[value\x3d"%s"]', d)).prop("checked", !0);
                b.$disableItems.filter(e('[value\x3d"%s"]', d)).prop("checked", !0)
            });
            this.$selectAll.prop("checked", this.$selectItems.length === this.$selectItems.filter(":checked").length + this.$disableItems.filter(":checked").length);
            d.each(b.$selectGroups,
                function(a, f) {
                    var e = d(f).parent().attr("data-group"),
                        e = b.$selectItems.filter('[data-group\x3d"' + e + '"]');
                    d(f).prop("checked", e.length && e.length === e.filter(":checked").length)
                });
            this.update()
        },
        enable: function() {
            this.$choice.removeClass("disabled")
        },
        disable: function() {
            this.$choice.addClass("disabled")
        },
        checkAll: function() {
            this.$selectItems.prop("checked", !0);
            this.$selectGroups.prop("checked", !0);
            this.$selectAll.prop("checked", !0);
            this.update();
            this.options.onCheckAll()
        },
        uncheckAll: function() {
            this.$selectItems.prop("checked", !1);
            this.$selectGroups.prop("checked", !1);
            this.$selectAll.prop("checked", !1);
            this.update();
            this.options.onUncheckAll()
        },
        focus: function() {
            this.$choice.focus();
            this.options.onFocus()
        },
        blur: function() {
            this.$choice.blur();
            this.options.onBlur()
        },
        refresh: function() {
            this.init()
        },
        filter: function() {
            var a = this,
                b = d.trim(this.$searchInput.val()).toLowerCase();
            0 === b.length ? (this.$selectAll.parent().show(), this.$selectItems.parent().show(), this.$disableItems.parent().show(), this.$selectGroups.parent().show(), this.$noResults.hide()) :
                (this.$selectItems.each(function() {
                    var a = d(this).parent();
                    a[0 > n(a.text().toLowerCase()).indexOf(n(b)) ? "hide" : "show"]()
                }), this.$disableItems.parent().hide(), this.$selectGroups.each(function() {
                    var b = d(this).parent(),
                        f = b.attr("data-group"),
                        m = a.$selectItems.filter(":visible");
                    b[m.filter(e('[data-group\x3d"%s"]', f)).length ? "show" : "hide"]()
                }), this.$selectItems.parent().filter(":visible").length ? (this.$selectAll.parent().show(), this.$noResults.hide()) : (this.$selectAll.parent().hide(), this.$noResults.show()));
            this.updateOptGroupSelect();
            this.updateSelectAll();
            this.options.onFilter(b)
        }
    };
    d.fn.multipleSelect = function() {
        var a = arguments[0],
            b = arguments,
            c, f = "getSelects setSelects enable disable open close checkAll uncheckAll focus blur refresh close".split(" ");
        this.each(function() {
            var e = d(this),
                k = e.data("multipleSelect"),
                l = d.extend({}, d.fn.multipleSelect.defaults, e.data(), "object" === typeof a && a);
            k || (k = new h(e, l), e.data("multipleSelect", k));
            if ("string" === typeof a) {
                if (0 > d.inArray(a, f)) throw "Unknown method: " +
                    a;
                c = k[a](b[1])
            } else k.init(), b[1] && (c = k[b[1]].apply(k, [].slice.call(b, 2)))
        });
        return "undefined" !== typeof c ? c : this
    };
    d.fn.multipleSelect.defaults = {
        name: "",
        isOpen: !1,
        placeholder: "",
        selectAll: !0,
        selectAllDelimiter: ["[", "]"],
        minimumCountSelected: 3,
        ellipsis: !1,
        multiple: !1,
        multipleWidth: 80,
        single: !1,
        filter: !1,
        width: void 0,
        dropWidth: void 0,
        maxHeight: 250,
        container: null,
        position: "bottom",
        keepOpen: !1,
        animate: "none",
        displayValues: !1,
        delimiter: ", ",
        addTitle: !1,
        filterAcceptOnEnter: !1,
        hideOptgroupCheckboxes: !1,
        selectAllText: "Select all",
        allSelected: "All selected",
        countSelected: "# of % selected",
        noMatchesFound: "No matches found",
        styler: function() {
            return !1
        },
        textTemplate: function(a) {
            return a.html()
        },
        labelTemplate: function(a) {
            return a.attr("label")
        },
        onOpen: function() {
            return !1
        },
        onClose: function() {
            return !1
        },
        onCheckAll: function() {
            return !1
        },
        onUncheckAll: function() {
            return !1
        },
        onFocus: function() {
            return !1
        },
        onBlur: function() {
            return !1
        },
        onOptgroupClick: function() {
            return !1
        },
        onClick: function() {
            return !1
        },
        onFilter: function() {
            return !1
        }
    }
})(jQuery);
this.JSON || (this.JSON = {});
(function() {
    function b(a) {
        return 10 > a ? "0" + a : a
    }

    function k(a) {
        r.lastIndex = 0;
        return r.test(a) ? '"' + a.replace(r, function(a) {
            var d = u[a];
            return "string" === typeof d ? d : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
        }) + '"' : '"' + a + '"'
    }

    function m(a, g) {
        var d, b, q = e,
            f, c = g[a];
        c && "object" === typeof c && "function" === typeof c.toJSON && (c = c.toJSON(a));
        "function" === typeof l && (c = l.call(g, a, c));
        switch (typeof c) {
            case "string":
                return k(c);
            case "number":
                return isFinite(c) ? String(c) : "null";
            case "boolean":
            case "null":
                return String(c);
            case "object":
                if (!c) return "null";
                e += n;
                f = [];
                if ("[object Array]" === Object.prototype.toString.apply(c)) {
                    b = c.length;
                    for (a = 0; a < b; a += 1) f[a] = m(a, c) || "null";
                    g = 0 === f.length ? "[]" : e ? "[\n" + e + f.join(",\n" + e) + "\n" + q + "]" : "[" + f.join(",") + "]";
                    e = q;
                    return g
                }
                if (l && "object" === typeof l)
                    for (b = l.length, a = 0; a < b; a += 1) d = l[a], "string" === typeof d && (g = m(d, c)) && f.push(k(d) + (e ? ": " : ":") + g);
                else
                    for (d in c) Object.hasOwnProperty.call(c, d) && (g = m(d, c)) && f.push(k(d) + (e ? ": " : ":") + g);
                g = 0 === f.length ? "{}" : e ? "{\n" + e + f.join(",\n" + e) + "\n" + q + "}" : "{" + f.join(",") + "}";
                e = q;
                return g
        }
    }
    "function" !== typeof Date.prototype.toJSON && (Date.prototype.toJSON = function() {
        return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + b(this.getUTCMonth() + 1) + "-" + b(this.getUTCDate()) + "T" + b(this.getUTCHours()) + ":" + b(this.getUTCMinutes()) + ":" + b(this.getUTCSeconds()) + "Z" : null
    }, String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
        return this.valueOf()
    });
    var t = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        r = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        e, n, u = {
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            '"': '\\"',
            "\\": "\\\\"
        },
        l;
    "function" !== typeof JSON.stringify && (JSON.stringify = function(a, b, d) {
        var p;
        n = e = "";
        if ("number" === typeof d)
            for (p = 0; p < d; p += 1) n += " ";
        else "string" === typeof d && (n = d);
        if ((l = b) && "function" !== typeof b && ("object" !== typeof b || "number" !== typeof b.length)) throw Error("JSON.stringify");
        return m("", {
            "": a
        })
    });
    "function" !== typeof JSON.parse && (JSON.parse = function(a, b) {
        function d(a, e) {
            var f, c, h = a[e];
            if (h && "object" === typeof h)
                for (f in h) Object.hasOwnProperty.call(h,
                    f) && (c = d(h, f), void 0 !== c ? h[f] = c : delete h[f]);
            return b.call(a, e, h)
        }
        t.lastIndex = 0;
        t.test(a) && (a = a.replace(t, function(a) {
            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
        }));
        if (/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return a = eval("(" + a + ")"), "function" === typeof b ? d({
            "": a
        }, "") : a;
        throw new SyntaxError("JSON.parse");
    })
})();
jQuery.fn.serializeObject = function() {
    var b = {},
        k = this.serializeArray();
    jQuery.each(k, function() {
        b[this.name] ? (b[this.name].push || (b[this.name] = [b[this.name]]), b[this.name].push(this.value || "")) : b[this.name] = this.value || ""
    });
    return b
};
jQuery.postJSON = function(b, k, m) {
    return jQuery.ajax({
        type: "POST",
        url: b,
        contentType: "application/json",
        data: JSON.stringify(k),
        dataType: "json",
        success: m
    })
};
(function(d) {
    function x(a, b, f) {
        var c = a[0],
            g = /er/.test(f) ? "indeterminate" : /bl/.test(f) ? "disabled" : "checked",
            e = "update" == f ? {
                checked: c.checked,
                disabled: c.disabled,
                indeterminate: "true" == a.attr("indeterminate") || "false" == a.attr("determinate")
            } : c[g];
        if (/^(ch|di|in)/.test(f) && !e) u(a, g);
        else if (/^(un|en|de)/.test(f) && e) n(a, g);
        else if ("update" == f)
            for (var d in e) e[d] ? u(a, d, !0) : n(a, d, !0);
        else b && "toggle" != f || (b || a.trigger("ifClicked"), e ? "radio" !== c.type && n(a, g) : u(a, g))
    }

    function u(a, b, f) {
        var c = a[0],
            g = a.parent(),
            e = "checked" == b,
            l = "indeterminate" == b,
            y = "disabled" == b,
            p = l ? "determinate" : e ? "unchecked" : "enabled",
            C = k(a, p + q(c.type)),
            r = k(a, b + q(c.type));
        if (!0 !== c[b]) {
            if (!f && "checked" == b && "radio" == c.type && c.name) {
                var t = a.closest("form"),
                    m = 'input[name\x3d"' + c.name + '"]',
                    m = t.length ? t.find(m) : d(m);
                m.each(function() {
                    this !== c && d(this).data("iCheck") && n(d(this), b)
                })
            }
            l ? (c[b] = !0, c.checked && n(a, "checked", "force")) : (f || (c[b] = !0), e && c.indeterminate && n(a, "indeterminate", !1));
            v(a, e, b, f)
        }
        c.disabled && k(a, "cursor", !0) && g.find(".iCheck-helper").css("cursor",
            "default");
        g.addClass(r || k(a, b) || "");
        g.attr("role") && !l && g.attr("aria-" + (y ? "disabled" : "checked"), "true");
        g.removeClass(C || k(a, p) || "");
        f || (-1 === a[0].className.indexOf("_LayerSelect") && d(a).trigger("click"), a.get(0).checked = !0, jQuery(a).trigger("change"))
    }

    function n(a, b, f) {
        var c = a[0],
            d = a.parent(),
            e = "checked" == b,
            l = "indeterminate" == b,
            y = "disabled" == b,
            p = l ? "determinate" : e ? "unchecked" : "enabled",
            n = k(a, p + q(c.type)),
            r = k(a, b + q(c.type));
        if (!1 !== c[b]) {
            if (l || !f || "force" == f) c[b] = !1;
            v(a, e, p, f)
        }!c.disabled && k(a, "cursor", !0) && d.find(".iCheck-helper").css("cursor", "pointer");
        d.removeClass(r || k(a, b) || "");
        d.attr("role") && !l && d.attr("aria-" + (y ? "disabled" : "checked"), "false");
        d.addClass(n || k(a, p) || "");
        f || (a.get(0).checked = !1, "checkbox" == a.get(0).type && jQuery(a).trigger("change"))
    }

    function A(a, b) {
        a.data("iCheck") && (a.parent().html(a.attr("style", a.data("iCheck").s || "")), b && a.trigger(b), a.off(".i").unwrap(), d('label[for\x3d"' + a[0].id + '"]').add(a.closest("label")).off(".i"))
    }

    function k(a, b, d) {
        if (a.data("iCheck")) return a.data("iCheck").o[b +
            (d ? "" : "Class")]
    }

    function q(a) {
        return a.charAt(0).toUpperCase() + a.slice(1)
    }

    function v(a, b, d, c) {
        c || (b && a.trigger("ifToggled"), a.trigger("ifChanged").trigger("if" + q(d)))
    }
    var z = /ipad|iphone|ipod|android|blackberry|windows phone|opera mini|silk/i.test(navigator.userAgent);
    d.fn.iCheck = function(a, b) {
        var f = 'input[type\x3d"checkbox"], input[type\x3d"radio"]',
            c = d(),
            g = function(a) {
                a.each(function() {
                    var a = d(this);
                    c = a.is(f) ? c.add(a) : c.add(a.find(f))
                })
            };
        if (/^(check|uncheck|toggle|indeterminate|determinate|disable|enable|update|destroy)$/i.test(a)) return a =
            a.toLowerCase(), g(this), c.each(function() {
                var c = d(this);
                "destroy" == a ? A(c, "ifDestroyed") : x(c, !0, a);
                d.isFunction(b) && b()
            });
        if ("object" != typeof a && a) return this;
        var e = d.extend({
                checkedClass: "checked",
                disabledClass: "disabled",
                indeterminateClass: "indeterminate",
                labelHover: !0
            }, a),
            l = e.handle,
            k = e.hoverClass || "hover",
            p = e.focusClass || "focus",
            q = e.activeClass || "active",
            r = !!e.labelHover,
            t = e.labelHoverClass || "hover",
            m = ("" + e.increaseArea).replace("%", "") | 0;
        if ("checkbox" == l || "radio" == l) f = 'input[type\x3d"' + l + '"]'; -
        50 > m && (m = -50);
        g(this);
        return c.each(function() {
            var a = d(this);
            A(a);
            var c = this,
                b = c.id,
                f = -m + "%",
                g = 100 + 2 * m + "%",
                g = {
                    position: "absolute",
                    top: f,
                    left: f,
                    display: "block",
                    width: g,
                    height: g,
                    margin: 0,
                    padding: 0,
                    background: "#fff",
                    border: 0,
                    opacity: 0
                },
                f = z ? {
                    position: "absolute",
                    visibility: "hidden"
                } : m ? g : {
                    position: "absolute",
                    opacity: 0
                },
                l = "checkbox" == c.type ? e.checkboxClass || "icheckbox" : e.radioClass || "iradio",
                w = d('label[for\x3d"' + b + '"]').add(a.closest("label")),
                v = !!e.aria,
                B = "iCheck-" + Math.random().toString(36).substr(2,
                    6),
                h = '\x3cdiv class\x3d"' + l + '" ' + (v ? 'role\x3d"' + c.type + '" ' : "");
            v && w.each(function() {
                h += 'aria-labelledby\x3d"';
                this.id ? h += this.id : (this.id = B, h += B);
                h += '"'
            });
            h = a.wrap(h + "/\x3e").trigger("ifCreated").parent().append(e.insert);
            g = d('\x3cins class\x3d"iCheck-helper"/\x3e').css(g).appendTo(h);
            a.data("iCheck", {
                o: e,
                s: a.attr("style")
            }).css(f);
            e.inheritClass && h.addClass(c.className || "");
            e.inheritID && b && h.attr("id", "iCheck-" + b);
            "static" == h.css("position") && h.css("position", "relative");
            x(a, !0, "update");
            if (w.length) w.on("click.i mouseover.i mouseout.i touchbegin.i touchend.i",
                function(b) {
                    var e = b.type,
                        f = d(this);
                    if (!c.disabled) {
                        if ("click" == e) {
                            if (d(b.target).is("a")) return;
                            x(a, !1, !0)
                        } else r && (/ut|nd/.test(e) ? (h.removeClass(k), f.removeClass(t)) : (h.addClass(k), f.addClass(t)));
                        if (z) b.stopPropagation();
                        else return !1
                    }
                });
            a.on("click.i focus.i blur.i keyup.i keydown.i keypress.i", function(b) {
                var d = b.type;
                b = b.keyCode;
                if ("click" == d) return !1;
                if ("keydown" == d && 32 == b) return "radio" == c.type && c.checked || (c.checked ? n(a, "checked") : u(a, "checked")), !1;
                if ("keyup" == d && "radio" == c.type) !c.checked &&
                    u(a, "checked");
                else if (/us|ur/.test(d)) h["blur" == d ? "removeClass" : "addClass"](p)
            });
            g.on("click mousedown mouseup mouseover mouseout touchbegin.i touchend.i", function(b) {
                var d = b.type,
                    e = /wn|up/.test(d) ? q : k;
                if (!c.disabled) {
                    if ("click" == d) x(a, !1, !0);
                    else if (/wn|er|in/.test(d) ? h.addClass(e) : h.removeClass(e + " " + q), w.length && r && e == k) w[/ut|nd/.test(d) ? "removeClass" : "addClass"](t);
                    if (z) b.stopPropagation();
                    else return !1
                }
            })
        })
    }
})(window.jQuery || window.Zepto);
! function(d) {
    d(window.jQuery, window, document)
}(function(d, p, w, x) {
    d.widget("selectBox.selectBoxIt", {
        VERSION: "3.8.1",
        options: {
            showEffect: "none",
            showEffectOptions: {},
            showEffectSpeed: "medium",
            hideEffect: "none",
            hideEffectOptions: {},
            hideEffectSpeed: "medium",
            showFirstOption: !0,
            defaultText: "",
            defaultIcon: "",
            downArrowIcon: "",
            theme: "default",
            keydownOpen: !0,
            isMobile: function() {
                return /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/.test(navigator.userAgent || navigator.vendor || p.opera)
            },
            "native": !1,
            aggressiveChange: !1,
            selectWhenHidden: !0,
            viewport: d(p),
            similarSearch: !1,
            copyAttributes: ["title", "rel"],
            copyClasses: "button",
            nativeMousedown: !1,
            customShowHideEvent: !1,
            autoWidth: !0,
            html: !0,
            populate: "",
            dynamicPositioning: !0,
            hideCurrent: !1
        },
        getThemes: function() {
            var a = d(this.element).attr("data-theme") || "c";
            return {
                bootstrap: {
                    focus: "active",
                    hover: "",
                    enabled: "enabled",
                    disabled: "disabled",
                    arrow: "caret",
                    button: "btn",
                    list: "dropdown-menu",
                    container: "bootstrap",
                    open: "open"
                },
                jqueryui: {
                    focus: "ui-state-focus",
                    hover: "ui-state-hover",
                    enabled: "ui-state-enabled",
                    disabled: "ui-state-disabled",
                    arrow: "ui-icon ui-icon-triangle-1-s",
                    button: "ui-widget ui-state-default",
                    list: "ui-widget ui-widget-content",
                    container: "jqueryui",
                    open: "selectboxit-open"
                },
                jquerymobile: {
                    focus: "ui-btn-down-" + a,
                    hover: "ui-btn-hover-" + a,
                    enabled: "ui-enabled",
                    disabled: "ui-disabled",
                    arrow: "ui-icon ui-icon-arrow-d ui-icon-shadow",
                    button: "ui-btn ui-btn-icon-right ui-btn-corner-all ui-shadow ui-btn-up-" + a,
                    list: "ui-btn ui-btn-icon-right ui-btn-corner-all ui-shadow ui-btn-up-" +
                        a,
                    container: "jquerymobile",
                    open: "selectboxit-open"
                },
                "default": {
                    focus: "selectboxit-focus",
                    hover: "selectboxit-hover",
                    enabled: "selectboxit-enabled",
                    disabled: "selectboxit-disabled",
                    arrow: "selectboxit-default-arrow",
                    button: "selectboxit-btn",
                    list: "selectboxit-list",
                    container: "selectboxit-container",
                    open: "selectboxit-open"
                }
            }
        },
        isDeferred: function(a) {
            return d.isPlainObject(a) && a.promise && a.done
        },
        _create: function(a) {
            var c = this.options.populate,
                b = this.options.theme;
            if (this.element.is("select")) return this.widgetProto =
                d.Widget.prototype, this.originalElem = this.element[0], this.selectBox = this.element, this.options.populate && this.add && !a && this.add(c), this.selectItems = this.element.find("option"), this.firstSelectItem = this.selectItems.slice(0, 1), this.documentHeight = d(w).height(), this.theme = d.isPlainObject(b) ? d.extend({}, this.getThemes()["default"], b) : this.getThemes()[b] ? this.getThemes()[b] : this.getThemes()["default"], this.currentFocus = 0, this.blur = !0, this.textArray = [], this.currentIndex = 0, this.currentText = "", this.flipped = !1, a || (this.selectBoxStyles = this.selectBox.attr("style")), this._createDropdownButton()._createUnorderedList()._copyAttributes()._replaceSelectBox()._addClasses(this.theme)._eventHandlers(), this.originalElem.disabled && this.disable && this.disable(), this._ariaAccessibility && this._ariaAccessibility(), this.isMobile = this.options.isMobile(), this._mobile && this._mobile(), this.options["native"] && this._applyNativeSelect(), this.triggerEvent("create"), this
        },
        _createDropdownButton: function() {
            var a = this.originalElemId =
                this.originalElem.id || "",
                c = this.originalElemValue = this.originalElem.value || "",
                b = this.originalElemName = this.originalElem.name || "",
                h = this.options.copyClasses,
                g = this.selectBox.attr("class") || "";
            return this.dropdownText = d("\x3cspan/\x3e", {
                id: a && a + "SelectBoxItText",
                "class": "selectboxit-text",
                unselectable: "on",
                text: this.firstSelectItem.text()
            }).attr("data-val", c), this.dropdownImageContainer = d("\x3cspan/\x3e", {
                "class": "selectboxit-option-icon-container"
            }), this.dropdownImage = d("\x3ci/\x3e", {
                id: a && a + "SelectBoxItDefaultIcon",
                "class": "selectboxit-default-icon",
                unselectable: "on"
            }), this.dropdown = d("\x3cspan/\x3e", {
                id: a && a + "SelectBoxIt",
                "class": "selectboxit " + ("button" === h ? g : "") + " " + (this.selectBox.prop("disabled") ? this.theme.disabled : this.theme.enabled),
                name: b,
                tabindex: this.selectBox.attr("tabindex") || "0",
                unselectable: "on"
            }).append(this.dropdownImageContainer.append(this.dropdownImage)).append(this.dropdownText), this.dropdownContainer = d("\x3cspan/\x3e", {
                id: a && a + "SelectBoxItContainer",
                "class": "selectboxit-container " + this.theme.container +
                    " " + ("container" === h ? g : "")
            }).append(this.dropdown), this
        },
        _createUnorderedList: function() {
            var a, c, b, h, g, e, f, l, m, u, q, n, t, k = this,
                v = "",
                r = k.originalElemId || "",
                r = d("\x3cul/\x3e", {
                    id: r && r + "SelectBoxItOptions",
                    "class": "selectboxit-options",
                    tabindex: -1
                });
            if (k.options.showFirstOption || (k.selectItems.first().attr("disabled", "disabled"), k.selectItems = k.selectBox.find("option").slice(1)), k.selectItems.each(function(p) {
                    n = d(this);
                    b = c = "";
                    a = n.prop("disabled");
                    h = n.attr("data-icon") || "";
                    e = (g = n.attr("data-iconurl") ||
                        "") ? "selectboxit-option-icon-url" : "";
                    f = g ? "style\x3d\"background-image:url('" + g + "');\"" : "";
                    l = n.attr("data-selectedtext");
                    q = (m = n.attr("data-text")) ? m : n.text();
                    t = n.parent();
                    t.is("optgroup") && (c = "selectboxit-optgroup-option", 0 === n.index() && (b = '\x3cspan class\x3d"selectboxit-optgroup-header ' + t.first().attr("class") + '"data-disabled\x3d"true"\x3e' + t.first().attr("label") + "\x3c/span\x3e"));
                    n.attr("value", this.value);
                    v += b + '\x3cli data-id\x3d"' + p + '" data-val\x3d"' + this.value + '" data-disabled\x3d"' + a + '" class\x3d"' +
                        c + " selectboxit-option " + (d(this).attr("class") || "") + '"' + (this.style.cssText ? ' style\x3d"' + this.style.cssText + '"' : "") + '\x3e\x3ca class\x3d"selectboxit-option-anchor"\x3e\x3cspan class\x3d"selectboxit-option-icon-container"\x3e\x3ci class\x3d"selectboxit-option-icon ' + h + " " + (e || k.theme.container) + '"' + f + "\x3e\x3c/i\x3e\x3c/span\x3e" + (k.options.html ? q : k.htmlEscape(q)) + "\x3c/a\x3e\x3c/li\x3e";
                    u = n.attr("data-search");
                    k.textArray[p] = a ? "" : u ? u : q;
                    this.selected && (k._setText(k.dropdownText, l || q), k.currentFocus =
                        p)
                }), k.options.defaultText || k.selectBox.attr("data-text")) {
                var p = k.options.defaultText || k.selectBox.attr("data-text");
                k._setText(k.dropdownText, p);
                k.options.defaultText = p
            }
            return r.append(v), k.list = r, k.dropdownContainer.append(k.list), k.listItems = k.list.children("li"), k.listAnchors = k.list.find("a"), k.listItems.first().addClass("selectboxit-option-first"), k.listItems.last().addClass("selectboxit-option-last"), k.list.find("li[data-disabled\x3d'true']").not(".optgroupHeader").addClass(k.theme.disabled),
                k.dropdownImage.addClass(k.selectBox.attr("data-icon") || k.options.defaultIcon || k.listItems.eq(k.currentFocus).find("i").attr("class")), k.dropdownImage.attr("style", k.listItems.eq(k.currentFocus).find("i").attr("style")), k
        },
        _replaceSelectBox: function() {
            var a, c, b = this.originalElem.id || "",
                h = this.selectBox.attr("data-size"),
                h = this.listSize = h === x ? "auto" : "0" === h ? "auto" : +h;
            return this.selectBox.css("display", "none").after(this.dropdownContainer), this.dropdownContainer.appendTo("body").addClass("selectboxit-rendering"),
                this.dropdown.height(), this.downArrow = d("\x3ci/\x3e", {
                    id: b && b + "SelectBoxItArrow",
                    "class": "selectboxit-arrow",
                    unselectable: "on"
                }), this.downArrowContainer = d("\x3cspan/\x3e", {
                    id: b && b + "SelectBoxItArrowContainer",
                    "class": "selectboxit-arrow-container",
                    unselectable: "on"
                }).append(this.downArrow), this.dropdown.append(this.downArrowContainer), this.listItems.removeClass("selectboxit-selected").eq(this.currentFocus).addClass("selectboxit-selected"), a = this.downArrowContainer.outerWidth(!0), c = this.dropdownImage.outerWidth(!0),
                this.options.autoWidth && (this.dropdown.css({
                    width: "auto"
                }).css({
                    width: this.list.outerWidth(!0) + a + c
                }), this.list.css({
                    "min-width": this.dropdown.width()
                })), this.dropdownText.css({
                    "max-width": this.dropdownContainer.outerWidth(!0) - (a + c)
                }), this.selectBox.after(this.dropdownContainer), this.dropdownContainer.removeClass("selectboxit-rendering"), "number" === d.type(h) && (this.maxHeight = this.listAnchors.outerHeight(!0) * h), this
        },
        _scrollToView: function(a) {
            var c = this.listItems.eq(this.currentFocus),
                b = this.list.scrollTop(),
                d = c.height(),
                c = c.position().top,
                g = Math.abs(c),
                e = this.list.height();
            return "search" === a ? d > e - c ? this.list.scrollTop(b + (c - (e - d))) : -1 > c && this.list.scrollTop(c - d) : "up" === a ? -1 > c && this.list.scrollTop(b - g) : "down" === a && d > e - c && this.list.scrollTop(b + (g - e + d)), this
        },
        _callbackSupport: function(a) {
            return d.isFunction(a) && a.call(this, this.dropdown), this
        },
        _setText: function(a, c) {
            return this.options.html ? a.html(c) : a.text(c), this
        },
        open: function(a) {
            var c = this,
                b = c.options.showEffect,
                d = c.options.showEffectSpeed,
                g = c.options.showEffectOptions,
                e = c.options["native"],
                f = c.isMobile;
            return !c.listItems.length || c.dropdown.hasClass(c.theme.disabled) ? c : (e || f || this.list.is(":visible") || (c.triggerEvent("open"), c._dynamicPositioning && c.options.dynamicPositioning && c._dynamicPositioning(), "none" === b ? c.list.show() : "show" === b || "slideDown" === b || "fadeIn" === b ? c.list[b](d) : c.list.show(b, g, d), c.list.promise().done(function() {
                c._scrollToView("search");
                c.triggerEvent("opened")
            })), c._callbackSupport(a), c)
        },
        close: function(a) {
            var c = this,
                b = c.options.hideEffect,
                d =
                c.options.hideEffectSpeed,
                g = c.options.hideEffectOptions,
                e = c.isMobile;
            return c.options["native"] || e || !c.list.is(":visible") || (c.triggerEvent("close"), "none" === b ? c.list.hide() : "hide" === b || "slideUp" === b || "fadeOut" === b ? c.list[b](d) : c.list.hide(b, g, d), c.list.promise().done(function() {
                c.triggerEvent("closed")
            })), c._callbackSupport(a), c
        },
        toggle: function() {
            var a = this.list.is(":visible");
            a ? this.close() : a || this.open()
        },
        _keyMappings: {
            38: "up",
            40: "down",
            13: "enter",
            8: "backspace",
            9: "tab",
            32: "space",
            27: "esc"
        },
        _keydownMethods: function() {
            var a =
                this,
                c = a.list.is(":visible") || !a.options.keydownOpen;
            return {
                down: function() {
                    a.moveDown && c && a.moveDown()
                },
                up: function() {
                    a.moveUp && c && a.moveUp()
                },
                enter: function() {
                    var b = a.listItems.eq(a.currentFocus);
                    a._update(b);
                    "true" !== b.attr("data-preventclose") && a.close();
                    a.triggerEvent("enter")
                },
                tab: function() {
                    a.triggerEvent("tab-blur");
                    a.close()
                },
                backspace: function() {
                    a.triggerEvent("backspace")
                },
                esc: function() {
                    a.close()
                }
            }
        },
        _eventHandlers: function() {
            var a, c, b = this,
                h = b.options.nativeMousedown,
                g = b.options.customShowHideEvent,
                e = b.focusClass,
                f = b.hoverClass,
                l = b.openClass;
            return this.dropdown.on({
                "click.selectBoxIt": function() {
                    b.dropdown.trigger("focus", !0);
                    b.originalElem.disabled || (b.triggerEvent("click"), h || g || b.toggle())
                },
                "mousedown.selectBoxIt": function() {
                    d(this).data("mdown", !0);
                    b.triggerEvent("mousedown");
                    h && !g && b.toggle()
                },
                "mouseup.selectBoxIt": function() {
                    b.triggerEvent("mouseup")
                },
                "blur.selectBoxIt": function() {
                    b.blur && (b.triggerEvent("blur"), b.close(), d(this).removeClass(e))
                },
                "focus.selectBoxIt": function(a, c) {
                    var h =
                        d(this).data("mdown");
                    d(this).removeData("mdown");
                    h || c || setTimeout(function() {
                        b.triggerEvent("tab-focus")
                    }, 0);
                    c || (d(this).hasClass(b.theme.disabled) || d(this).addClass(e), b.triggerEvent("focus"))
                },
                "keydown.selectBoxIt": function(a) {
                    var c = b._keyMappings[a.keyCode],
                        d = b._keydownMethods()[c];
                    d && (d(), !b.options.keydownOpen || "up" !== c && "down" !== c || b.open());
                    d && "tab" !== c && a.preventDefault()
                },
                "keypress.selectBoxIt": function(a) {
                    var c = b._keyMappings[a.charCode || a.keyCode],
                        d = String.fromCharCode(a.charCode || a.keyCode);
                    b.search && (!c || c && "space" === c) && b.search(d, !0, !0);
                    "space" === c && a.preventDefault()
                },
                "mouseenter.selectBoxIt": function() {
                    b.triggerEvent("mouseenter")
                },
                "mouseleave.selectBoxIt": function() {
                    b.triggerEvent("mouseleave")
                }
            }), b.list.on({
                "mouseover.selectBoxIt": function() {
                    b.blur = !1
                },
                "mouseout.selectBoxIt": function() {
                    b.blur = !0
                },
                "focusin.selectBoxIt": function() {
                    b.dropdown.trigger("focus", !0)
                }
            }), b.list.on({
                "mousedown.selectBoxIt": function() {
                    b._update(d(this));
                    b.triggerEvent("option-click");
                    "false" === d(this).attr("data-disabled") &&
                        "true" !== d(this).attr("data-preventclose") && b.close();
                    setTimeout(function() {
                        b.dropdown.trigger("focus", !0)
                    }, 0)
                },
                "focusin.selectBoxIt": function() {
                    b.listItems.not(d(this)).removeAttr("data-active");
                    d(this).attr("data-active", "");
                    var a = b.list.is(":hidden");
                    (b.options.searchWhenHidden && a || b.options.aggressiveChange || a && b.options.selectWhenHidden) && b._update(d(this));
                    d(this).addClass(e)
                },
                "mouseup.selectBoxIt": function() {
                    h && !g && (b._update(d(this)), b.triggerEvent("option-mouseup"), "false" === d(this).attr("data-disabled") &&
                        "true" !== d(this).attr("data-preventclose") && b.close())
                },
                "mouseenter.selectBoxIt": function() {
                    "false" === d(this).attr("data-disabled") && (b.listItems.removeAttr("data-active"), d(this).addClass(e).attr("data-active", ""), b.listItems.not(d(this)).removeClass(e), d(this).addClass(e), b.currentFocus = +d(this).attr("data-id"))
                },
                "mouseleave.selectBoxIt": function() {
                    "false" === d(this).attr("data-disabled") && (b.listItems.not(d(this)).removeClass(e).removeAttr("data-active"), d(this).addClass(e), b.currentFocus = +d(this).attr("data-id"))
                },
                "blur.selectBoxIt": function() {
                    d(this).removeClass(e)
                }
            }, ".selectboxit-option"), b.list.on({
                "click.selectBoxIt": function(a) {
                    a.preventDefault()
                }
            }, "a"), b.selectBox.on({
                "change.selectBoxIt, internal-change.selectBoxIt": function(d, h) {
                    var e, g;
                    h || (e = b.list.find('li[data-val\x3d"' + b.originalElem.value + '"]'), e.length && (b.listItems.eq(b.currentFocus).removeClass(b.focusClass), b.currentFocus = +e.attr("data-id")));
                    e = b.listItems.eq(b.currentFocus);
                    g = e.attr("data-selectedtext");
                    c = (a = e.attr("data-text")) ? a : e.find("a").text();
                    b._setText(b.dropdownText, g || c);
                    b.dropdownText.attr("data-val", b.originalElem.value);
                    e.find("i").attr("class") && (b.dropdownImage.attr("class", e.find("i").attr("class")).addClass("selectboxit-default-icon"), b.dropdownImage.attr("style", e.find("i").attr("style")));
                    b.triggerEvent("changed")
                },
                "disable.selectBoxIt": function() {
                    b.dropdown.addClass(b.theme.disabled)
                },
                "enable.selectBoxIt": function() {
                    b.dropdown.removeClass(b.theme.disabled)
                },
                "open.selectBoxIt": function() {
                    var a;
                    a = b.list.find("li[data-val\x3d'" +
                        b.dropdownText.attr("data-val") + "']");
                    a.length || (a = b.listItems.not("[data-disabled\x3dtrue]").first());
                    b.currentFocus = +a.attr("data-id");
                    a = b.listItems.eq(b.currentFocus);
                    b.dropdown.addClass(l).removeClass(f).addClass(e);
                    b.listItems.removeClass(b.selectedClass).removeAttr("data-active").not(a).removeClass(e);
                    a.addClass(b.selectedClass).addClass(e);
                    b.options.hideCurrent && (b.listItems.show(), a.hide())
                },
                "close.selectBoxIt": function() {
                    b.dropdown.removeClass(l)
                },
                "blur.selectBoxIt": function() {
                    b.dropdown.removeClass(e)
                },
                "mouseenter.selectBoxIt": function() {
                    d(this).hasClass(b.theme.disabled) || b.dropdown.addClass(f)
                },
                "mouseleave.selectBoxIt": function() {
                    b.dropdown.removeClass(f)
                },
                destroy: function(a) {
                    a.preventDefault();
                    a.stopPropagation()
                }
            }), b
        },
        _update: function(a) {
            var c, b = this.options.defaultText || this.selectBox.attr("data-text"),
                d = this.listItems.eq(this.currentFocus);
            "false" === a.attr("data-disabled") && (this.listItems.eq(this.currentFocus).attr("data-selectedtext"), c = d.attr("data-text"), c || d.text(), (b && this.options.html ?
                this.dropdownText.html() === b : this.dropdownText.text() === b) && this.selectBox.val() === a.attr("data-val") ? this.triggerEvent("change") : (this.selectBox.val(a.attr("data-val")), this.currentFocus = +a.attr("data-id"), this.originalElem.value !== this.dropdownText.attr("data-val") && this.triggerEvent("change")))
        },
        _addClasses: function(a) {
            var c = (this.focusClass = a.focus, this.hoverClass = a.hover, a.button),
                b = a.list,
                d = a.arrow,
                g = a.container;
            return this.openClass = a.open, this.selectedClass = "selectboxit-selected", this.downArrow.addClass(this.selectBox.attr("data-downarrow") ||
                this.options.downArrowIcon || d), this.dropdownContainer.addClass(g), this.dropdown.addClass(c), this.list.addClass(b), this
        },
        refresh: function(a, c) {
            return this._destroySelectBoxIt()._create(!0), c || this.triggerEvent("refresh"), this._callbackSupport(a), this
        },
        htmlEscape: function(a) {
            return String(a).replace(/&/g, "\x26amp;").replace(/"/g, "\x26quot;").replace(/'/g, "\x26#39;").replace(/</g, "\x26lt;").replace(/>/g, "\x26gt;")
        },
        triggerEvent: function(a) {
            return this.selectBox.trigger(a, {
                selectbox: this.selectBox,
                selectboxOption: this.selectItems.eq(this.options.showFirstOption ?
                    this.currentFocus : 0 <= this.currentFocus - 1 ? this.currentFocus : 0),
                dropdown: this.dropdown,
                dropdownOption: this.listItems.eq(this.currentFocus)
            }), this
        },
        _copyAttributes: function() {
            return this._addSelectBoxAttributes && this._addSelectBoxAttributes(), this
        },
        _realOuterWidth: function(a) {
            if (a.is(":visible")) return a.outerWidth(!0);
            var c;
            a = a.clone();
            return a.css({
                visibility: "hidden",
                display: "block",
                position: "absolute"
            }).appendTo("body"), c = a.outerWidth(!0), a.remove(), c
        }
    });
    var f = d.selectBox.selectBoxIt.prototype;
    f.add =
        function(a, c) {
            this._populate(a, function(a) {
                var h, g, e = this;
                h = d.type(a);
                var f = 0,
                    l = [],
                    m = (g = e._isJSON(a)) && e._parseJSON(a);
                if (a && ("array" === h || g && m.data && "array" === d.type(m.data)) || "object" === h && a.data && "array" === d.type(a.data)) {
                    e._isJSON(a) && (a = m);
                    a.data && (a = a.data);
                    for (g = a.length; g - 1 >= f; f += 1) h = a[f], d.isPlainObject(h) ? l.push(d("\x3coption/\x3e", h)) : "string" === d.type(h) && l.push(d("\x3coption/\x3e", {
                        text: h,
                        value: h
                    }));
                    e.selectBox.append(l)
                } else a && "string" === h && !e._isJSON(a) ? e.selectBox.append(a) : a && "object" ===
                    h ? e.selectBox.append(d("\x3coption/\x3e", a)) : a && e._isJSON(a) && d.isPlainObject(e._parseJSON(a)) && e.selectBox.append(d("\x3coption/\x3e", e._parseJSON(a)));
                return e.dropdown ? e.refresh(function() {
                    e._callbackSupport(c)
                }, !0) : e._callbackSupport(c), e
            })
        };
    f._parseJSON = function(a) {
        return JSON && JSON.parse && JSON.parse(a) || d.parseJSON(a)
    };
    f._isJSON = function(a) {
        try {
            return this._parseJSON(a), !0
        } catch (c) {
            return !1
        }
    };
    f._populate = function(a, c) {
        var b = this;
        return a = d.isFunction(a) ? a.call() : a, b.isDeferred(a) ? a.done(function(a) {
            c.call(b,
                a)
        }) : c.call(b, a), b
    };
    f._ariaAccessibility = function() {
        var a = this,
            c = d("label[for\x3d'" + a.originalElem.id + "']");
        return a.dropdownContainer.attr({
            role: "combobox",
            "aria-autocomplete": "list",
            "aria-haspopup": "true",
            "aria-expanded": "false",
            "aria-owns": a.list[0].id
        }), a.dropdownText.attr({
            "aria-live": "polite"
        }), a.dropdown.on({
            "disable.selectBoxIt": function() {
                a.dropdownContainer.attr("aria-disabled", "true")
            },
            "enable.selectBoxIt": function() {
                a.dropdownContainer.attr("aria-disabled", "false")
            }
        }), c.length && a.dropdownContainer.attr("aria-labelledby",
            c[0].id), a.list.attr({
            role: "listbox",
            "aria-hidden": "true"
        }), a.listItems.attr({
            role: "option"
        }), a.selectBox.on({
            "open.selectBoxIt": function() {
                a.list.attr("aria-hidden", "false");
                a.dropdownContainer.attr("aria-expanded", "true")
            },
            "close.selectBoxIt": function() {
                a.list.attr("aria-hidden", "true");
                a.dropdownContainer.attr("aria-expanded", "false")
            }
        }), a
    };
    f._addSelectBoxAttributes = function() {
        var a = this;
        return a._addAttributes(a.selectBox.prop("attributes"), a.dropdown), a.selectItems.each(function(c) {
            a._addAttributes(d(this).prop("attributes"),
                a.listItems.eq(c))
        }), a
    };
    f._addAttributes = function(a, c) {
        var b = this.options.copyAttributes;
        return a.length && d.each(a, function(a, g) {
            var e = g.name.toLowerCase(),
                f = g.value;
            "null" === f || -1 === d.inArray(e, b) && -1 === e.indexOf("data") || c.attr(e, f)
        }), this
    };
    f.destroy = function(a) {
        return this._destroySelectBoxIt(), this.widgetProto.destroy.call(this), this._callbackSupport(a), this
    };
    f._destroySelectBoxIt = function() {
        return this.dropdown.off(".selectBoxIt"), d.contains(this.dropdownContainer[0], this.originalElem) && this.dropdownContainer.before(this.selectBox),
            this.dropdownContainer.remove(), this.selectBox.removeAttr("style").attr("style", this.selectBoxStyles), this.triggerEvent("destroy"), this
    };
    f.disable = function(a) {
        return this.options.disabled || (this.close(), this.selectBox.attr("disabled", "disabled"), this.dropdown.removeAttr("tabindex").removeClass(this.theme.enabled).addClass(this.theme.disabled), this.setOption("disabled", !0), this.triggerEvent("disable")), this._callbackSupport(a), this
    };
    f.disableOption = function(a, c) {
        var b, h, g;
        return "number" === d.type(a) &&
            (this.close(), b = this.selectBox.find("option").eq(a), this.triggerEvent("disable-option"), b.attr("disabled", "disabled"), this.listItems.eq(a).attr("data-disabled", "true").addClass(this.theme.disabled), this.currentFocus === a && (h = this.listItems.eq(this.currentFocus).nextAll("li").not("[data-disabled\x3d'true']").first().length, g = this.listItems.eq(this.currentFocus).prevAll("li").not("[data-disabled\x3d'true']").first().length, h ? this.moveDown() : g ? this.moveUp() : this.disable())), this._callbackSupport(c), this
    };
    f._isDisabled = function() {
        return this.originalElem.disabled && this.disable(), this
    };
    f._dynamicPositioning = function() {
        if ("number" === d.type(this.listSize)) this.list.css("max-height", this.maxHeight || "none");
        else {
            var a = this.dropdown.offset().top,
                c = this.list.data("max-height") || this.list.outerHeight(),
                b = this.dropdown.outerHeight(),
                h = this.options.viewport,
                g = h.height(),
                h = d.isWindow(h.get(0)) ? h.scrollTop() : h.offset().top,
                e = !(g + h >= a + b + c);
            (this.list.data("max-height") || this.list.data("max-height", this.list.outerHeight()),
                e) ? this.dropdown.offset().top - h >= c ? (this.list.css("max-height", c), this.list.css("top", this.dropdown.position().top - this.list.outerHeight())) : (a = Math.abs(a + b + c - (g + h)), g = Math.abs(this.dropdown.offset().top - h - c), g > a ? (this.list.css("max-height", c - a - b / 2), this.list.css("top", "auto")) : (this.list.css("max-height", c - g - b / 2), this.list.css("top", this.dropdown.position().top - this.list.outerHeight()))): (this.list.css("max-height", c), this.list.css("top", "auto"))
        }
        return this
    };
    f.enable = function(a) {
        return this.options.disabled &&
            (this.triggerEvent("enable"), this.selectBox.removeAttr("disabled"), this.dropdown.attr("tabindex", 0).removeClass(this.theme.disabled).addClass(this.theme.enabled), this.setOption("disabled", !1), this._callbackSupport(a)), this
    };
    f.enableOption = function(a, c) {
        var b;
        return "number" === d.type(a) && (b = this.selectBox.find("option").eq(a), this.triggerEvent("enable-option"), b.removeAttr("disabled"), this.listItems.eq(a).attr("data-disabled", "false").removeClass(this.theme.disabled)), this._callbackSupport(c), this
    };
    f.moveDown = function(a) {
        this.currentFocus += 1;
        var c = "true" === this.listItems.eq(this.currentFocus).attr("data-disabled") ? !0 : !1,
            b = this.listItems.eq(this.currentFocus).nextAll("li").not("[data-disabled\x3d'true']").first().length;
        if (this.currentFocus === this.listItems.length) --this.currentFocus;
        else {
            if (c && b) return this.listItems.eq(this.currentFocus - 1).blur(), this.moveDown(), void 0;
            c && !b ? --this.currentFocus : (this.listItems.eq(this.currentFocus - 1).blur().end().eq(this.currentFocus).focusin(), this._scrollToView("down"),
                this.triggerEvent("moveDown"))
        }
        return this._callbackSupport(a), this
    };
    f.moveUp = function(a) {
        --this.currentFocus;
        var c = "true" === this.listItems.eq(this.currentFocus).attr("data-disabled") ? !0 : !1,
            b = this.listItems.eq(this.currentFocus).prevAll("li").not("[data-disabled\x3d'true']").first().length;
        if (-1 === this.currentFocus) this.currentFocus += 1;
        else {
            if (c && b) return this.listItems.eq(this.currentFocus + 1).blur(), this.moveUp(), void 0;
            c && !b ? this.currentFocus += 1 : (this.listItems.eq(this.currentFocus + 1).blur().end().eq(this.currentFocus).focusin(),
                this._scrollToView("up"), this.triggerEvent("moveUp"))
        }
        return this._callbackSupport(a), this
    };
    f._setCurrentSearchOption = function(a) {
        return (this.options.aggressiveChange || this.options.selectWhenHidden || this.listItems.eq(a).is(":visible")) && !0 !== this.listItems.eq(a).data("disabled") && (this.listItems.eq(this.currentFocus).blur(), this.currentIndex = a, this.currentFocus = a, this.listItems.eq(this.currentFocus).focusin(), this._scrollToView("search"), this.triggerEvent("search")), this
    };
    f._searchAlgorithm = function(a,
        c) {
        var b, d, g, e, f = !1,
            l = this.textArray,
            m = this.currentText;
        b = a;
        for (g = l.length; g > b; b += 1) {
            e = l[b];
            for (d = 0; g > d; d += 1) - 1 !== l[d].search(c) && (f = !0, d = g);
            if (f || (this.currentText = this.currentText.charAt(this.currentText.length - 1).replace(/[|()\[{.+*?$\\]/g, "\\$0"), m = this.currentText), c = new RegExp(m, "gi"), 3 > m.length) {
                if (c = new RegExp(m.charAt(0), "gi"), -1 !== e.charAt(0).search(c)) return this._setCurrentSearchOption(b), (e.substring(0, m.length).toLowerCase() !== m.toLowerCase() || this.options.similarSearch) && (this.currentIndex +=
                    1), !1
            } else if (-1 !== e.search(c)) return this._setCurrentSearchOption(b), !1;
            if (e.toLowerCase() === this.currentText.toLowerCase()) return this._setCurrentSearchOption(b), this.currentText = "", !1
        }
        return !0
    };
    f.search = function(a, c, b) {
        b ? this.currentText += a.replace(/[|()\[{.+*?$\\]/g, "\\$0") : this.currentText = a.replace(/[|()\[{.+*?$\\]/g, "\\$0");
        return this._searchAlgorithm(this.currentIndex, new RegExp(this.currentText, "gi")) && this._searchAlgorithm(0, this.currentText), this._callbackSupport(c), this
    };
    f._updateMobileText =
        function() {
            var a, c;
            a = this.selectBox.find("option").filter(":selected");
            c = (c = a.attr("data-text")) ? c : a.text();
            this._setText(this.dropdownText, c);
            this.list.find('li[data-val\x3d"' + a.val() + '"]').find("i").attr("class") && this.dropdownImage.attr("class", this.list.find('li[data-val\x3d"' + a.val() + '"]').find("i").attr("class")).addClass("selectboxit-default-icon")
        };
    f._applyNativeSelect = function() {
        return this.dropdownContainer.append(this.selectBox), this.dropdown.attr("tabindex", "-1"), this.selectBox.css({
            display: "block",
            visibility: "visible",
            width: this._realOuterWidth(this.dropdown),
            height: this.dropdown.outerHeight(),
            opacity: "0",
            position: "absolute",
            top: "0",
            left: "0",
            cursor: "pointer",
            "z-index": "999999",
            margin: this.dropdown.css("margin"),
            padding: "0",
            "-webkit-appearance": "menulist-button"
        }), this.originalElem.disabled && this.triggerEvent("disable"), this
    };
    f._mobileEvents = function() {
        var a = this;
        a.selectBox.on({
            "changed.selectBoxIt": function() {
                a.hasChanged = !0;
                a._updateMobileText();
                a.triggerEvent("option-click")
            },
            "mousedown.selectBoxIt": function() {
                a.hasChanged ||
                    !a.options.defaultText || a.originalElem.disabled || (a._updateMobileText(), a.triggerEvent("option-click"))
            },
            "enable.selectBoxIt": function() {
                a.selectBox.removeClass("selectboxit-rendering")
            },
            "disable.selectBoxIt": function() {
                a.selectBox.addClass("selectboxit-rendering")
            }
        })
    };
    f._mobile = function() {
        return this.isMobile && (this._applyNativeSelect(), this._mobileEvents()), this
    };
    f.remove = function(a, c) {
        var b, h, g = this;
        b = d.type(a);
        var e = 0,
            f = "";
        if ("array" === b) {
            for (h = a.length; h - 1 >= e; e += 1) b = a[e], "number" === d.type(b) &&
                (f += f.length ? ", option:eq(" + b + ")" : "option:eq(" + b + ")");
            g.selectBox.find(f).remove()
        } else "number" === b ? g.selectBox.find("option").eq(a).remove() : g.selectBox.find("option").remove();
        return g.dropdown ? g.refresh(function() {
            g._callbackSupport(c)
        }, !0) : g._callbackSupport(c), g
    };
    f.selectOption = function(a, c) {
        var b = d.type(a);
        return "number" === b ? this.selectBox.val(this.selectItems.eq(a).val()).change() : "string" === b && this.selectBox.val(a).change(), this._callbackSupport(c), this
    };
    f.setOption = function(a, c, b) {
        var f =
            this;
        return "string" === d.type(a) && (f.options[a] = c), f.refresh(function() {
            f._callbackSupport(b)
        }, !0), f
    };
    f.setOptions = function(a, c) {
        var b = this;
        return d.isPlainObject(a) && (b.options = d.extend({}, b.options, a)), b.refresh(function() {
            b._callbackSupport(c)
        }, !0), b
    };
    f.wait = function(a, c) {
        return this.widgetProto._delay.call(this, c, a), this
    }
});
(function(e) {
    function t() {
        this.regional = [];
        this.regional[""] = {
            currentText: "Now",
            closeText: "Done",
            amNames: ["AM", "A"],
            pmNames: ["PM", "P"],
            timeFormat: "HH:mm",
            timeSuffix: "",
            timeOnlyTitle: "Choose Time",
            timeText: "Time",
            hourText: "Hour",
            minuteText: "Minute",
            secondText: "Second",
            millisecText: "Millisecond",
            timezoneText: "Time Zone",
            isRTL: !1
        };
        this._defaults = {
            showButtonPanel: !0,
            timeOnly: !1,
            showHour: !0,
            showMinute: !0,
            showSecond: !1,
            showMillisec: !1,
            showTimezone: !1,
            showTime: !0,
            stepHour: 1,
            stepMinute: 1,
            stepSecond: 1,
            stepMillisec: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0,
            timezone: null,
            useLocalTimezone: !1,
            defaultTimezone: "+0000",
            hourMin: 0,
            minuteMin: 0,
            secondMin: 0,
            millisecMin: 0,
            hourMax: 23,
            minuteMax: 59,
            secondMax: 59,
            millisecMax: 999,
            minDateTime: null,
            maxDateTime: null,
            onSelect: null,
            hourGrid: 0,
            minuteGrid: 0,
            secondGrid: 0,
            millisecGrid: 0,
            alwaysSetTime: !0,
            separator: " ",
            altFieldTimeOnly: !0,
            altTimeFormat: null,
            altSeparator: null,
            altTimeSuffix: null,
            pickerTimeFormat: null,
            pickerTimeSuffix: null,
            showTimepicker: !0,
            timezoneIso8601: !1,
            timezoneList: null,
            addSliderAccess: !1,
            sliderAccessArgs: null,
            controlType: "slider",
            defaultValue: null,
            parse: "strict"
        };
        e.extend(this._defaults, this.regional[""])
    }
    e.ui.timepicker = e.ui.timepicker || {};
    if (!e.ui.timepicker.version) {
        e.extend(e.ui, {
            timepicker: {
                version: "1.1.1"
            }
        });
        e.extend(t.prototype, {
            $input: null,
            $altInput: null,
            $timeObj: null,
            inst: null,
            hour_slider: null,
            minute_slider: null,
            second_slider: null,
            millisec_slider: null,
            timezone_select: null,
            hour: 0,
            minute: 0,
            second: 0,
            millisec: 0,
            timezone: null,
            defaultTimezone: "+0000",
            hourMinOriginal: null,
            minuteMinOriginal: null,
            secondMinOriginal: null,
            millisecMinOriginal: null,
            hourMaxOriginal: null,
            minuteMaxOriginal: null,
            secondMaxOriginal: null,
            millisecMaxOriginal: null,
            ampm: "",
            formattedDate: "",
            formattedTime: "",
            formattedDateTime: "",
            timezoneList: null,
            units: ["hour", "minute", "second", "millisec"],
            control: null,
            setDefaults: function(c) {
                u(this._defaults, c || {});
                return this
            },
            _newInst: function(c, b) {
                var a = new t,
                    d = {},
                    f = {},
                    g, k;
                for (g in this._defaults)
                    if (this._defaults.hasOwnProperty(g)) {
                        var h = c.attr("time:" + g);
                        if (h) try {
                            d[g] =
                                eval(h)
                        } catch (m) {
                            d[g] = h
                        }
                    }
                g = {
                    beforeShow: function(b, d) {
                        if (e.isFunction(a._defaults.evnts.beforeShow)) return a._defaults.evnts.beforeShow.call(c[0], b, d, a)
                    },
                    onChangeMonthYear: function(b, d, f) {
                        a._updateDateTime(f);
                        e.isFunction(a._defaults.evnts.onChangeMonthYear) && a._defaults.evnts.onChangeMonthYear.call(c[0], b, d, f, a)
                    },
                    onClose: function(b, d) {
                        !0 === a.timeDefined && "" !== c.val() && a._updateDateTime(d);
                        e.isFunction(a._defaults.evnts.onClose) && a._defaults.evnts.onClose.call(c[0], b, d, a)
                    }
                };
                for (k in g) g.hasOwnProperty(k) &&
                    (f[k] = b[k] || null);
                a._defaults = e.extend({}, this._defaults, d, b, g, {
                    evnts: f,
                    timepicker: a
                });
                a.amNames = e.map(a._defaults.amNames, function(a) {
                    return a.toUpperCase()
                });
                a.pmNames = e.map(a._defaults.pmNames, function(a) {
                    return a.toUpperCase()
                });
                "string" === typeof a._defaults.controlType ? (void 0 === e.fn[a._defaults.controlType] && (a._defaults.controlType = "select"), a.control = a._controls[a._defaults.controlType]) : a.control = a._defaults.controlType;
                null === a._defaults.timezoneList && (d = "-1200 -1100 -1000 -0930 -0900 -0800 -0700 -0600 -0500 -0430 -0400 -0330 -0300 -0200 -0100 +0000 +0100 +0200 +0300 +0330 +0400 +0430 +0500 +0530 +0545 +0600 +0630 +0700 +0800 +0845 +0900 +0930 +1000 +1030 +1100 +1130 +1200 +1245 +1300 +1400".split(" "),
                    a._defaults.timezoneIso8601 && (d = e.map(d, function(a) {
                        return "+0000" == a ? "Z" : a.substring(0, 3) + ":" + a.substring(3)
                    })), a._defaults.timezoneList = d);
                a.timezone = a._defaults.timezone;
                a.hour = a._defaults.hour;
                a.minute = a._defaults.minute;
                a.second = a._defaults.second;
                a.millisec = a._defaults.millisec;
                a.ampm = "";
                a.$input = c;
                b.altField && (a.$altInput = e(b.altField).css({
                    cursor: "pointer"
                }).focus(function() {
                    c.trigger("focus")
                }));
                if (0 === a._defaults.minDate || 0 === a._defaults.minDateTime) a._defaults.minDate = new Date;
                if (0 === a._defaults.maxDate ||
                    0 === a._defaults.maxDateTime) a._defaults.maxDate = new Date;
                void 0 !== a._defaults.minDate && a._defaults.minDate instanceof Date && (a._defaults.minDateTime = new Date(a._defaults.minDate.getTime()));
                void 0 !== a._defaults.minDateTime && a._defaults.minDateTime instanceof Date && (a._defaults.minDate = new Date(a._defaults.minDateTime.getTime()));
                void 0 !== a._defaults.maxDate && a._defaults.maxDate instanceof Date && (a._defaults.maxDateTime = new Date(a._defaults.maxDate.getTime()));
                void 0 !== a._defaults.maxDateTime && a._defaults.maxDateTime instanceof
                Date && (a._defaults.maxDate = new Date(a._defaults.maxDateTime.getTime()));
                a.$input.bind("focus", function() {
                    a._onFocus()
                });
                return a
            },
            _addTimePicker: function(c) {
                var b = this.$altInput && this._defaults.altFieldTimeOnly ? this.$input.val() + " " + this.$altInput.val() : this.$input.val();
                this.timeDefined = this._parseTime(b);
                this._limitMinMaxDateTime(c, !1);
                this._injectTimePicker()
            },
            _parseTime: function(c, b) {
                this.inst || (this.inst = e.datepicker._getInst(this.$input[0]));
                if (b || !this._defaults.timeOnly) {
                    var a = e.datepicker._get(this.inst,
                        "dateFormat");
                    try {
                        var d = w(a, this._defaults.timeFormat, c, e.datepicker._getFormatConfig(this.inst), this._defaults);
                        if (!d.timeObj) return !1;
                        e.extend(this, d.timeObj)
                    } catch (f) {
                        return e.datepicker.log("Error parsing the date/time string: " + f + "\ndate/time string \x3d " + c + "\ntimeFormat \x3d " + this._defaults.timeFormat + "\ndateFormat \x3d " + a), !1
                    }
                } else {
                    a = e.datepicker.parseTime(this._defaults.timeFormat, c, this._defaults);
                    if (!a) return !1;
                    e.extend(this, a)
                }
                return !0
            },
            _injectTimePicker: function() {
                var c = this.inst.dpDiv,
                    b = this.inst.settings,
                    a = this,
                    d = "",
                    f = "",
                    g = {},
                    k = {},
                    h = null;
                if (0 === c.find("div.ui-timepicker-div").length && b.showTimepicker) {
                    for (var h = '\x3cdiv class\x3d"ui-timepicker-div' + (b.isRTL ? " ui-timepicker-rtl" : "") + '"\x3e\x3cdl\x3e\x3cdt class\x3d"ui_tpicker_time_label"' + (b.showTime ? "" : ' style\x3d"display:none;"') + "\x3e" + b.timeText + '\x3c/dt\x3e\x3cdd class\x3d"ui_tpicker_time"' + (b.showTime ? "" : ' style\x3d"display:none;"') + "\x3e\x3c/dd\x3e", m = 0, n = this.units.length; m < n; m++) {
                        d = this.units[m];
                        f = d.substr(0, 1).toUpperCase() +
                            d.substr(1);
                        g[d] = parseInt(b[d + "Max"] - (b[d + "Max"] - b[d + "Min"]) % b["step" + f], 10);
                        k[d] = 0;
                        h += '\x3cdt class\x3d"ui_tpicker_' + d + '_label"' + (b["show" + f] ? "" : ' style\x3d"display:none;"') + "\x3e" + b[d + "Text"] + '\x3c/dt\x3e\x3cdd class\x3d"ui_tpicker_' + d + '"\x3e\x3cdiv class\x3d"ui_tpicker_' + d + '_slider"' + (b["show" + f] ? "" : ' style\x3d"display:none;"') + "\x3e\x3c/div\x3e";
                        if (b["show" + f] && 0 < b[d + "Grid"]) {
                            h += '\x3cdiv style\x3d"padding-left: 1px"\x3e\x3ctable class\x3d"ui-tpicker-grid-label"\x3e\x3ctr\x3e';
                            if ("hour" == d)
                                for (f =
                                    b[d + "Min"]; f <= g[d]; f += parseInt(b[d + "Grid"], 10)) {
                                    k[d]++;
                                    var l = e.datepicker.formatTime(q(b.pickerTimeFormat || b.timeFormat) ? "hht" : "HH", {
                                            hour: f
                                        }, b),
                                        h = h + ('\x3ctd data-for\x3d"' + d + '"\x3e' + l + "\x3c/td\x3e")
                                } else
                                    for (f = b[d + "Min"]; f <= g[d]; f += parseInt(b[d + "Grid"], 10)) k[d]++, h += '\x3ctd data-for\x3d"' + d + '"\x3e' + (10 > f ? "0" : "") + f + "\x3c/td\x3e";
                            h += "\x3c/tr\x3e\x3c/table\x3e\x3c/div\x3e"
                        }
                        h += "\x3c/dd\x3e"
                    }
                    var h = h + ('\x3cdt class\x3d"ui_tpicker_timezone_label"' + (b.showTimezone ? "" : ' style\x3d"display:none;"') + "\x3e" + b.timezoneText +
                            "\x3c/dt\x3e"),
                        h = h + ('\x3cdd class\x3d"ui_tpicker_timezone" ' + (b.showTimezone ? "" : ' style\x3d"display:none;"') + "\x3e\x3c/dd\x3e"),
                        p = e(h + "\x3c/dl\x3e\x3c/div\x3e");
                    !0 === b.timeOnly && (p.prepend('\x3cdiv class\x3d"ui-widget-header ui-helper-clearfix ui-corner-all"\x3e\x3cdiv class\x3d"ui-datepicker-title"\x3e' + b.timeOnlyTitle + "\x3c/div\x3e\x3c/div\x3e"), c.find(".ui-datepicker-header, .ui-datepicker-calendar").hide());
                    m = 0;
                    for (n = a.units.length; m < n; m++) d = a.units[m], f = d.substr(0, 1).toUpperCase() + d.substr(1),
                        a[d + "_slider"] = a.control.create(a, p.find(".ui_tpicker_" + d + "_slider"), d, a[d], b[d + "Min"], g[d], b["step" + f]), b["show" + f] && 0 < b[d + "Grid"] && (h = 100 * k[d] * b[d + "Grid"] / (g[d] - b[d + "Min"]), p.find(".ui_tpicker_" + d + " table").css({
                            width: h + "%",
                            marginLeft: b.isRTL ? "0" : h / (-2 * k[d]) + "%",
                            marginRight: b.isRTL ? h / (-2 * k[d]) + "%" : "0",
                            borderCollapse: "collapse"
                        }).find("td").click(function(b) {
                            var c = e(this),
                                f = c.html();
                            b = parseInt(f.replace(/[^0-9]/g), 10);
                            f = f.replace(/[^apm]/ig);
                            c = c.data("for");
                            "hour" == c && (-1 !== f.indexOf("p") && 12 > b ?
                                b += 12 : -1 !== f.indexOf("a") && 12 === b && (b = 0));
                            a.control.value(a, a[c + "_slider"], d, b);
                            a._onTimeChange();
                            a._onSelectHandler()
                        }).css({
                            cursor: "pointer",
                            width: 100 / k[d] + "%",
                            textAlign: "center",
                            overflow: "hidden"
                        }));
                    this.timezone_select = p.find(".ui_tpicker_timezone").append("\x3cselect\x3e\x3c/select\x3e").find("select");
                    e.fn.append.apply(this.timezone_select, e.map(b.timezoneList, function(a, b) {
                        return e("\x3coption /\x3e").val("object" == typeof a ? a.value : a).text("object" == typeof a ? a.label : a)
                    }));
                    "undefined" != typeof this.timezone &&
                        null !== this.timezone && "" !== this.timezone ? e.timepicker.timeZoneOffsetString(new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12)) == this.timezone ? r(a) : this.timezone_select.val(this.timezone) : "undefined" != typeof this.hour && null !== this.hour && "" !== this.hour ? this.timezone_select.val(b.defaultTimezone) : r(a);
                    this.timezone_select.change(function() {
                        a._defaults.useLocalTimezone = !1;
                        a._onTimeChange()
                    });
                    b = c.find(".ui-datepicker-buttonpane");
                    b.length ? b.before(p) : c.append(p);
                    this.$timeObj =
                        p.find(".ui_tpicker_time");
                    null !== this.inst && (c = this.timeDefined, this._onTimeChange(), this.timeDefined = c);
                    if (this._defaults.addSliderAccess) {
                        var x = this._defaults.sliderAccessArgs,
                            v = this._defaults.isRTL;
                        x.isRTL = v;
                        setTimeout(function() {
                            if (0 === p.find(".ui-slider-access").length) {
                                p.find(".ui-slider:visible").sliderAccess(x);
                                var a = p.find(".ui-slider-access:eq(0)").outerWidth(!0);
                                a && p.find("table:visible").each(function() {
                                    var b = e(this),
                                        c = b.outerWidth(),
                                        d = b.css(v ? "marginRight" : "marginLeft").toString().replace("%",
                                            ""),
                                        f = c - a,
                                        g = {
                                            width: f,
                                            marginRight: 0,
                                            marginLeft: 0
                                        };
                                    g[v ? "marginRight" : "marginLeft"] = d * f / c + "%";
                                    b.css(g)
                                })
                            }
                        }, 10)
                    }
                }
            },
            _limitMinMaxDateTime: function(c, b) {
                var a = this._defaults,
                    d = new Date(c.selectedYear, c.selectedMonth, c.selectedDay);
                if (this._defaults.showTimepicker) {
                    if (null !== e.datepicker._get(c, "minDateTime") && void 0 !== e.datepicker._get(c, "minDateTime") && d) {
                        var f = e.datepicker._get(c, "minDateTime"),
                            g = new Date(f.getFullYear(), f.getMonth(), f.getDate(), 0, 0, 0, 0);
                        if (null === this.hourMinOriginal || null === this.minuteMinOriginal ||
                            null === this.secondMinOriginal || null === this.millisecMinOriginal) this.hourMinOriginal = a.hourMin, this.minuteMinOriginal = a.minuteMin, this.secondMinOriginal = a.secondMin, this.millisecMinOriginal = a.millisecMin;
                        c.settings.timeOnly || g.getTime() == d.getTime() ? (this._defaults.hourMin = f.getHours(), this.hour <= this._defaults.hourMin ? (this.hour = this._defaults.hourMin, this._defaults.minuteMin = f.getMinutes(), this.minute <= this._defaults.minuteMin ? (this.minute = this._defaults.minuteMin, this._defaults.secondMin = f.getSeconds(),
                                this.second <= this._defaults.secondMin ? (this.second = this._defaults.secondMin, this._defaults.millisecMin = f.getMilliseconds()) : (this.millisec < this._defaults.millisecMin && (this.millisec = this._defaults.millisecMin), this._defaults.millisecMin = this.millisecMinOriginal)) : (this._defaults.secondMin = this.secondMinOriginal, this._defaults.millisecMin = this.millisecMinOriginal)) : (this._defaults.minuteMin = this.minuteMinOriginal, this._defaults.secondMin = this.secondMinOriginal, this._defaults.millisecMin = this.millisecMinOriginal)) :
                            (this._defaults.hourMin = this.hourMinOriginal, this._defaults.minuteMin = this.minuteMinOriginal, this._defaults.secondMin = this.secondMinOriginal, this._defaults.millisecMin = this.millisecMinOriginal)
                    }
                    if (null !== e.datepicker._get(c, "maxDateTime") && void 0 !== e.datepicker._get(c, "maxDateTime") && d) {
                        f = e.datepicker._get(c, "maxDateTime");
                        g = new Date(f.getFullYear(), f.getMonth(), f.getDate(), 0, 0, 0, 0);
                        if (null === this.hourMaxOriginal || null === this.minuteMaxOriginal || null === this.secondMaxOriginal) this.hourMaxOriginal = a.hourMax,
                            this.minuteMaxOriginal = a.minuteMax, this.secondMaxOriginal = a.secondMax, this.millisecMaxOriginal = a.millisecMax;
                        c.settings.timeOnly || g.getTime() == d.getTime() ? (this._defaults.hourMax = f.getHours(), this.hour >= this._defaults.hourMax ? (this.hour = this._defaults.hourMax, this._defaults.minuteMax = f.getMinutes(), this.minute >= this._defaults.minuteMax ? (this.minute = this._defaults.minuteMax, this._defaults.secondMax = f.getSeconds()) : this.second >= this._defaults.secondMax ? (this.second = this._defaults.secondMax, this._defaults.millisecMax =
                            f.getMilliseconds()) : (this.millisec > this._defaults.millisecMax && (this.millisec = this._defaults.millisecMax), this._defaults.millisecMax = this.millisecMaxOriginal)) : (this._defaults.minuteMax = this.minuteMaxOriginal, this._defaults.secondMax = this.secondMaxOriginal, this._defaults.millisecMax = this.millisecMaxOriginal)) : (this._defaults.hourMax = this.hourMaxOriginal, this._defaults.minuteMax = this.minuteMaxOriginal, this._defaults.secondMax = this.secondMaxOriginal, this._defaults.millisecMax = this.millisecMaxOriginal)
                    }
                    void 0 !==
                        b && !0 === b && (a = parseInt(this._defaults.hourMax - (this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour, 10), d = parseInt(this._defaults.minuteMax - (this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute, 10), f = parseInt(this._defaults.secondMax - (this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond, 10), g = parseInt(this._defaults.millisecMax - (this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec, 10), this.hour_slider &&
                            (this.control.options(this, this.hour_slider, "hour", {
                                min: this._defaults.hourMin,
                                max: a
                            }), this.control.value(this, this.hour_slider, "hour", this.hour)), this.minute_slider && (this.control.options(this, this.minute_slider, "minute", {
                                min: this._defaults.minuteMin,
                                max: d
                            }), this.control.value(this, this.minute_slider, "minute", this.minute)), this.second_slider && (this.control.options(this, this.second_slider, "second", {
                                min: this._defaults.secondMin,
                                max: f
                            }), this.control.value(this, this.second_slider, "second", this.second)),
                            this.millisec_slider && (this.control.options(this, this.millisec_slider, "millisec", {
                                min: this._defaults.millisecMin,
                                max: g
                            }), this.control.value(this, this.millisec_slider, "millisec", this.millisec)))
                }
            },
            _onTimeChange: function() {
                var c = this.hour_slider ? this.control.value(this, this.hour_slider, "hour") : !1,
                    b = this.minute_slider ? this.control.value(this, this.minute_slider, "minute") : !1,
                    a = this.second_slider ? this.control.value(this, this.second_slider, "second") : !1,
                    d = this.millisec_slider ? this.control.value(this, this.millisec_slider,
                        "millisec") : !1,
                    f = this.timezone_select ? this.timezone_select.val() : !1,
                    g = this._defaults,
                    k = g.pickerTimeFormat || g.timeFormat,
                    h = g.pickerTimeSuffix || g.timeSuffix;
                "object" == typeof c && (c = !1);
                "object" == typeof b && (b = !1);
                "object" == typeof a && (a = !1);
                "object" == typeof d && (d = !1);
                "object" == typeof f && (f = !1);
                !1 !== c && (c = parseInt(c, 10));
                !1 !== b && (b = parseInt(b, 10));
                !1 !== a && (a = parseInt(a, 10));
                !1 !== d && (d = parseInt(d, 10));
                var m = g[12 > c ? "amNames" : "pmNames"][0],
                    n = c != this.hour || b != this.minute || a != this.second || d != this.millisec ||
                    0 < this.ampm.length && 12 > c != (-1 !== e.inArray(this.ampm.toUpperCase(), this.amNames)) || null === this.timezone && f != this.defaultTimezone || null !== this.timezone && f != this.timezone;
                n && (!1 !== c && (this.hour = c), !1 !== b && (this.minute = b), !1 !== a && (this.second = a), !1 !== d && (this.millisec = d), !1 !== f && (this.timezone = f), this.inst || (this.inst = e.datepicker._getInst(this.$input[0])), this._limitMinMaxDateTime(this.inst, !0));
                q(g.timeFormat) && (this.ampm = m);
                this.formattedTime = e.datepicker.formatTime(g.timeFormat, this, g);
                this.$timeObj &&
                    (k === g.timeFormat ? this.$timeObj.text(this.formattedTime + h) : this.$timeObj.text(e.datepicker.formatTime(k, this, g) + h));
                this.timeDefined = !0;
                n && this._updateDateTime()
            },
            _onSelectHandler: function() {
                var c = this._defaults.onSelect || this.inst.settings.onSelect,
                    b = this.$input ? this.$input[0] : null;
                c && b && c.apply(b, [this.formattedDateTime, this])
            },
            _updateDateTime: function(c) {
                c = this.inst || c;
                var b = e.datepicker._daylightSavingAdjust(new Date(c.selectedYear, c.selectedMonth, c.selectedDay)),
                    a = e.datepicker._get(c, "dateFormat");
                c = e.datepicker._getFormatConfig(c);
                var d = null !== b && this.timeDefined,
                    a = this.formattedDate = e.datepicker.formatDate(a, null === b ? new Date : b, c);
                !0 === this._defaults.timeOnly ? a = this.formattedTime : !0 !== this._defaults.timeOnly && (this._defaults.alwaysSetTime || d) && (a += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix);
                this.formattedDateTime = a;
                if (this._defaults.showTimepicker)
                    if (this.$altInput && !0 === this._defaults.altFieldTimeOnly) this.$altInput.val(this.formattedTime), this.$input.val(this.formattedDate);
                    else if (this.$altInput) {
                    this.$input.val(a);
                    var a = "",
                        d = this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator,
                        f = this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;
                    (a = this._defaults.altFormat ? e.datepicker.formatDate(this._defaults.altFormat, null === b ? new Date : b, c) : this.formattedDate) && (a += d);
                    a = this._defaults.altTimeFormat ? a + (e.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + f) : a + (this.formattedTime + f);
                    this.$altInput.val(a)
                } else this.$input.val(a);
                else this.$input.val(this.formattedDate);
                this.$input.trigger("change")
            },
            _onFocus: function() {
                if (!this.$input.val() && this._defaults.defaultValue) {
                    this.$input.val(this._defaults.defaultValue);
                    var c = e.datepicker._getInst(this.$input.get(0)),
                        b = e.datepicker._get(c, "timepicker");
                    if (b && b._defaults.timeOnly && c.input.val() != c.lastVal) try {
                        e.datepicker._updateDatepicker(c)
                    } catch (a) {
                        e.datepicker.log(a)
                    }
                }
            },
            _controls: {
                slider: {
                    create: function(c, b, a, d, f, g, k) {
                        var h = c._defaults.isRTL;
                        return b.prop("slide", null).slider({
                            orientation: "horizontal",
                            value: h ? -1 * d : d,
                            min: h ? -1 * g : f,
                            max: h ? -1 * f : g,
                            step: k,
                            slide: function(b, d) {
                                c.control.value(c, e(this), a, h ? -1 * d.value : d.value);
                                c._onTimeChange()
                            },
                            stop: function(a, b) {
                                c._onSelectHandler()
                            }
                        })
                    },
                    options: function(c, b, a, d, e) {
                        if (c._defaults.isRTL) {
                            if ("string" == typeof d) return "min" == d || "max" == d ? void 0 !== e ? b.slider(d, -1 * e) : Math.abs(b.slider(d)) : b.slider(d);
                            c = d.min;
                            a = d.max;
                            d.min = d.max = null;
                            void 0 !== c && (d.max = -1 * c);
                            void 0 !== a && (d.min = -1 * a);
                            return b.slider(d)
                        }
                        return "string" == typeof d && void 0 !== e ? b.slider(d, e) : b.slider(d)
                    },
                    value: function(c, b, a, d) {
                        return c._defaults.isRTL ? void 0 !== d ? b.slider("value", -1 * d) : Math.abs(b.slider("value")) : void 0 !== d ? b.slider("value", d) : b.slider("value")
                    }
                },
                select: {
                    create: function(c, b, a, d, f, g, k) {
                        var h = '\x3cselect class\x3d"ui-timepicker-select" data-unit\x3d"' + a + '" data-min\x3d"' + f + '" data-max\x3d"' + g + '" data-step\x3d"' + k + '"\x3e';
                        for (c._defaults.timeFormat.indexOf("t"); f <= g; f += k) h += '\x3coption value\x3d"' + f + '"' + (f == d ? " selected" : "") + "\x3e", h = "hour" == a && q(c._defaults.pickerTimeFormat || c._defaults.timeFormat) ?
                            h + e.datepicker.formatTime("hh TT", {
                                hour: f
                            }, c._defaults) : "millisec" == a || 10 <= f ? h + f : h + ("0" + f.toString()), h += "\x3c/option\x3e";
                        h += "\x3c/select\x3e";
                        b.children("select").remove();
                        e(h).appendTo(b).change(function(a) {
                            c._onTimeChange();
                            c._onSelectHandler()
                        });
                        return b
                    },
                    options: function(c, b, a, d, e) {
                        a = {};
                        var g = b.children("select");
                        if ("string" == typeof d) {
                            if (void 0 === e) return g.data(d);
                            a[d] = e
                        } else a = d;
                        return c.control.create(c, b, g.data("unit"), g.val(), a.min || g.data("min"), a.max || g.data("max"), a.step || g.data("step"))
                    },
                    value: function(c, b, a, d) {
                        c = b.children("select");
                        return void 0 !== d ? c.val(d) : c.val()
                    }
                }
            }
        });
        e.fn.extend({
            timepicker: function(c) {
                c = c || {};
                var b = Array.prototype.slice.call(arguments);
                "object" == typeof c && (b[0] = e.extend(c, {
                    timeOnly: !0
                }));
                return e(this).each(function() {
                    e.fn.datetimepicker.apply(e(this), b)
                })
            },
            datetimepicker: function(c) {
                c = c || {};
                var b = arguments;
                return "string" == typeof c ? "getDate" == c ? e.fn.datepicker.apply(e(this[0]), b) : this.each(function() {
                    var a = e(this);
                    a.datepicker.apply(a, b)
                }) : this.each(function() {
                    var a =
                        e(this);
                    a.datepicker(e.timepicker._newInst(a, c)._defaults)
                })
            }
        });
        e.datepicker.parseDateTime = function(c, b, a, d, e) {
            c = w(c, b, a, d, e);
            c.timeObj && (b = c.timeObj, c.date.setHours(b.hour, b.minute, b.second, b.millisec));
            return c.date
        };
        e.datepicker.parseTime = function(c, b, a) {
            a = u(u({}, e.timepicker._defaults), a || {});
            var d = function(a, b, c) {
                    var d = function(a, b) {
                            var c = [];
                            a && e.merge(c, a);
                            b && e.merge(c, b);
                            c = e.map(c, function(a) {
                                return a.replace(/[.*+?|()\[\]{}\\]/g, "\\$\x26")
                            });
                            return "(" + c.join("|") + ")?"
                        },
                        f = "^" + a.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[lz]|'.*?')/g,
                            function(a) {
                                switch (a.charAt(0).toLowerCase()) {
                                    case "h":
                                        return "(\\d?\\d)";
                                    case "m":
                                        return "(\\d?\\d)";
                                    case "s":
                                        return "(\\d?\\d)";
                                    case "l":
                                        return "(\\d?\\d?\\d)";
                                    case "z":
                                        return "(z|[-+]\\d\\d:?\\d\\d|\\S+)?";
                                    case "t":
                                        return d(c.amNames, c.pmNames);
                                    default:
                                        return "(" + a.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function(a) {
                                            return "\\" + a
                                        }) + ")?"
                                }
                            }).replace(/\s/g, "\\s?") + c.timeSuffix + "$";
                    a = function(a) {
                        a = a.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|t{1,2}|z|'.*?')/g);
                        var b = {
                            h: -1,
                            m: -1,
                            s: -1,
                            l: -1,
                            t: -1,
                            z: -1
                        };
                        if (a)
                            for (var c = 0; c < a.length; c++) - 1 == b[a[c].toString().charAt(0)] && (b[a[c].toString().charAt(0)] = c + 1);
                        return b
                    }(a);
                    var l = "",
                        f = b.match(new RegExp(f, "i"));
                    b = {
                        hour: 0,
                        minute: 0,
                        second: 0,
                        millisec: 0
                    };
                    if (f) {
                        -1 !== a.t && (void 0 === f[a.t] || 0 === f[a.t].length ? (l = "", b.ampm = "") : (l = -1 !== e.inArray(f[a.t].toUpperCase(), c.amNames) ? "AM" : "PM", b.ampm = c["AM" == l ? "amNames" : "pmNames"][0])); - 1 !== a.h && (b.hour = "AM" == l && "12" == f[a.h] ? 0 : "PM" == l && "12" != f[a.h] ? parseInt(f[a.h], 10) + 12 : Number(f[a.h])); - 1 !== a.m &&
                            (b.minute = Number(f[a.m])); - 1 !== a.s && (b.second = Number(f[a.s])); - 1 !== a.l && (b.millisec = Number(f[a.l]));
                        if (-1 !== a.z && void 0 !== f[a.z]) {
                            a = f[a.z].toUpperCase();
                            switch (a.length) {
                                case 1:
                                    a = c.timezoneIso8601 ? "Z" : "+0000";
                                    break;
                                case 5:
                                    c.timezoneIso8601 && (a = "0000" == a.substring(1) ? "Z" : a.substring(0, 3) + ":" + a.substring(3));
                                    break;
                                case 6:
                                    c.timezoneIso8601 ? "00:00" == a.substring(1) && (a = "Z") : a = "Z" == a || "00:00" == a.substring(1) ? "+0000" : a.replace(/:/, "")
                            }
                            b.timezone = a
                        }
                        return b
                    }
                    return !1
                },
                f = function(a, b, c) {
                    try {
                        var f = new Date("2012-01-01 " +
                            b);
                        return {
                            hour: f.getHours(),
                            minutes: f.getMinutes(),
                            seconds: f.getSeconds(),
                            millisec: f.getMilliseconds(),
                            timezone: e.timepicker.timeZoneOffsetString(f)
                        }
                    } catch (n) {
                        try {
                            return d(a, b, c)
                        } catch (l) {
                            e.datepicker.log("Unable to parse \ntimeString: " + b + "\ntimeFormat: " + a)
                        }
                    }
                    return !1
                };
            return "function" === typeof a.parse ? a.parse(c, b, a) : "loose" === a.parse ? f(c, b, a) : d(c, b, a)
        };
        e.datepicker.formatTime = function(c, b, a) {
            a = a || {};
            a = e.extend({}, e.timepicker._defaults, a);
            b = e.extend({
                    hour: 0,
                    minute: 0,
                    second: 0,
                    millisec: 0,
                    timezone: "+0000"
                },
                b);
            var d = a.amNames[0],
                f = parseInt(b.hour, 10);
            11 < f && (d = a.pmNames[0]);
            c = c.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[lz]|('.*?'|".*?"))/g, function(c) {
                switch (c) {
                    case "HH":
                        return ("0" + f).slice(-2);
                    case "H":
                        return f;
                    case "hh":
                        return ("0" + y(f)).slice(-2);
                    case "h":
                        return y(f);
                    case "mm":
                        return ("0" + b.minute).slice(-2);
                    case "m":
                        return b.minute;
                    case "ss":
                        return ("0" + b.second).slice(-2);
                    case "s":
                        return b.second;
                    case "l":
                        return ("00" + b.millisec).slice(-3);
                    case "z":
                        return null === b.timezone ? a.defaultTimezone : b.timezone;
                    case "T":
                        return d.charAt(0).toUpperCase();
                    case "TT":
                        return d.toUpperCase();
                    case "t":
                        return d.charAt(0).toLowerCase();
                    case "tt":
                        return d.toLowerCase();
                    default:
                        return c.replace(/\'/g, "") || "'"
                }
            });
            return c = e.trim(c)
        };
        e.datepicker._base_selectDate = e.datepicker._selectDate;
        e.datepicker._selectDate = function(c, b) {
            var a = this._getInst(e(c)[0]),
                d = this._get(a, "timepicker");
            d ? (d._limitMinMaxDateTime(a, !0), a.inline = a.stay_open = !0, this._base_selectDate(c, b), a.inline = a.stay_open = !1, this._notifyChange(a), this._updateDatepicker(a)) :
                this._base_selectDate(c, b)
        };
        e.datepicker._base_updateDatepicker = e.datepicker._updateDatepicker;
        e.datepicker._updateDatepicker = function(c) {
            var b = c.input[0];
            if (!e.datepicker._curInst || e.datepicker._curInst == c || !e.datepicker._datepickerShowing || e.datepicker._lastInput == b)
                if ("boolean" !== typeof c.stay_open || !1 === c.stay_open)
                    if (this._base_updateDatepicker(c), b = this._get(c, "timepicker")) b._addTimePicker(c), b._defaults.useLocalTimezone && (r(b, new Date(c.selectedYear, c.selectedMonth, c.selectedDay, 12)), b._onTimeChange())
        };
        e.datepicker._base_doKeyPress = e.datepicker._doKeyPress;
        e.datepicker._doKeyPress = function(c) {
            var b = e.datepicker._getInst(c.target),
                a = e.datepicker._get(b, "timepicker");
            if (a && e.datepicker._get(b, "constrainInput")) {
                var d = q(a._defaults.timeFormat),
                    b = e.datepicker._possibleChars(e.datepicker._get(b, "dateFormat")),
                    a = a._defaults.timeFormat.toString().replace(/[hms]/g, "").replace(/TT/g, d ? "APM" : "").replace(/Tt/g, d ? "AaPpMm" : "").replace(/tT/g, d ? "AaPpMm" : "").replace(/T/g, d ? "AP" : "").replace(/tt/g, d ? "apm" : "").replace(/t/g,
                        d ? "ap" : "") + " " + a._defaults.separator + a._defaults.timeSuffix + (a._defaults.showTimezone ? a._defaults.timezoneList.join("") : "") + a._defaults.amNames.join("") + a._defaults.pmNames.join("") + b,
                    d = String.fromCharCode(void 0 === c.charCode ? c.keyCode : c.charCode);
                return c.ctrlKey || " " > d || !b || -1 < a.indexOf(d)
            }
            return e.datepicker._base_doKeyPress(c)
        };
        e.datepicker._base_updateAlternate = e.datepicker._updateAlternate;
        e.datepicker._updateAlternate = function(c) {
            var b = this._get(c, "timepicker");
            if (b) {
                var a = b._defaults.altField;
                if (a) {
                    var d = this._getDate(c);
                    c = e.datepicker._getFormatConfig(c);
                    var f, g = b._defaults.altSeparator ? b._defaults.altSeparator : b._defaults.separator;
                    f = b._defaults.altTimeSuffix ? b._defaults.altTimeSuffix : b._defaults.timeSuffix;
                    f = "" + (e.datepicker.formatTime(null !== b._defaults.altTimeFormat ? b._defaults.altTimeFormat : b._defaults.timeFormat, b, b._defaults) + f);
                    b._defaults.timeOnly || b._defaults.altFieldTimeOnly || (f = b._defaults.altFormat ? e.datepicker.formatDate(b._defaults.altFormat, null === d ? new Date : d, c) + g + f :
                        b.formattedDate + g + f);
                    e(a).val(f)
                }
            } else e.datepicker._base_updateAlternate(c)
        };
        e.datepicker._base_doKeyUp = e.datepicker._doKeyUp;
        e.datepicker._doKeyUp = function(c) {
            var b = e.datepicker._getInst(c.target),
                a = e.datepicker._get(b, "timepicker");
            if (a && a._defaults.timeOnly && b.input.val() != b.lastVal) try {
                e.datepicker._updateDatepicker(b)
            } catch (d) {
                e.datepicker.log(d)
            }
            return e.datepicker._base_doKeyUp(c)
        };
        e.datepicker._base_gotoToday = e.datepicker._gotoToday;
        e.datepicker._gotoToday = function(c) {
            var b = this._getInst(e(c)[0]),
                a = b.dpDiv;
            this._base_gotoToday(c);
            c = this._get(b, "timepicker");
            r(c);
            this._setTime(b, new Date);
            e(".ui-datepicker-today", a).click()
        };
        e.datepicker._disableTimepickerDatepicker = function(c) {
            var b = this._getInst(c);
            if (b) {
                var a = this._get(b, "timepicker");
                e(c).datepicker("getDate");
                a && (a._defaults.showTimepicker = !1, a._updateDateTime(b))
            }
        };
        e.datepicker._enableTimepickerDatepicker = function(c) {
            var b = this._getInst(c);
            if (b) {
                var a = this._get(b, "timepicker");
                e(c).datepicker("getDate");
                a && (a._defaults.showTimepicker = !0, a._addTimePicker(b), a._updateDateTime(b))
            }
        };
        e.datepicker._setTime = function(c, b) {
            var a = this._get(c, "timepicker");
            if (a) {
                var d = a._defaults;
                a.hour = b ? b.getHours() : d.hour;
                a.minute = b ? b.getMinutes() : d.minute;
                a.second = b ? b.getSeconds() : d.second;
                a.millisec = b ? b.getMilliseconds() : d.millisec;
                a._limitMinMaxDateTime(c, !0);
                a._onTimeChange();
                a._updateDateTime(c)
            }
        };
        e.datepicker._setTimeDatepicker = function(c, b, a) {
            if (c = this._getInst(c)) {
                var d = this._get(c, "timepicker");
                d && (this._setDateFromField(c), b && ("string" == typeof b ?
                    (d._parseTime(b, a), b = new Date, b.setHours(d.hour, d.minute, d.second, d.millisec)) : b = new Date(b.getTime()), "Invalid Date" == b.toString() && (b = void 0), this._setTime(c, b)))
            }
        };
        e.datepicker._base_setDateDatepicker = e.datepicker._setDateDatepicker;
        e.datepicker._setDateDatepicker = function(c, b) {
            var a = this._getInst(c);
            if (a) {
                var d = b instanceof Date ? new Date(b.getTime()) : b;
                this._updateDatepicker(a);
                this._base_setDateDatepicker.apply(this, arguments);
                this._setTimeDatepicker(c, d, !0)
            }
        };
        e.datepicker._base_getDateDatepicker =
            e.datepicker._getDateDatepicker;
        e.datepicker._getDateDatepicker = function(c, b) {
            var a = this._getInst(c);
            if (a) {
                var d = this._get(a, "timepicker");
                return d ? (void 0 === a.lastVal && this._setDateFromField(a, b), (a = this._getDate(a)) && d._parseTime(e(c).val(), d.timeOnly) && a.setHours(d.hour, d.minute, d.second, d.millisec), a) : this._base_getDateDatepicker(c, b)
            }
        };
        e.datepicker._base_parseDate = e.datepicker.parseDate;
        e.datepicker.parseDate = function(c, b, a) {
            var d;
            try {
                d = this._base_parseDate(c, b, a)
            } catch (f) {
                d = this._base_parseDate(c,
                    b.substring(0, b.length - (f.length - f.indexOf(":") - 2)), a), e.datepicker.log("Error parsing the date string: " + f + "\ndate string \x3d " + b + "\ndate format \x3d " + c)
            }
            return d
        };
        e.datepicker._base_formatDate = e.datepicker._formatDate;
        e.datepicker._formatDate = function(c, b, a, d) {
            return (b = this._get(c, "timepicker")) ? (b._updateDateTime(c), b.$input.val()) : this._base_formatDate(c)
        };
        e.datepicker._base_optionDatepicker = e.datepicker._optionDatepicker;
        e.datepicker._optionDatepicker = function(c, b, a) {
            var d = this._getInst(c),
                f;
            if (!d) return null;
            if (d = this._get(d, "timepicker")) {
                var g = null,
                    k = null,
                    h = null,
                    m = d._defaults.evnts,
                    n = {},
                    l;
                if ("string" == typeof b)
                    if ("minDate" === b || "minDateTime" === b) g = a;
                    else if ("maxDate" === b || "maxDateTime" === b) k = a;
                else if ("onSelect" === b) h = a;
                else {
                    if (m.hasOwnProperty(b)) {
                        if ("undefined" === typeof a) return m[b];
                        n[b] = a;
                        f = {}
                    }
                } else if ("object" == typeof b)
                    for (l in b.minDate ? g = b.minDate : b.minDateTime ? g = b.minDateTime : b.maxDate ? k = b.maxDate : b.maxDateTime && (k = b.maxDateTime), m) m.hasOwnProperty(l) && b[l] && (n[l] = b[l]);
                for (l in n) n.hasOwnProperty(l) && (m[l] = n[l], f || (f = e.extend({}, b)), delete f[l]);
                if (l = f) a: {
                    l = f;
                    for (var p in l)
                        if (l.hasOwnProperty(l)) {
                            l = !1;
                            break a
                        }
                    l = !0
                }
                if (l) return;
                g ? (g = 0 === g ? new Date : new Date(g), d._defaults.minDate = g, d._defaults.minDateTime = g) : k ? (k = 0 === k ? new Date : new Date(k), d._defaults.maxDate = k, d._defaults.maxDateTime = k) : h && (d._defaults.onSelect = h)
            }
            return void 0 === a ? this._base_optionDatepicker.call(e.datepicker, c, b) : this._base_optionDatepicker.call(e.datepicker, c, f || b, a)
        };
        var u = function(c, b) {
                e.extend(c,
                    b);
                for (var a in b)
                    if (null === b[a] || void 0 === b[a]) c[a] = b[a];
                return c
            },
            q = function(c) {
                return -1 !== c.indexOf("t") && -1 !== c.indexOf("h")
            },
            y = function(c) {
                12 < c && (c -= 12);
                0 == c && (c = 12);
                return String(c)
            },
            w = function(c, b, a, d, f) {
                var g;
                a: {
                    try {
                        var k = f && f.separator ? f.separator : e.timepicker._defaults.separator,
                            h = (f && f.timeFormat ? f.timeFormat : e.timepicker._defaults.timeFormat).split(k).length,
                            m = a.split(k),
                            n = m.length;
                        if (1 < n) {
                            g = [m.splice(0, n - h).join(k), m.splice(0, h).join(k)];
                            break a
                        }
                    } catch (l) {
                        if (e.datepicker.log("Could not split the date from the time. Please check the following datetimepicker options\nthrown error: " +
                                l + "\ndateTimeString" + a + "\ndateFormat \x3d " + c + "\nseparator \x3d " + f.separator + "\ntimeFormat \x3d " + f.timeFormat), 0 <= l.indexOf(":")) {
                            g = a.length - (l.length - l.indexOf(":") - 2);
                            a.substring(g);
                            g = [e.trim(a.substring(0, g)), e.trim(a.substring(g))];
                            break a
                        } else throw l;
                    }
                    g = [a, ""]
                }
                c = e.datepicker._base_parseDate(c, g[0], d);
                if ("" !== g[1]) {
                    b = e.datepicker.parseTime(b, g[1], f);
                    if (null === b) throw "Wrong time format";
                    return {
                        date: c,
                        timeObj: b
                    }
                }
                return {
                    date: c
                }
            },
            r = function(c, b) {
                if (c && c.timezone_select) {
                    c._defaults.useLocalTimezone = !0;
                    var a = e.timepicker.timeZoneOffsetString("undefined" !== typeof b ? b : new Date);
                    c._defaults.timezoneIso8601 && (a = a.substring(0, 3) + ":" + a.substring(3));
                    c.timezone_select.val(a)
                }
            };
        e.timepicker = new t;
        e.timepicker.timeZoneOffsetString = function(c) {
            c = -1 * c.getTimezoneOffset();
            var b = c % 60;
            return (0 <= c ? "+" : "-") + ("0" + ((c - b) / 60 * 101).toString()).substr(-2) + ("0" + (101 * b).toString()).substr(-2)
        };
        e.timepicker.timeRange = function(c, b, a) {
            return e.timepicker.handleRange("timepicker", c, b, a)
        };
        e.timepicker.dateTimeRange = function(c,
            b, a) {
            e.timepicker.dateRange(c, b, a, "datetimepicker")
        };
        e.timepicker.dateRange = function(c, b, a, d) {
            e.timepicker.handleRange(d || "datepicker", c, b, a)
        };
        e.timepicker.handleRange = function(c, b, a, d) {
            function f(c, d, e) {
                d.val() && new Date(b.val()) > new Date(a.val()) && d.val(e)
            }

            function g(a, b, d) {
                e(a).val() && (a = e(a)[c].call(e(a), "getDate"), a.getTime && e(b)[c].call(e(b), "option", d, a))
            }
            e.fn[c].call(b, e.extend({
                onClose: function(b, c) {
                    f(this, a, b)
                },
                onSelect: function(b) {
                    g(this, a, "minDate")
                }
            }, d, d.start));
            e.fn[c].call(a, e.extend({
                onClose: function(a,
                    c) {
                    f(this, b, a)
                },
                onSelect: function(a) {
                    g(this, b, "maxDate")
                }
            }, d, d.end));
            "timepicker" != c && d.reformat && e([b, a]).each(function() {
                var a = e(this)[c].call(e(this), "option", "dateFormat"),
                    b = new Date(e(this).val());
                e(this).val() && b && e(this).val(e.datepicker.formatDate(a, b))
            });
            f(b, a, b.val());
            g(b, a, "minDate");
            g(a, b, "maxDate");
            return e([b.get(0), a.get(0)])
        };
        e.timepicker.version = "1.1.1"
    }
})(jQuery);
(function() {
    var d = function(b, c) {
        var e = d.resolve(b, c || "/"),
            m = d.modules[e];
        if (!m) throw Error("Failed to resolve module " + b + ", tried " + e);
        return (e = d.cache[e]) ? e.exports : m()
    };
    d.paths = [];
    d.modules = {};
    d.cache = {};
    d.extensions = [".js", ".coffee", ".json"];
    d._core = {
        assert: !0,
        events: !0,
        fs: !0,
        path: !0,
        vm: !0
    };
    d.resolve = function() {
        return function(b, c) {
            function e(a) {
                a = h.normalize(a);
                if (d.modules[a]) return a;
                for (var f = 0; f < d.extensions.length; f++) {
                    var b = d.extensions[f];
                    if (d.modules[a + b]) return a + b
                }
            }

            function m(a) {
                a = a.replace(/\/+$/,
                    "");
                var f = h.normalize(a + "/package.json");
                if (d.modules[f]) {
                    var f = d.modules[f](),
                        b = f.browserify;
                    if ("object" == typeof b && b.main) {
                        if (f = e(h.resolve(a, b.main))) return f
                    } else if ("string" == typeof b) {
                        if (f = e(h.resolve(a, b))) return f
                    } else if (f.main && (f = e(h.resolve(a, f.main)))) return f
                }
                return e(a + "/index")
            }
            c || (c = "/");
            if (d._core[b]) return b;
            var h = d.modules.path(),
                g = (c = h.resolve("/", c)) || "/";
            if (b.match(/^(?:\.\.?\/|\/)/)) {
                var k = e(h.resolve(g, b)) || m(h.resolve(g, b));
                if (k) return k
            }
            if (g = function(a, f) {
                    var b;
                    "/" === f ?
                        b = [""] : b = h.normalize(f).split("/");
                    for (var p = [], l = b.length - 1; 0 <= l; l--)
                        if ("node_modules" !== b[l]) {
                            var q = b.slice(0, l + 1).join("/") + "/node_modules";
                            p.push(q)
                        }
                    for (b = 0; b < p.length; b++) {
                        l = p[b];
                        if (q = e(l + "/" + a)) return q;
                        if (l = m(l + "/" + a)) return l
                    }
                    if (q = e(a)) return q
                }(b, g)) return g;
            throw Error("Cannot find module '" + b + "'");
        }
    }();
    d.alias = function(b, c) {
        var e = d.modules.path(),
            m = null;
        try {
            m = d.resolve(b + "/package.json", "/")
        } catch (k) {
            m = d.resolve(b, "/")
        }
        for (var e = e.dirname(m), m = (Object.keys || function(b) {
                var a = [],
                    f;
                for (f in b) a.push(f);
                return a
            })(d.modules), h = 0; h < m.length; h++) {
            var g = m[h];
            g.slice(0, e.length + 1) === e + "/" ? (g = g.slice(e.length), d.modules[c + g] = d.modules[e + g]) : g === e && (d.modules[c] = d.modules[e])
        }
    };
    (function() {
        var b = {},
            c = "undefined" != typeof window ? window : {},
            e = !1;
        d.define = function(m, h) {
            !e && d.modules.__browserify_process && (b = d.modules.__browserify_process(), e = !0);
            var g = d._core[m] ? "" : d.modules.path().dirname(m),
                k = function(b) {
                    var c = d(b, g);
                    b = d.cache[d.resolve(b, g)];
                    return b && null === b.parent && (b.parent = a), c
                };
            k.resolve = function(a) {
                return d.resolve(a,
                    g)
            };
            k.modules = d.modules;
            k.define = d.define;
            k.cache = d.cache;
            var a = {
                id: m,
                filename: m,
                exports: {},
                loaded: !1,
                parent: null
            };
            d.modules[m] = function() {
                return d.cache[m] = a, h.call(a.exports, k, a, a.exports, g, m, b, c), a.loaded = !0, a.exports
            }
        }
    })();
    d.define("path", function(b, c, e, d, h, g, k) {
        function a(a, b) {
            for (var f = [], c = 0; c < a.length; c++) b(a[c], c, a) && f.push(a[c]);
            return f
        }

        function f(a, b) {
            for (var f = 0, c = a.length; 0 <= c; c--) {
                var e = a[c];
                "." == e ? a.splice(c, 1) : ".." === e ? (a.splice(c, 1), f++) : f && (a.splice(c, 1), f--)
            }
            if (b)
                for (; f--; f) a.unshift("..");
            return a
        }
        var n = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;
        e.resolve = function() {
            for (var b = "", l = !1, c = arguments.length; - 1 <= c && !l; c--) {
                var e = 0 <= c ? arguments[c] : g.cwd();
                "string" == typeof e && e && (b = e + "/" + b, l = "/" === e.charAt(0))
            }
            return b = f(a(b.split("/"), function(a) {
                return !!a
            }), !l).join("/"), (l ? "/" : "") + b || "."
        };
        e.normalize = function(b) {
            var c = "/" === b.charAt(0),
                e = "/" === b.slice(-1);
            return b = f(a(b.split("/"), function(a) {
                return !!a
            }), !c).join("/"), !b && !c && (b = "."), b && e && (b += "/"), (c ? "/" : "") + b
        };
        e.join = function() {
            var b = Array.prototype.slice.call(arguments,
                0);
            return e.normalize(a(b, function(a, b) {
                return a && "string" == typeof a
            }).join("/"))
        };
        e.dirname = function(a) {
            return (a = n.exec(a)[1] || "") ? 1 === a.length ? a : a.substring(0, a.length - 1) : "."
        };
        e.basename = function(a, b) {
            var f = n.exec(a)[2] || "";
            return b && f.substr(-1 * b.length) === b && (f = f.substr(0, f.length - b.length)), f
        };
        e.extname = function(a) {
            return n.exec(a)[3] || ""
        }
    });
    d.define("__browserify_process", function(b, c, e, d, h, g, k) {
        g = c.exports = {};
        g.nextTick = function() {
            if ("undefined" != typeof window && window.setImmediate) return window.setImmediate;
            if ("undefined" != typeof window && window.postMessage && window.addEventListener) {
                var a = [];
                return window.addEventListener("message", function(b) {
                        b.source === window && "browserify-tick" === b.data && (b.stopPropagation(), 0 < a.length && a.shift()())
                    }, !0),
                    function(b) {
                        a.push(b);
                        window.postMessage("browserify-tick", "*")
                    }
            }
            return function(a) {
                setTimeout(a, 0)
            }
        }();
        g.title = "browser";
        g.browser = !0;
        g.env = {};
        g.argv = [];
        g.binding = function(a) {
            if ("evals" === a) return b("vm");
            throw Error("No such module. (Possibly not yet loaded)");
        };
        (function() {
            var a = "/",
                f;
            g.cwd = function() {
                return a
            };
            g.chdir = function(c) {
                f || (f = b("path"));
                a = f.resolve(c, a)
            }
        })()
    });
    d.define("/ArrayList.js", function(b, c, e, d, h, g, k) {
        function a(a) {
            this.array = [];
            a instanceof f && this.addAll(a)
        }
        var f = b("./Collection");
        e = b("./List");
        var n = b("./IndexOutOfBoundsException"),
            p = b("./NoSuchElementException"),
            l = b("./OperationNotSupported");
        a.prototype = new e;
        a.prototype.array = null;
        a.prototype.add = function(a) {
            return this.array.push(a), !0
        };
        a.prototype.addAll = function(a) {
            for (a = a.iterator(); a.hasNext();) this.add(a.next());
            return !0
        };
        a.prototype.set = function(a, b) {
            var f = this.array[a];
            return this.array[a] = b, f
        };
        a.prototype.iterator = function() {
            return new a.Iterator(this)
        };
        a.prototype.get = function(a) {
            if (0 > a || a >= this.size()) throw new n;
            return this.array[a]
        };
        a.prototype.isEmpty = function() {
            return 0 === this.array.length
        };
        a.prototype.size = function() {
            return this.array.length
        };
        a.prototype.toArray = function() {
            for (var a = [], b = 0, f = this.array.length; b < f; b++) a.push(this.array[b]);
            return a
        };
        a.prototype.remove = function(a) {
            for (var b = !1, f =
                    0, c = this.array.length; f < c; f++)
                if (this.array[f] === a) {
                    this.array.splice(f, 1);
                    b = !0;
                    break
                }
            return b
        };
        a.Iterator = function(a) {
            this.arrayList = a
        };
        a.Iterator.prototype.arrayList = null;
        a.Iterator.prototype.position = 0;
        a.Iterator.prototype.next = function() {
            if (this.position === this.arrayList.size()) throw new p;
            return this.arrayList.get(this.position++)
        };
        a.Iterator.prototype.hasNext = function() {
            return this.position < this.arrayList.size() ? !0 : !1
        };
        a.Iterator.prototype.remove = function() {
            throw new l;
        };
        c.exports = a
    });
    d.define("/Collection.js",
        function(b, c, e, d, h, g, k) {
            function a() {}
            b("./Iterator");
            a.prototype.add = function(a) {};
            a.prototype.addAll = function(a) {};
            a.prototype.isEmpty = function() {};
            a.prototype.iterator = function() {};
            a.prototype.size = function() {};
            a.prototype.toArray = function() {};
            a.prototype.remove = function(a) {};
            c.exports = a
        });
    d.define("/Iterator.js", function(b, c, e, d, h, g, k) {
        function a() {}
        a.prototype.hasNext = function() {};
        a.prototype.next = function() {};
        a.prototype.remove = function() {};
        c.exports = a
    });
    d.define("/List.js", function(b, c, e, d,
        h, g, k) {
        function a() {}
        b = b("./Collection");
        a.prototype = new b;
        a.prototype.get = function(a) {};
        a.prototype.set = function(a, b) {};
        a.prototype.isEmpty = function() {};
        c.exports = a
    });
    d.define("/IndexOutOfBoundsException.js", function(b, c, e, d, h, g, k) {
        function a(a) {
            this.message = a || ""
        }
        a.prototype = Error();
        a.prototype.name = "IndexOutOfBoundsException";
        c.exports = a
    });
    d.define("/NoSuchElementException.js", function(b, c, e, d, h, g, k) {
        function a(a) {
            this.message = a || ""
        }
        a.prototype = Error();
        a.prototype.name = "NoSuchElementException";
        c.exports = a
    });
    d.define("/OperationNotSupported.js", function(b, c, e, d, h, g, k) {
        function a(a) {
            this.message = a || ""
        }
        a.prototype = Error();
        a.prototype.name = "OperationNotSupported";
        c.exports = a
    });
    d.define("/Arrays.js", function(b, c, e, d, h, g, k) {
        function a() {}
        a.sort = function() {
            var a = arguments[0],
                b, c, l;
            if (1 === arguments.length) a.sort();
            else if (2 === arguments.length) c = arguments[1], l = function(a, b) {
                return c.compare(a, b)
            }, a.sort(l);
            else if (3 === arguments.length)
                for (b = a.slice(arguments[1], arguments[2]), b.sort(), l = a.slice(0,
                        arguments[1]).concat(b, a.slice(arguments[2], a.length)), a.splice(0, a.length), b = 0; b < l.length; b++) a.push(l[b]);
            else if (4 === arguments.length)
                for (b = a.slice(arguments[1], arguments[2]), c = arguments[3], l = function(a, b) {
                        return c.compare(a, b)
                    }, b.sort(l), l = a.slice(0, arguments[1]).concat(b, a.slice(arguments[2], a.length)), a.splice(0, a.length), b = 0; b < l.length; b++) a.push(l[b])
        };
        a.asList = function(a) {
            for (var b = new javascript.util.ArrayList, c = 0, l = a.length; c < l; c++) b.add(a[c]);
            return b
        };
        c.exports = a
    });
    d.define("/EmptyStackException.js",
        function(b, c, e, d, h, g, k) {
            function a(a) {
                this.message = a || ""
            }
            a.prototype = Error();
            a.prototype.name = "EmptyStackException";
            c.exports = a
        });
    d.define("/HashMap.js", function(b, c, e, d, h, g, k) {
        function a() {
            this.object = {}
        }
        e = b("./Map");
        b("./ArrayList");
        a.prototype = new e;
        a.prototype.object = null;
        a.prototype.get = function(a) {
            return this.object[a] || null
        };
        a.prototype.put = function(a, b) {
            return this.object[a] = b, b
        };
        a.prototype.values = function() {
            var a = new javascript.util.ArrayList,
                b;
            for (b in this.object) this.object.hasOwnProperty(b) &&
                a.add(this.object[b]);
            return a
        };
        a.prototype.size = function() {
            return this.values().size()
        };
        c.exports = a
    });
    d.define("/Map.js", function(b, c, e, d, h, g, k) {
        function a() {}
        a.prototype.get = function(a) {};
        a.prototype.put = function(a, b) {};
        a.prototype.size = function() {};
        a.prototype.values = function() {};
        c.exports = a
    });
    d.define("/Set.js", function(b, c, d, m, h, g, k) {
        function a() {}
        b = b("./Collection");
        a.prototype = new b;
        a.prototype.contains = function(a) {};
        c.exports = a
    });
    d.define("/HashSet.js", function(b, c, d, m, h, g, k) {
        function a(a) {
            this.array = [];
            a instanceof f && this.addAll(a)
        }
        var f = b("./Collection");
        d = b("./Set");
        var n = b("./OperationNotSupported"),
            p = b("./NoSuchElementException");
        a.prototype = new d;
        a.prototype.array = null;
        a.prototype.contains = function(a) {
            for (var b = 0, c = this.array.length; b < c; b++)
                if (this.array[b] === a) return !0;
            return !1
        };
        a.prototype.add = function(a) {
            return this.contains(a) ? !1 : (this.array.push(a), !0)
        };
        a.prototype.addAll = function(a) {
            for (a = a.iterator(); a.hasNext();) this.add(a.next());
            return !0
        };
        a.prototype.remove = function(a) {
            throw new n;
        };
        a.prototype.size = function() {
            return this.array.length
        };
        a.prototype.isEmpty = function() {
            return 0 === this.array.length
        };
        a.prototype.toArray = function() {
            for (var a = [], b = 0, c = this.array.length; b < c; b++) a.push(this.array[b]);
            return a
        };
        a.prototype.iterator = function() {
            return new a.Iterator(this)
        };
        a.Iterator = function(a) {
            this.hashSet = a
        };
        a.Iterator.prototype.hashSet = null;
        a.Iterator.prototype.position = 0;
        a.Iterator.prototype.next = function() {
            if (this.position === this.hashSet.size()) throw new p;
            return this.hashSet.array[this.position++]
        };
        a.Iterator.prototype.hasNext = function() {
            return this.position < this.hashSet.size() ? !0 : !1
        };
        a.Iterator.prototype.remove = function() {
            throw new javascript.util.OperationNotSupported;
        };
        c.exports = a
    });
    d.define("/SortedMap.js", function(b, c, d, m, h, g, k) {
        function a() {}
        b = b("./Map");
        a.prototype = new b;
        c.exports = a
    });
    d.define("/SortedSet.js", function(b, c, d, m, h, g, k) {
        function a() {}
        b = b("./Set");
        a.prototype = new b;
        c.exports = a
    });
    d.define("/Stack.js", function(b, c, d, m, h, g, k) {
        function a() {
            this.array = []
        }
        d = b("./List");
        var f = b("./EmptyStackException");
        a.prototype = new d;
        a.prototype.array = null;
        a.prototype.push = function(a) {
            return this.array.push(a), a
        };
        a.prototype.pop = function(a) {
            if (0 === this.array.length) throw new f;
            return this.array.pop()
        };
        a.prototype.peek = function() {
            if (0 === this.array.length) throw new f;
            return this.array[this.array.length - 1]
        };
        a.prototype.empty = function(a) {
            return 0 === this.array.length ? !0 : !1
        };
        a.prototype.isEmpty = function() {
            return this.empty()
        };
        a.prototype.search = function(a) {
            return this.array.indexOf(a)
        };
        a.prototype.size = function() {
            return this.array.length
        };
        a.prototype.toArray = function() {
            for (var a = [], b = 0, c = this.array.length; b < c; b++) a.push(this.array[b]);
            return a
        };
        c.exports = a
    });
    d.define("/TreeMap.js", function(b, c, d, m, h, g, k) {
        function a() {
            this.array = []
        }
        d = b("./Map");
        b("./SortedMap");
        b("./ArrayList");
        a.prototype = new d;
        a.prototype.array = null;
        a.prototype.get = function(a) {
            for (var b = 0, c = this.array.length; b < c; b++) {
                var d = this.array[b];
                if (0 === d.key.compareTo(a)) return d.value
            }
            return null
        };
        a.prototype.put = function(a, b) {
            var c = this.get(a);
            if (c) {
                var d = c.value;
                return c.value =
                    b, d
            }
            for (var d = {
                    key: a,
                    value: b
                }, e = 0, g = this.array.length; e < g; e++)
                if (c = this.array[e], 1 === c.key.compareTo(a)) return this.array.splice(e, 0, d), null;
            return this.array.push({
                key: a,
                value: b
            }), null
        };
        a.prototype.values = function() {
            for (var a = new javascript.util.ArrayList, b = 0, c = this.array.length; b < c; b++) a.add(this.array[b].value);
            return a
        };
        a.prototype.size = function() {
            return this.values().size()
        };
        c.exports = a
    });
    d.define("/TreeSet.js", function(b, c, d, m, h, g, k) {
        function a(a) {
            this.array = [];
            a instanceof f && this.addAll(a)
        }
        var f = b("./Collection");
        d = b("./SortedSet");
        var n = b("./OperationNotSupported"),
            p = b("./NoSuchElementException");
        a.prototype = new d;
        a.prototype.array = null;
        a.prototype.contains = function(a) {
            for (var b = 0, c = this.array.length; b < c; b++)
                if (0 === this.array[b].compareTo(a)) return !0;
            return !1
        };
        a.prototype.add = function(a) {
            if (this.contains(a)) return !1;
            for (var b = 0, c = this.array.length; b < c; b++)
                if (1 === this.array[b].compareTo(a)) return this.array.splice(b, 0, a), !0;
            return this.array.push(a), !0
        };
        a.prototype.addAll = function(a) {
            for (a =
                a.iterator(); a.hasNext();) this.add(a.next());
            return !0
        };
        a.prototype.remove = function(a) {
            throw new n;
        };
        a.prototype.size = function() {
            return this.array.length
        };
        a.prototype.isEmpty = function() {
            return 0 === this.array.length
        };
        a.prototype.toArray = function() {
            for (var a = [], b = 0, c = this.array.length; b < c; b++) a.push(this.array[b]);
            return a
        };
        a.prototype.iterator = function() {
            return new a.Iterator(this)
        };
        a.Iterator = function(a) {
            this.treeSet = a
        };
        a.Iterator.prototype.treeSet = null;
        a.Iterator.prototype.position = 0;
        a.Iterator.prototype.next =
            function() {
                if (this.position === this.treeSet.size()) throw new p;
                return this.treeSet.array[this.position++]
            };
        a.Iterator.prototype.hasNext = function() {
            return this.position < this.treeSet.size() ? !0 : !1
        };
        a.Iterator.prototype.remove = function() {
            throw new javascript.util.OperationNotSupported;
        };
        c.exports = a
    });
    d.define("/javascript.util.js", function(b, c, d, m, h, g, k) {
        c = {
            util: {}
        };
        c.util.version = "0.10.0";
        c.util.ArrayList = b("./ArrayList");
        c.util.Arrays = b("./Arrays");
        c.util.Collection = b("./Collection");
        c.util.EmptyStackException =
            b("./EmptyStackException");
        c.util.HashMap = b("./HashMap");
        c.util.IndexOutOfBoundsException = b("./IndexOutOfBoundsException");
        c.util.Iterator = b("./Iterator");
        c.util.List = b("./List");
        c.util.Map = b("./Map");
        c.util.NoSuchElementException = b("./NoSuchElementException");
        c.util.OperationNotSupported = b("./OperationNotSupported");
        c.util.Set = b("./Set");
        c.util.HashSet = b("./HashSet");
        c.util.SortedMap = b("./SortedMap");
        c.util.SortedSet = b("./SortedSet");
        c.util.Stack = b("./Stack");
        c.util.TreeMap = b("./TreeMap");
        c.util.TreeSet =
            b("./TreeSet");
        this.javascript = c;
        var a;
        "undefined" != typeof window ? a = window : a = k;
        a.javascript = c
    });
    d("/javascript.util.js")
})();
/*

*/
! function(qa, wb) {
    "object" == typeof exports && "undefined" != typeof module ? wb(exports) : "function" == typeof define && define.amd ? define(["exports"], wb) : wb(qa.jsts = qa.jsts || {})
}(this, function(qa) {
    function wb() {}

    function K() {}

    function v() {}

    function Aa() {}

    function gd() {}

    function Wb() {}

    function Ba() {}

    function la(a) {
        this.name = "RuntimeException";
        this.message = a;
        this.stack = Error().stack;
        Error.call(this, a)
    }

    function oc() {
        0 === arguments.length ? la.call(this) : 1 === arguments.length && la.call(this, arguments[0])
    }

    function t() {}

    function k() {
        if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) k.call(this, 0, 0);
        else if (1 === arguments.length) {
            var a = arguments[0];
            k.call(this, a.x, a.y, a.z)
        } else if (2 === arguments.length) k.call(this, arguments[0], arguments[1], k.NULL_ORDINATE);
        else if (3 === arguments.length) {
            var a = arguments[1],
                b = arguments[2];
            this.x = arguments[0];
            this.y = a;
            this.z = b
        }
    }

    function Xb() {
        if (this.dimensionsToTest = 2, 0 === arguments.length) Xb.call(this, 2);
        else if (1 === arguments.length) {
            var a = arguments[0];
            if (2 !== a && 3 !== a) throw new K("only 2 or 3 dimensions may be specified");
            this.dimensionsToTest = a
        }
    }

    function hd() {}

    function T() {}

    function nf(a) {
        this.message = a || ""
    }

    function ga() {}

    function Ic(a) {
        this.message = a || ""
    }

    function id(a) {
        this.message = a || ""
    }

    function l(a) {
        this.array_ = [];
        a instanceof T && this.addAll(a)
    }

    function Z() {
        if (l.apply(this), 0 !== arguments.length)
            if (1 === arguments.length) {
                var a = arguments[0];
                this.ensureCapacity(a.length);
                this.add(a, !0)
            } else if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            this.ensureCapacity(a.length);
            this.add(a, b)
        }
    }

    function y() {
        if (this.minx =
            null, this.maxx = null, this.miny = null, this.maxy = null, 0 === arguments.length) this.init();
        else if (1 === arguments.length)
            if (arguments[0] instanceof k) {
                var a = arguments[0];
                this.init(a.x, a.x, a.y, a.y)
            } else arguments[0] instanceof y && this.init(arguments[0]);
        else if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            this.init(a.x, b.x, a.y, b.y)
        } else 4 === arguments.length && this.init(arguments[0], arguments[1], arguments[2], arguments[3])
    }

    function of () {}

    function xb() {}

    function h() {}

    function Oa() {}

    function Ya(a) {
        this.str =
            a
    }

    function db(a) {
        this.value = a
    }

    function jd() {}

    function m() {
        (this.hi = 0, this.lo = 0, 0 === arguments.length) ? this.init(0): 1 === arguments.length ? "number" == typeof arguments[0] ? this.init(arguments[0]) : arguments[0] instanceof m ? this.init(arguments[0]) : "string" == typeof arguments[0] && m.call(this, m.parse(arguments[0])) : 2 === arguments.length && this.init(arguments[0], arguments[1])
    }

    function Ga() {}

    function Q() {}

    function U() {}

    function Ha() {
        if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.y = this.x = 0, this.w =
            1;
        else if (1 === arguments.length) {
            var a = arguments[0];
            this.x = a.x;
            this.y = a.y;
            this.w = 1
        } else if (2 === arguments.length)
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) a = arguments[1], this.x = arguments[0], this.y = a, this.w = 1;
            else if (arguments[0] instanceof Ha && arguments[1] instanceof Ha) {
            var a = arguments[0],
                b = arguments[1];
            this.x = a.y * b.w - b.y * a.w;
            this.y = b.x * a.w - a.x * b.w;
            this.w = a.x * b.y - b.x * a.y
        } else arguments[0] instanceof k && arguments[1] instanceof k && (a = arguments[0], b = arguments[1], this.x = a.y - b.y, this.y =
            b.x - a.x, this.w = a.x * b.y - b.x * a.y);
        else if (3 === arguments.length) a = arguments[1], b = arguments[2], this.x = arguments[0], this.y = a, this.w = b;
        else if (4 === arguments.length) {
            var c = arguments[0],
                d = arguments[1],
                e = arguments[2],
                f = arguments[3],
                a = c.y - d.y,
                b = d.x - c.x,
                c = c.x * d.y - d.x * c.y,
                d = e.y - f.y,
                D = f.x - e.x,
                e = e.x * f.y - f.x * e.y;
            this.x = b * e - D * c;
            this.y = d * c - a * e;
            this.w = a * D - d * b
        }
    }

    function de() {}

    function eb() {}

    function r(a) {
        this.userData = this.SRID = this.factory = this.envelope = null;
        this.factory = a;
        this.SRID = a.getSRID()
    }

    function Yb() {}

    function ha() {}

    function ee() {}

    function fe() {}

    function ge() {}

    function he() {}

    function z() {}

    function pf() {}

    function qf() {}

    function pc() {}

    function gg() {}

    function ie() {}

    function ma(a) {
        this.array_ = [];
        a instanceof T && this.addAll(a)
    }

    function R(a) {
        return null == a ? null : a.parent
    }

    function yb(a, b) {
        null !== a && (a.color = b)
    }

    function rf(a) {
        return null == a ? null : a.left
    }

    function hg(a) {
        return null == a ? null : a.right
    }

    function ea() {
        this.root_ = null;
        this.size_ = 0
    }

    function kd() {}

    function ig() {}

    function va(a) {
        this.array_ = [];
        a instanceof T && this.addAll(a)
    }

    function zb() {}

    function n() {}

    function Ab() {}

    function qc() {}

    function F(a, b) {
        this.geometries = null;
        var c = a;
        if (r.call(this, b), null === c && (c = []), r.hasNullElements(c)) throw new K("geometries must not contain null elements");
        this.geometries = c
    }

    function wa(a, b) {
        F.call(this, a, b)
    }

    function Ob() {
        if (this.geom = null, this.geomFact = null, this.bnRule = null, this.endpointMap = null, 1 === arguments.length) Ob.call(this, arguments[0], ha.MOD2_BOUNDARY_RULE);
        else if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            this.geom =
                a;
            this.geomFact = a.getFactory();
            this.bnRule = b
        }
    }

    function sf() {
        this.count = null
    }

    function pg() {}

    function qg() {}

    function rg() {}

    function sg() {}

    function tg() {}

    function Pa() {}

    function da() {}

    function C(a, b) {
        this.points = null;
        r.call(this, b);
        this.init(a)
    }

    function je() {}

    function W(a, b) {
        this.coordinates = null;
        r.call(this, b);
        this.init(a)
    }

    function Bb() {}

    function O(a, b, c) {
        this.holes = this.shell = null;
        if (r.call(this, c), null === a && (a = this.getFactory().createLinearRing()), null === b && (b = []), r.hasNullElements(b)) throw new K("holes must not contain null elements");
        if (a.isEmpty() && r.hasNonEmptyElements(b)) throw new K("shell is empty but holes are not");
        this.shell = a;
        this.holes = b
    }

    function Ia(a, b) {
        F.call(this, a, b)
    }

    function aa(a, b) {
        a instanceof k && b instanceof E ? aa.call(this, b.getCoordinateSequenceFactory().create(a), b) : u(a, Q) && b instanceof E && (C.call(this, a, b), this.validateConstruction())
    }

    function na(a, b) {
        F.call(this, a, b)
    }

    function Qa() {
        (this.factory = null, this.isUserDataCopied = !1, 0 !== arguments.length) && 1 === arguments.length && (this.factory = arguments[0])
    }

    function ke() {}

    function tf() {}

    function uf() {}

    function vf() {}

    function Za() {
        if (this.dimension = 3, this.coordinates = null, 1 === arguments.length)
            if (arguments[0] instanceof Array) Za.call(this, arguments[0], 3);
            else if (Number.isInteger(arguments[0])) {
            var a = arguments[0];
            this.coordinates = Array(a).fill(null);
            for (var b = 0; b < a; b++) this.coordinates[b] = new k
        } else {
            if (u(arguments[0], Q)) {
                a = arguments[0];
                if (null === a) return this.coordinates = [].fill(null), null;
                this.dimension = a.getDimension();
                this.coordinates = Array(a.size()).fill(null);
                for (b =
                    0; b < this.coordinates.length; b++) this.coordinates[b] = a.getCoordinateCopy(b)
            }
        } else if (2 === arguments.length)
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) b = arguments[0], a = arguments[1], this.coordinates = b, this.dimension = a, null === b && (this.coordinates = [].fill(null));
            else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))
            for (a = arguments[0], b = arguments[1], this.coordinates = Array(a).fill(null), this.dimension = b, b = 0; b < a; b++) this.coordinates[b] = new k
    }

    function Pb() {}

    function ug(a,
        b) {
        return a === b || a !== a && b !== b
    }

    function vg(a) {
        this.add ? a.forEach(this.add, this) : a.forEach(function(a) {
            this.set(a[0], a[1])
        }, this)
    }

    function wf(a, b, c) {
        var d = [0],
            e = !1;
        return a.push(d), {
            next: function() {
                var f, D = d[0];
                return !e && D < b.length ? (f = c ? [b[D], c[D]] : b[D], d[0]++) : (e = !0, a.splice(a.indexOf(d), 1)), {
                    done: e,
                    value: f
                }
            }
        }
    }

    function wg() {
        return this._values.length
    }

    function Cb() {
        this.map_ = new xg
    }

    function L() {
        if (this.modelType = null, this.scale = null, 0 === arguments.length) this.modelType = L.FLOATING;
        else if (1 === arguments.length)
            if (arguments[0] instanceof mb) {
                var a = arguments[0];
                this.modelType = a;
                a === L.FIXED && this.setScale(1)
            } else "number" == typeof arguments[0] ? (a = arguments[0], this.modelType = L.FIXED, this.setScale(a)) : arguments[0] instanceof L && (a = arguments[0], this.modelType = a.modelType, this.scale = a.scale)
    }

    function mb(a) {
        this.name = null;
        this.name = a;
        mb.nameToTypeMap.put(a, this)
    }

    function E() {
        if (this.precisionModel = null, this.coordinateSequenceFactory = null, this.SRID = null, 0 === arguments.length) E.call(this, new L, 0);
        else if (1 === arguments.length)
            if (u(arguments[0],
                    de)) {
                var a = arguments[0];
                E.call(this, new L, 0, a)
            } else arguments[0] instanceof L && E.call(this, arguments[0], 0, E.getDefaultCoordinateSequenceFactory());
        else if (2 === arguments.length) E.call(this, arguments[0], arguments[1], E.getDefaultCoordinateSequenceFactory());
        else if (3 === arguments.length) {
            var a = arguments[1],
                b = arguments[2];
            this.precisionModel = arguments[0];
            this.coordinateSequenceFactory = b;
            this.SRID = a
        }
    }

    function xf(a) {
        this.geometryFactory = a || new E
    }

    function ra(a) {
        this.parser = new xf(a)
    }

    function P() {
        this.result =
            null;
        this.inputLines = Array(2).fill().map(function() {
            return Array(2)
        });
        this.intPt = Array(2).fill(null);
        this.precisionModel = this.pb = this.pa = this._isProper = this.intLineIndex = null;
        this.intPt[0] = new k;
        this.intPt[1] = new k;
        this.pa = this.intPt[0];
        this.pb = this.intPt[1];
        this.result = 0
    }

    function ia() {
        P.apply(this)
    }

    function rc() {}

    function sc(a) {
        this.p = null;
        this.crossingCount = 0;
        this.isPointOnSegment = !1;
        this.p = a
    }

    function q() {}

    function A() {
        if (this.p0 = null, this.p1 = null, 0 === arguments.length) A.call(this, new k, new k);
        else if (1 ===
            arguments.length) {
            var a = arguments[0];
            A.call(this, a.p0, a.p1)
        } else if (2 === arguments.length) a = arguments[1], this.p0 = arguments[0], this.p1 = a;
        else if (4 === arguments.length) {
            var a = arguments[2],
                b = arguments[3];
            A.call(this, new k(arguments[0], arguments[1]), new k(a, b))
        }
    }

    function N() {
        if (this.matrix = null, 0 === arguments.length) this.matrix = Array(3).fill().map(function() {
            return Array(3)
        }), this.setAll(n.FALSE);
        else if (1 === arguments.length)
            if ("string" == typeof arguments[0]) {
                var a = arguments[0];
                N.call(this);
                this.set(a)
            } else arguments[0] instanceof
        N && (a = arguments[0], N.call(this), this.matrix[h.INTERIOR][h.INTERIOR] = a.matrix[h.INTERIOR][h.INTERIOR], this.matrix[h.INTERIOR][h.BOUNDARY] = a.matrix[h.INTERIOR][h.BOUNDARY], this.matrix[h.INTERIOR][h.EXTERIOR] = a.matrix[h.INTERIOR][h.EXTERIOR], this.matrix[h.BOUNDARY][h.INTERIOR] = a.matrix[h.BOUNDARY][h.INTERIOR], this.matrix[h.BOUNDARY][h.BOUNDARY] = a.matrix[h.BOUNDARY][h.BOUNDARY], this.matrix[h.BOUNDARY][h.EXTERIOR] = a.matrix[h.BOUNDARY][h.EXTERIOR], this.matrix[h.EXTERIOR][h.INTERIOR] = a.matrix[h.EXTERIOR][h.INTERIOR],
            this.matrix[h.EXTERIOR][h.BOUNDARY] = a.matrix[h.EXTERIOR][h.BOUNDARY], this.matrix[h.EXTERIOR][h.EXTERIOR] = a.matrix[h.EXTERIOR][h.EXTERIOR])
    }

    function Db(a) {
        this.areaBasePt = null;
        this.triangleCent3 = new k;
        this.areasum2 = 0;
        this.cg3 = new k;
        this.lineCentSum = new k;
        this.ptCount = this.totalLength = 0;
        this.ptCentSum = new k;
        this.areaBasePt = null;
        this.add(a)
    }

    function le(a) {
        this.message = a || ""
    }

    function xa() {
        this.array_ = []
    }

    function Jc() {
        this.treeSet = new va;
        this.list = new l
    }

    function Eb() {
        if (this.geomFactory = null, this.inputPts =
            null, 1 === arguments.length) {
            var a = arguments[0];
            Eb.call(this, Eb.extractCoordinates(a), a.getFactory())
        } else 2 === arguments.length && (a = arguments[1], this.inputPts = Jc.filterCoordinates(arguments[0]), this.geomFactory = a)
    }

    function Kc(a) {
        this.origin = null;
        this.origin = a
    }

    function Ca() {
        this.factory = this.inputGeom = null;
        this.preserveGeometryCollectionType = this.pruneEmptyGeometry = !0;
        this.preserveType = this.preserveCollections = !1
    }

    function Lc(a, b) {
        (this.snapTolerance = 0, this.srcPts = null, this.seg = new A, this.allowSnappingToSourceVertices = !1, this._isClosed = !1, a instanceof C && "number" == typeof b) ? Lc.call(this, a.getCoordinates(), b): a instanceof Array && "number" == typeof b && (this.srcPts = a, this._isClosed = Lc.isClosed(a), this.snapTolerance = b)
    }

    function ya(a) {
        this.srcGeom = null;
        this.srcGeom = a
    }

    function ld() {
        if (Ca.apply(this), this.snapTolerance = null, this.snapPts = null, this.isSelfSnap = !1, 2 === arguments.length) {
            var a = arguments[1];
            this.snapTolerance = arguments[0];
            this.snapPts = a
        } else if (3 === arguments.length) {
            var a = arguments[1],
                b = arguments[2];
            this.snapTolerance =
                arguments[0];
            this.snapPts = a;
            this.isSelfSnap = b
        }
    }

    function Ra() {
        this.isFirst = !0;
        this.commonMantissaBitsCount = 53;
        this.commonBits = 0;
        this.commonSignExp = null
    }

    function md() {
        this.commonCoord = null;
        this.ccFilter = new me
    }

    function me() {
        this.commonBitsX = new Ra;
        this.commonBitsY = new Ra
    }

    function nd(a) {
        this.trans = null;
        this.trans = a
    }

    function tc(a) {
        this.subcollectionIterator = this.index = this.max = this.atStart = this.parent = null;
        this.parent = a;
        this.atStart = !0;
        this.index = 0;
        this.max = a.getNumGeometries()
    }

    function uc() {
        if ((this.boundaryRule =
                ha.OGC_SFS_BOUNDARY_RULE, this.isIn = null, this.numBoundaries = null, 0 !== arguments.length) && 1 === arguments.length) {
            var a = arguments[0];
            if (null === a) throw new K("Rule must be non-null");
            this.boundaryRule = a
        }
    }

    function Mc() {}

    function od() {}

    function yf(a, b) {
        this.data = this.pts = null;
        this.pts = a;
        this.data = b
    }

    function ne() {}

    function Fb(a, b) {
        this.item = this.bounds = null;
        this.bounds = a;
        this.item = b
    }

    function zf() {
        this.items = this._size = null;
        this._size = 0;
        this.items = new l;
        this.items.add(null)
    }

    function Zb() {}

    function oe() {}

    function za() {
        (this.childBoundables =
            new l, this.bounds = null, this.level = null, 0 !== arguments.length) && 1 === arguments.length && (this.level = arguments[0])
    }

    function Da(a, b, c) {
        this.itemDistance = this._distance = this.boundable2 = this.boundable1 = null;
        this.boundable1 = a;
        this.boundable2 = b;
        this.itemDistance = c;
        this._distance = this.distance()
    }

    function ba() {
        if (this.root = null, this.built = !1, this.itemBoundables = new l, this.nodeCapacity = null, 0 === arguments.length) ba.call(this, ba.DEFAULT_NODE_CAPACITY);
        else if (1 === arguments.length) {
            var a = arguments[0];
            t.isTrue(1 <
                a, "Node capacity must be greater than 1");
            this.nodeCapacity = a
        }
    }

    function pe() {}

    function X() {
        0 === arguments.length ? X.call(this, X.DEFAULT_NODE_CAPACITY) : 1 === arguments.length && ba.call(this, arguments[0])
    }

    function pd(a) {
        za.call(this, a)
    }

    function Ea() {}

    function Af(a, b, c, d) {
        this._isInterior = this.segmentOctant = this.segmentIndex = this.coord = this.segString = null;
        this.segString = a;
        this.coord = new k(b);
        this.segmentIndex = c;
        this.segmentOctant = d;
        this._isInterior = !b.equals2D(a.getCoordinate(c))
    }

    function Bf(a) {
        this.nodeMap =
            new ea;
        this.edge = null;
        this.edge = a
    }

    function jg(a) {
        this.nextNode = this.currNode = this.nodeIt = this.edge = this.nodeList = null;
        this.currSegIndex = 0;
        this.nodeList = a;
        this.edge = a.getEdge();
        this.nodeIt = a.iterator();
        this.readNextNode()
    }

    function Cf() {}

    function nb(a, b) {
        this.nodeList = new Bf(this);
        this.data = this.pts = null;
        this.pts = a;
        this.data = b
    }

    function qd() {
        this.tempEnv1 = new y;
        this.tempEnv2 = new y;
        this.overlapSeg1 = new A;
        this.overlapSeg2 = new A
    }

    function Df(a, b, c, d) {
        this.id = this.context = this.env = this.end = this.start = this.pts =
            null;
        this.pts = a;
        this.start = b;
        this.end = c;
        this.context = d
    }

    function H() {}

    function fb() {}

    function rd() {}

    function qe() {
        (this.segInt = null, 0 !== arguments.length) && 1 === arguments.length && this.setSegmentIntersector(arguments[0])
    }

    function $b() {
        (this.monoChains = new l, this.index = new X, this.idCounter = 0, this.nodedSegStrings = null, this.nOverlaps = 0, 0 !== arguments.length) && 1 === arguments.length && qe.call(this, arguments[0])
    }

    function sd(a) {
        qd.apply(this);
        this.si = null;
        this.si = a
    }

    function Ja() {
        if (this.pt = null, 1 === arguments.length) la.call(this,
            arguments[0]);
        else if (2 === arguments.length) {
            var a = arguments[1];
            la.call(this, Ja.msgWithCoord(arguments[0], a));
            this.name = "TopologyException";
            this.pt = new k(a)
        }
    }

    function td() {}

    function Qb(a) {
        this.isCheckEndSegmentsOnly = this.findAllIntersections = !1;
        this.intSegments = this.interiorIntersection = this.li = null;
        this.intersections = new l;
        this.intersectionCount = 0;
        this.keepIntersections = !0;
        this.li = a;
        this.interiorIntersection = null
    }

    function ud(a) {
        this.li = new ia;
        this.segStrings = null;
        this.findAllIntersections = !1;
        this.segInt =
            null;
        this._isValid = !0;
        this.segStrings = a
    }

    function vc(a) {
        this.nv = null;
        this.nv = new ud(vc.toSegmentStrings(a))
    }

    function Nc(a) {
        this.mapOp = null;
        this.mapOp = a
    }

    function p() {}

    function Ka() {
        if (this.location = null, 1 === arguments.length)
            if (arguments[0] instanceof Array) this.init(arguments[0].length);
            else if (Number.isInteger(arguments[0])) {
            var a = arguments[0];
            this.init(1);
            this.location[p.ON] = a
        } else {
            if (arguments[0] instanceof Ka && (a = arguments[0], this.init(a.location.length), null !== a))
                for (var b = 0; b < this.location.length; b++) this.location[b] =
                    a.location[b]
        } else if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            this.init(3);
            this.location[p.ON] = a;
            this.location[p.LEFT] = b;
            this.location[p.RIGHT] = c
        }
    }

    function ca() {
        if (this.elt = Array(2).fill(null), 1 === arguments.length)
            if (Number.isInteger(arguments[0])) {
                var a = arguments[0];
                this.elt[0] = new Ka(a);
                this.elt[1] = new Ka(a)
            } else arguments[0] instanceof ca && (a = arguments[0], this.elt[0] = new Ka(a.elt[0]), this.elt[1] = new Ka(a.elt[1]));
        else if (2 === arguments.length) {
            var a = arguments[0],
                b =
                arguments[1];
            this.elt[0] = new Ka(h.NONE);
            this.elt[1] = new Ka(h.NONE);
            this.elt[a].setLocation(b)
        } else if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            this.elt[0] = new Ka(a, b, c);
            this.elt[1] = new Ka(a, b, c)
        } else if (4 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2],
                d = arguments[3];
            this.elt[0] = new Ka(h.NONE, h.NONE, h.NONE);
            this.elt[1] = new Ka(h.NONE, h.NONE, h.NONE);
            this.elt[a].setLocations(b, c, d)
        }
    }

    function Oc(a, b) {
        this.startDe = null;
        this.maxNodeDegree = -1;
        this.edges =
            new l;
        this.pts = new l;
        this.label = new ca(h.NONE);
        this.shell = this._isHole = this.ring = null;
        this.holes = new l;
        this.geometryFactory = null;
        this.geometryFactory = b;
        this.computePoints(a);
        this.computeRing()
    }

    function re(a, b) {
        Oc.call(this, a, b)
    }

    function vd(a, b) {
        Oc.call(this, a, b)
    }

    function ac() {
        (this.label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 !== arguments.length) && 1 === arguments.length && (this.label = arguments[0])
    }

    function Gb(a, b) {
        ac.apply(this);
        this.edges = this.coord = null;
        this.coord = a;
        this.edges = b;
        this.label = new ca(0, h.NONE)
    }

    function Pc(a) {
        this.nodeMap = new ea;
        this.nodeFact = null;
        this.nodeFact = a
    }

    function ob() {
        if (this.edge = null, this.label = null, this.node = null, this.p0 = null, this.p1 = null, this.dx = null, this.dy = null, this.quadrant = null, 1 === arguments.length) this.edge = arguments[0];
        else if (3 === arguments.length) ob.call(this, arguments[0], arguments[1], arguments[2], null);
        else if (4 === arguments.length) {
            var a = arguments[1],
                b = arguments[2],
                c = arguments[3];
            ob.call(this, arguments[0]);
            this.init(a,
                b);
            this.label = c
        }
    }

    function wc(a, b) {
        this._isForward = null;
        this._isVisited = this._isInResult = !1;
        this.minEdgeRing = this.edgeRing = this.nextMin = this.next = this.sym = null;
        this.depth = [0, -999, -999];
        if (ob.call(this, a), this._isForward = b, b) this.init(a.getCoordinate(0), a.getCoordinate(1));
        else {
            var c = a.getNumPoints() - 1;
            this.init(a.getCoordinate(c), a.getCoordinate(c - 1))
        }
        this.computeDirectedLabel()
    }

    function xc() {}

    function pb() {
        (this.edges = new l, this.nodes = null, this.edgeEndList = new l, 0 === arguments.length) ? this.nodes = new Pc(new xc):
            1 === arguments.length && (this.nodes = new Pc(arguments[0]))
    }

    function se(a) {
        this.geometryFactory = null;
        this.shellList = new l;
        this.geometryFactory = a
    }

    function Ef(a, b, c) {
        this.ptLocator = this.geometryFactory = this.op = null;
        this.lineEdgesList = new l;
        this.resultLineList = new l;
        this.op = a;
        this.geometryFactory = b;
        this.ptLocator = c
    }

    function Ff(a, b, c) {
        this.geometryFactory = this.op = null;
        this.resultPointList = new l;
        c;
        this.op = a;
        this.geometryFactory = b
    }

    function te() {}

    function Sa(a) {
        this.geom = null;
        this.geom = a
    }

    function yc() {
        this.edgeMap =
            new ea;
        this.edgeList = null;
        this.ptInAreaLocation = [h.NONE, h.NONE]
    }

    function ue() {
        yc.apply(this);
        this.label = this.resultAreaEdgeList = null;
        this.SCANNING_FOR_INCOMING = 1;
        this.LINKING_TO_OUTGOING = 2
    }

    function Qc() {
        xc.apply(this)
    }

    function Gf(a, b) {
        this.chainIndex = this.mce = null;
        this.mce = a;
        this.chainIndex = b
    }

    function Hb() {
        if (this.label = null, this.xValue = null, this.eventType = null, this.insertEvent = null, this.deleteEventIndex = null, this.obj = null, 2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            this.eventType = Hb.DELETE;
            this.xValue = a;
            this.insertEvent = b
        } else if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            this.eventType = Hb.INSERT;
            this.label = a;
            this.xValue = b;
            this.obj = c
        }
    }

    function ve() {}

    function bc(a, b, c) {
        this.hasProperInterior = this.hasProper = this._hasIntersection = !1;
        this.isSelfIntersection = this.recordIsolated = this.includeProper = this.li = this.properIntersectionPoint = null;
        this.numTests = this.numIntersections = 0;
        this.bdyNodes = null;
        this.isDoneWhenProperInt = this._isDone = !1;
        this.li = a;
        this.includeProper =
            b;
        this.recordIsolated = c
    }

    function we() {
        ve.apply(this);
        this.events = new l;
        this.nOverlaps = null
    }

    function zc() {
        this.min = v.POSITIVE_INFINITY;
        this.max = v.NEGATIVE_INFINITY
    }

    function Hf() {}

    function xe(a, b, c) {
        zc.apply(this);
        this.item = null;
        this.min = a;
        this.max = b;
        this.item = c
    }

    function ye(a, b) {
        zc.apply(this);
        this.node2 = this.node1 = null;
        this.node1 = a;
        this.node2 = b;
        this.buildExtent(this.node1, this.node2)
    }

    function If() {
        this.leaves = new l;
        this.root = null;
        this.level = 0
    }

    function sa() {
        if (this.lines = null, this.isForcedToLineString = !1, 1 === arguments.length) this.lines = arguments[0];
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.lines = arguments[0];
            this.isForcedToLineString = a
        }
    }

    function ze() {
        this.items = new l
    }

    function wd(a) {
        this.index = null;
        if (!u(a, Bb)) throw new K("Argument must be Polygonal");
        this.index = new Ae(a)
    }

    function Be(a) {
        this.counter = null;
        this.counter = a
    }

    function Ae(a) {
        this.index = new If;
        this.init(a)
    }

    function Jf(a, b, c) {
        this.dist = this.segmentIndex = this.coord = null;
        this.coord = new k(a);
        this.segmentIndex = b;
        this.dist = c
    }

    function Kf(a) {
        this.nodeMap =
            new ea;
        this.edge = null;
        this.edge = a
    }

    function xd() {}

    function Lf(a) {
        this.startIndex = this.pts = this.e = null;
        this.env1 = new y;
        this.env2 = new y;
        this.e = a;
        this.pts = a.getCoordinates();
        this.startIndex = (new xd).getChainStartIndices(this.pts)
    }

    function gb() {
        this.depth = Array(2).fill().map(function() {
            return Array(3)
        });
        for (var a = 0; 2 > a; a++)
            for (var b = 0; 3 > b; b++) this.depth[a][b] = gb.NULL_VALUE
    }

    function $a() {
        if (ac.apply(this), this.pts = null, this.env = null, this.eiList = new Kf(this), this.name = null, this.mce = null, this._isIsolated = !0, this.depth = new gb, this.depthDelta = 0, 1 === arguments.length) $a.call(this, arguments[0], null);
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.pts = arguments[0];
            this.label = a
        }
    }

    function Fa() {
        if (pb.apply(this), this.parentGeom = null, this.lineEdgeMap = new Cb, this.boundaryNodeRule = null, this.useBoundaryDeterminationRule = !0, this.argIndex = null, this.boundaryNodes = null, this._hasTooFewPoints = !1, this.invalidPoint = null, this.areaPtLocator = null, this.ptLocator = new uc, 2 === arguments.length) Fa.call(this, arguments[0],
            arguments[1], ha.OGC_SFS_BOUNDARY_RULE);
        else if (3 === arguments.length) {
            var a = arguments[1],
                b = arguments[2];
            this.argIndex = arguments[0];
            this.parentGeom = a;
            this.boundaryNodeRule = b;
            null !== a && this.add(a)
        }
    }

    function cc() {
        if (this.li = new ia, this.resultPrecisionModel = null, this.arg = null, 1 === arguments.length) {
            var a = arguments[0];
            this.setComputationPrecision(a.getPrecisionModel());
            this.arg = Array(1).fill(null);
            this.arg[0] = new Fa(0, a)
        } else if (2 === arguments.length) cc.call(this, arguments[0], arguments[1], ha.OGC_SFS_BOUNDARY_RULE);
        else if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            0 <= a.getPrecisionModel().compareTo(b.getPrecisionModel()) ? this.setComputationPrecision(a.getPrecisionModel()) : this.setComputationPrecision(b.getPrecisionModel());
            this.arg = Array(2).fill(null);
            this.arg[0] = new Fa(0, a, c);
            this.arg[1] = new Fa(1, b, c)
        }
    }

    function dc(a) {
        this._orientation = this.pts = null;
        this.pts = a;
        this._orientation = dc.orientation(a)
    }

    function Ce() {
        this.edges = new l;
        this.ocaMap = new ea
    }

    function w(a, b) {
        this.ptLocator = new uc;
        this.graph = this.resultGeom = this.geomFact = null;
        this.edgeList = new Ce;
        this.resultPolyList = new l;
        this.resultLineList = new l;
        this.resultPointList = new l;
        cc.call(this, a, b);
        this.graph = new pb(new Qc);
        this.geomFact = a.getFactory()
    }

    function ab(a, b) {
        this.geom = Array(2).fill(null);
        this.cbr = this.snapTolerance = null;
        this.geom[0] = a;
        this.geom[1] = b;
        this.computeSnapTolerance()
    }

    function ja(a, b) {
        this.geom = Array(2).fill(null);
        this.geom[0] = a;
        this.geom[1] = b
    }

    function hb(a) {
        this.interiorPoint = this.factory = null;
        this.maxWidth = 0;
        this.factory = a.getFactory();
        this.add(a)
    }

    function Rc(a) {
        this.centreY = this.poly = null;
        this.hiY = v.MAX_VALUE;
        this.loY = -v.MAX_VALUE;
        this.poly = a;
        this.hiY = a.getEnvelopeInternal().getMaxY();
        this.loY = a.getEnvelopeInternal().getMinY();
        this.centreY = hb.avg(this.loY, this.hiY)
    }

    function De(a) {
        this.centroid = null;
        this.minDistance = v.MAX_VALUE;
        this.interiorPoint = null;
        this.centroid = a.getCentroid().getCoordinate();
        this.addInterior(a);
        null === this.interiorPoint && this.addEndpoints(a)
    }

    function Ee(a) {
        this.centroid = null;
        this.minDistance =
            v.MAX_VALUE;
        this.interiorPoint = null;
        this.centroid = a.getCentroid().getCoordinate();
        this.add(a)
    }

    function ec() {
        this.tempEnv1 = new y;
        this.selectedSegment = new A
    }

    function qb() {
        this.items = new l;
        this.subnode = [null, null]
    }

    function Ib() {
        if (this.min = null, this.max = null, 0 === arguments.length) this.max = this.min = 0;
        else if (1 === arguments.length) {
            var a = arguments[0];
            this.init(a.min, a.max)
        } else 2 === arguments.length && this.init(arguments[0], arguments[1])
    }

    function Ac() {}

    function yd(a) {
        this.level = this.pt = 0;
        this.interval = null;
        this.computeKey(a)
    }

    function Rb(a, b) {
        qb.apply(this);
        this.level = this.centre = this.interval = null;
        this.interval = a;
        this.level = b;
        this.centre = (a.getMin() + a.getMax()) / 2
    }

    function fc() {}

    function Sc() {
        qb.apply(this)
    }

    function Tc() {
        this.root = null;
        this.minExtent = 1;
        this.root = new Sc
    }

    function Mf() {}

    function zd(a) {
        this.tree = this.ring = null;
        this.crossings = 0;
        this.interval = new Ib;
        this.ring = a;
        this.buildIndex()
    }

    function Ad(a, b) {
        ec.apply(this);
        this.p = this.mcp = null;
        this.mcp = a;
        this.p = b
    }

    function B() {}

    function S(a, b, c) {
        this.p2 =
            this.p1 = this.p0 = null;
        this.p0 = a;
        this.p1 = b;
        this.p2 = c
    }

    function Sb(a) {
        this.centre = this.extremalPts = this.input = null;
        this.radius = 0;
        this.input = a
    }

    function ta() {
        if (this.inputGeom = null, this.isConvex = null, this.convexHullPts = null, this.minBaseSeg = new A, this.minWidthPt = null, this.minPtIndex = null, this.minWidth = 0, 1 === arguments.length) ta.call(this, arguments[0], !1);
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.inputGeom = arguments[0];
            this.isConvex = a
        }
    }

    function gc(a) {
        this.distanceTolerance = this.inputGeom = null;
        this.inputGeom = a
    }

    function Bd(a) {
        Ca.apply(this);
        this.distanceTolerance = null;
        this.distanceTolerance = a
    }

    function Jb(a) {
        this._next = this._sym = this._orig = null;
        this._orig = a
    }

    function La(a) {
        this._isMarked = !1;
        Jb.call(this, a)
    }

    function Uc() {
        this.vertexMap = new Cb
    }

    function Fe(a) {
        this._isStart = !1;
        La.call(this, a)
    }

    function Ge() {
        Uc.apply(this)
    }

    function Cd() {
        this.graph = this.factory = this.result = null;
        this.lines = new l;
        this.nodeEdgeStack = new xa;
        this.ringStartEdge = null;
        this.graph = new Ge
    }

    function rb() {
        this.items = new l;
        this.subnode =
            Array(4).fill(null)
    }

    function Dd(a) {
        this.pt = new k;
        this.level = 0;
        this.env = null;
        this.computeKey(a)
    }

    function Tb(a, b) {
        rb.apply(this);
        this.level = this.centrey = this.centrex = this.env = null;
        this.env = a;
        this.level = b;
        this.centrex = (a.getMinX() + a.getMaxX()) / 2;
        this.centrey = (a.getMinY() + a.getMaxY()) / 2
    }

    function Bc() {
        rb.apply(this)
    }

    function hc() {
        this.root = null;
        this.minExtent = 1;
        this.root = new Bc
    }

    function Nf(a) {
        this.geometryFactory = a || new E
    }

    function kg(a) {
        this.geometryFactory = a || new E;
        this.precisionModel = this.geometryFactory.getPrecisionModel();
        this.parser = new Nf(this.geometryFactory)
    }

    function lg() {
        this.parser = new Nf(this.geometryFactory)
    }

    function mg(a) {
        this.geometryFactory = a || new E;
        this.precisionModel = this.geometryFactory.getPrecisionModel();
        this.parser = new xf(this.geometryFactory)
    }

    function Ed(a) {
        return [a.x, a.y]
    }

    function ng(a, b) {
        this.geometryFactory = a || new E;
        this.ol = b || "undefined" != typeof ol && ol
    }

    function Fd() {
        if (this.noder = null, this.scaleFactor = null, this.offsetX = null, this.offsetY = null, this.isScaled = !1, 2 === arguments.length) Fd.call(this,
            arguments[0], arguments[1], 0, 0);
        else if (4 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            arguments[2];
            arguments[3];
            this.noder = a;
            this.scaleFactor = b;
            this.isScaled = !this.isIntegerPrecision()
        }
    }

    function Gd() {
        if (this.inputGeom = null, this.isClosedEndpointsInInterior = !0, this.nonSimpleLocation = null, 1 === arguments.length) this.inputGeom = arguments[0];
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.inputGeom = arguments[0];
            this.isClosedEndpointsInInterior = !a.isInBoundary(2)
        }
    }

    function He(a) {
        this.degree =
            this.isClosed = this.pt = null;
        this.pt = a;
        this.isClosed = !1;
        this.degree = 0
    }

    function I() {
        if (this.quadrantSegments = I.DEFAULT_QUADRANT_SEGMENTS, this.endCapStyle = I.CAP_ROUND, this.joinStyle = I.JOIN_ROUND, this.mitreLimit = I.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this.simplifyFactor = I.DEFAULT_SIMPLIFY_FACTOR, 0 !== arguments.length)
            if (1 === arguments.length) this.setQuadrantSegments(arguments[0]);
            else if (2 === arguments.length) {
            var a = arguments[1];
            this.setQuadrantSegments(arguments[0]);
            this.setEndCapStyle(a)
        } else if (4 ===
            arguments.length) {
            var a = arguments[1],
                b = arguments[2],
                c = arguments[3];
            this.setQuadrantSegments(arguments[0]);
            this.setEndCapStyle(a);
            this.setJoinStyle(b);
            this.setMitreLimit(c)
        }
    }

    function Of() {
        this.minIndex = -1;
        this.orientedDe = this.minDe = this.minCoord = null
    }

    function Ie() {
        this.array_ = []
    }

    function Pf() {
        this.finder = null;
        this.dirEdgeList = new l;
        this.nodes = new l;
        this.env = this.rightMostCoord = null;
        this.finder = new Of
    }

    function oa(a) {
        this.isDeleted = this.distanceTol = this.inputLine = null;
        this.angleOrientation = q.COUNTERCLOCKWISE;
        this.inputLine = a
    }

    function Hd() {
        this.precisionModel = this.ptList = null;
        this.minimimVertexDistance = 0;
        this.ptList = new l
    }

    function sb(a, b, c) {
        this.maxCurveSegmentError = 0;
        this.filletAngleQuantum = null;
        this.closingSegLengthFactor = 1;
        this.segList = null;
        this.distance = 0;
        this.s2 = this.s1 = this.s0 = this.li = this.bufParams = this.precisionModel = null;
        this.seg0 = new A;
        this.seg1 = new A;
        this.offset0 = new A;
        this.offset1 = new A;
        this.side = 0;
        this._hasNarrowConcaveAngle = !1;
        this.precisionModel = a;
        this.bufParams = b;
        this.li = new ia;
        this.filletAngleQuantum =
            Math.PI / 2 / b.getQuadrantSegments();
        8 <= b.getQuadrantSegments() && b.getJoinStyle() === I.JOIN_ROUND && (this.closingSegLengthFactor = sb.MAX_CLOSING_SEG_LEN_FACTOR);
        this.init(c)
    }

    function Id(a, b) {
        this.distance = 0;
        this.bufParams = this.precisionModel = null;
        this.precisionModel = a;
        this.bufParams = b
    }

    function Je(a) {
        this.subgraphs = null;
        this.seg = new A;
        this.cga = new q;
        this.subgraphs = a
    }

    function Ke(a, b) {
        this.leftDepth = this.upwardSeg = null;
        this.upwardSeg = new A(a);
        this.leftDepth = b
    }

    function Qf(a, b, c) {
        this.curveBuilder = this.distance =
            this.inputGeom = null;
        this.curveList = new l;
        this.inputGeom = a;
        this.distance = b;
        this.curveBuilder = c
    }

    function Jd(a) {
        this.hasInterior = this.hasProperInterior = this.hasProper = this._hasIntersection = !1;
        this.isSelfIntersection = this.li = this.properIntersectionPoint = null;
        this.numTests = this.numProperIntersections = this.numInteriorIntersections = this.numIntersections = 0;
        this.li = a
    }

    function ic(a) {
        this.graph = this.geomFact = this.workingNoder = this.workingPrecisionModel = this.bufParams = null;
        this.edgeList = new Ce;
        this.bufParams =
            a
    }

    function Kd(a) {
        this.li = new ia;
        this.segStrings = null;
        this.segStrings = a
    }

    function Vc(a, b, c) {
        this.maxy = this.miny = this.maxx = this.minx = this.scaleFactor = this.p1Scaled = this.p0Scaled = this.ptScaled = this.originalPt = this.pt = this.li = null;
        this.corner = Array(4).fill(null);
        this.safeEnv = null;
        if (this.originalPt = a, this.pt = a, this.scaleFactor = b, this.li = c, 0 >= b) throw new K("Scale factor must be non-zero");
        1 !== b && (this.pt = new k(this.scale(a.x), this.scale(a.y)), this.p0Scaled = new k, this.p1Scaled = new k);
        this.initCorners(this.pt)
    }

    function Le(a) {
        this.index = null;
        this.index = a
    }

    function Ld(a, b, c) {
        ec.apply(this);
        this.hotPixelVertexIndex = this.parentEdge = this.hotPixel = null;
        this._isNodeAdded = !1;
        this.hotPixel = a;
        this.parentEdge = b;
        this.hotPixelVertexIndex = c
    }

    function Rf(a) {
        this.interiorIntersections = this.li = null;
        this.li = a;
        this.interiorIntersections = new l
    }

    function Sf(a) {
        this.nodedSegStrings = this.pointSnapper = this.noder = this.scaleFactor = this.li = this.pm = null;
        this.pm = a;
        this.li = new ia;
        this.li.setPrecisionModel(a);
        this.scaleFactor = a.getScale()
    }

    function pa() {
        if (this.argGeom = null, this.distance = null, this.bufParams = new I, this.resultGeometry = null, this.saveException = null, 1 === arguments.length) this.argGeom = arguments[0];
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.argGeom = arguments[0];
            this.bufParams = a
        }
    }

    function Cc(a) {
        this.comps = null;
        this.comps = a
    }

    function Ma() {
        if (this.component = null, this.segIndex = null, this.pt = null, 2 === arguments.length) Ma.call(this, arguments[0], Ma.INSIDE_AREA, arguments[1]);
        else if (3 === arguments.length) {
            var a = arguments[1],
                b = arguments[2];
            this.component = arguments[0];
            this.segIndex = a;
            this.pt = b
        }
    }

    function Dc(a) {
        this.pts = null;
        this.pts = a
    }

    function Md(a) {
        this.locations = null;
        this.locations = a
    }

    function ib() {
        if (this.geom = null, this.terminateDistance = 0, this.ptLocator = new uc, this.minDistanceLocation = null, this.minDistance = v.MAX_VALUE, 2 === arguments.length) ib.call(this, arguments[0], arguments[1], 0);
        else if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            this.geom = Array(2).fill(null);
            this.geom[0] = a;
            this.geom[1] = b;
            this.terminateDistance = c
        }
    }

    function Tf(a) {
        this.factory = null;
        this.directedEdges = new l;
        this.coordinates = null;
        this.factory = a
    }

    function bb() {
        this._isVisited = this._isMarked = !1;
        this.data = null
    }

    function Ta(a, b, c, d) {
        bb.apply(this);
        this.angle = this.quadrant = this.edgeDirection = this.sym = this.p1 = this.p0 = this.to = this.from = this.parentEdge = null;
        this.from = a;
        this.to = b;
        this.edgeDirection = d;
        this.p0 = a.getCoordinate();
        this.p1 = c;
        a = this.p1.x - this.p0.x;
        b = this.p1.y - this.p0.y;
        this.quadrant = H.quadrant(a, b);
        this.angle = Math.atan2(b,
            a)
    }

    function Nd(a, b, c, d) {
        Ta.call(this, a, b, c, d)
    }

    function tb() {
        (bb.apply(this), this.dirEdge = null, 0 !== arguments.length) && 2 === arguments.length && this.setDirectedEdges(arguments[0], arguments[1])
    }

    function Uf() {
        this.outEdges = new l;
        this.sorted = !1
    }

    function Kb() {
        if (bb.apply(this), this.pt = null, this.deStar = null, 1 === arguments.length) Kb.call(this, arguments[0], new Uf);
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.pt = arguments[0];
            this.deStar = a
        }
    }

    function Me(a) {
        tb.apply(this);
        this.line = null;
        this.line = a
    }

    function Vf() {
        this.nodeMap =
            new ea
    }

    function Wc() {
        this.edges = new ma;
        this.dirEdges = new ma;
        this.nodeMap = new Vf
    }

    function Ne() {
        Wc.apply(this)
    }

    function Wf() {
        this.graph = new Ne;
        this.edgeStrings = this.factory = this.mergedLineStrings = null
    }

    function Od(a, b, c, d) {
        this.next = this.edgeRing = null;
        this.label = -1;
        Ta.call(this, a, b, c, d)
    }

    function Oe(a) {
        tb.apply(this);
        this.line = null;
        this.line = a
    }

    function Pd(a) {
        this.geometryFactory = new E;
        this.disconnectedRingcoord = this.geomGraph = null;
        this.geomGraph = a
    }

    function Pe() {}

    function Qd() {
        if (this.edgeEnds = new l, 1 ===
            arguments.length) Qd.call(this, null, arguments[0]);
        else if (2 === arguments.length) {
            var a = (arguments[0], arguments[1]);
            ob.call(this, a.getEdge(), a.getCoordinate(), a.getDirectedCoordinate(), new ca(a.getLabel()));
            this.insert(a)
        }
    }

    function Qe() {
        yc.apply(this)
    }

    function Re(a, b) {
        Gb.call(this, a, b)
    }

    function Rd() {
        xc.apply(this)
    }

    function Xf() {
        this.nodes = new Pc(new Rd)
    }

    function Se(a) {
        this.li = new ia;
        this.geomGraph = null;
        this.nodeGraph = new Xf;
        this.invalidPoint = null;
        this.geomGraph = a
    }

    function Yf(a) {
        this.graph = null;
        this.rings =
            new l;
        this.totalEnv = new y;
        this.nestedPt = this.index = null;
        this.graph = a
    }

    function G() {
        if (this.errorType = null, this.pt = null, 1 === arguments.length) G.call(this, arguments[0], null);
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.errorType = arguments[0];
            null !== a && (this.pt = a.copy())
        }
    }

    function Ua(a) {
        this.parentGeometry = null;
        this.isSelfTouchingRingFormingHoleValid = !1;
        this.validErr = null;
        this.parentGeometry = a
    }

    function jb(a) {
        this.factory = null;
        this.deList = new l;
        this._isHole = this.shell = this.holes = this.ringPts = this.ring =
            this.lowestEdge = null;
        this._isIncluded = this._isIncludedSet = this._isProcessed = !1;
        this.factory = a
    }

    function Zf() {}

    function fa(a) {
        Wc.apply(this);
        this.factory = null;
        this.factory = a
    }

    function Na() {
        (this.lineStringAdder = new Te(this), this.graph = null, this.dangles = new l, this.cutEdges = new l, this.invalidRingLines = new l, this.holeList = null, this.shellList = null, this.polyList = null, this.isCheckingRingsValid = !0, this.extractOnlyPolygonal = null, this.geomFactory = null, 0 === arguments.length) ? Na.call(this, !1): 1 === arguments.length &&
            (this.extractOnlyPolygonal = arguments[0])
    }

    function Te(a) {
        this.p = null;
        this.p = a
    }

    function Ue(a) {
        this.li = new ia;
        this.ptLocator = new uc;
        this.arg = null;
        this.nodes = new Pc(new Rd);
        this.im = null;
        this.isolatedEdges = new l;
        this.invalidPoint = null;
        this.arg = a
    }

    function Sd(a) {
        this.rectEnv = null;
        this.rectEnv = a.getEnvelopeInternal()
    }

    function $f(a) {
        this.li = new ia;
        this.diagDown1 = this.diagDown0 = this.diagUp1 = this.diagUp0 = this.rectEnv = null;
        this.rectEnv = a;
        this.diagUp0 = new k(a.getMinX(), a.getMinY());
        this.diagUp1 = new k(a.getMaxX(),
            a.getMaxY());
        this.diagDown0 = new k(a.getMinX(), a.getMaxY());
        this.diagDown1 = new k(a.getMaxX(), a.getMinY())
    }

    function jc() {
        this._isDone = !1
    }

    function Xc(a) {
        this.rectEnv = this.rectangle = null;
        this.rectangle = a;
        this.rectEnv = a.getEnvelopeInternal()
    }

    function Ve(a) {
        jc.apply(this);
        this.rectEnv = null;
        this._intersects = !1;
        this.rectEnv = a
    }

    function We(a) {
        jc.apply(this);
        this.rectEnv = this.rectSeq = null;
        this._containsPoint = !1;
        this.rectSeq = a.getExteriorRing().getCoordinateSequence();
        this.rectEnv = a.getEnvelopeInternal()
    }

    function Xe(a) {
        jc.apply(this);
        this.rectIntersector = this.rectEnv = null;
        this.hasIntersection = !1;
        this.p0 = new k;
        this.p1 = new k;
        this.rectEnv = a.getEnvelopeInternal();
        this.rectIntersector = new $f(this.rectEnv)
    }

    function J() {
        (this._relate = null, 2 === arguments.length) ? (cc.call(this, arguments[0], arguments[1]), this._relate = new Ue(this.arg)) : 3 === arguments.length && (cc.call(this, arguments[0], arguments[1], arguments[2]), this._relate = new Ue(this.arg))
    }

    function Va(a) {
        this.geomFactory = null;
        this.skipEmpty = !1;
        this.inputGeoms = null;
        this.geomFactory = Va.extractFactory(a);
        this.inputGeoms = a
    }

    function Td(a, b) {
        this.geomFact = this.otherGeom = this.pointGeom = null;
        this.pointGeom = a;
        this.otherGeom = b;
        this.geomFact = b.getFactory()
    }

    function kc(a, b) {
        this.sortIndex = -1;
        this.comps = null;
        this.sortIndex = a;
        this.comps = b
    }

    function cb(a) {
        this.geomFactory = this.inputPolys = null;
        this.inputPolys = a;
        null === this.inputPolys && (this.inputPolys = new l)
    }

    function lc() {
        if (this.polygons = new l, this.lines = new l, this.points = new l, this.geomFact = null, 1 === arguments.length) u(arguments[0], T) ? this.extract(arguments[0]) :
            arguments[0] instanceof r && this.extract(arguments[0]);
        else if (2 === arguments.length) {
            var a = arguments[0];
            this.geomFact = arguments[1];
            this.extract(a)
        }
    }

    function Ye(a, b) {
        Qa.CoordinateOperation.apply(this);
        this.targetPM = null;
        this.removeCollapsed = !0;
        this.targetPM = a;
        this.removeCollapsed = b
    }

    function Ec(a) {
        this.targetPM = null;
        this.removeCollapsed = !0;
        this.isPointwise = this.changePrecisionModel = !1;
        this.targetPM = a
    }

    function Ud(a) {
        this.distanceTolerance = this.usePt = this.pts = null;
        this.seg = new A;
        this.pts = a
    }

    function Yc(a) {
        this.distanceTolerance =
            this.inputGeom = null;
        this.isEnsureValidTopology = !0;
        this.inputGeom = a
    }

    function Vd(a, b) {
        Ca.apply(this);
        this.isEnsureValidTopology = !0;
        this.distanceTolerance = null;
        this.isEnsureValidTopology = a;
        this.distanceTolerance = b
    }

    function Wd() {
        if (this.parent = null, this.index = null, 2 === arguments.length) Wd.call(this, arguments[0], arguments[1], null, -1);
        else if (4 === arguments.length) {
            var a = arguments[2],
                b = arguments[3];
            A.call(this, arguments[0], arguments[1]);
            this.parent = a;
            this.index = b
        }
    }

    function Ub() {
        if (this.parentLine = null, this.segs =
            null, this.resultSegs = new l, this.minimumSize = null, 1 === arguments.length) Ub.call(this, arguments[0], 2);
        else if (2 === arguments.length) {
            var a = arguments[1];
            this.parentLine = arguments[0];
            this.minimumSize = a;
            this.init()
        }
    }

    function Zc() {
        this.index = new hc
    }

    function ag(a) {
        this.querySeg = null;
        this.items = new l;
        this.querySeg = a
    }

    function Xd(a, b) {
        this.li = new ia;
        this.inputIndex = new Zc;
        this.outputIndex = new Zc;
        this.linePts = this.line = null;
        this.distanceTolerance = 0;
        this.inputIndex = a;
        this.outputIndex = b
    }

    function bg() {
        this.inputIndex =
            new Zc;
        this.outputIndex = new Zc;
        this.distanceTolerance = 0
    }

    function Fc(a) {
        this.inputGeom = null;
        this.lineSimplifier = new bg;
        this.linestringMap = null;
        this.inputGeom = a
    }

    function Yd(a) {
        Ca.apply(this);
        this.linestringMap = null;
        this.linestringMap = a
    }

    function Ze(a) {
        this.tps = null;
        this.tps = a
    }

    function $c(a) {
        this.splitPt = this.segLen = this.seg = null;
        this.minimumLen = 0;
        this.seg = a;
        this.segLen = a.getLength()
    }

    function cg() {}

    function Zd() {}

    function V() {}

    function M() {
        (this.p = null, 1 === arguments.length) ? this.p = new k(arguments[0]):
            2 === arguments.length ? this.p = new k(arguments[0], arguments[1]) : 3 === arguments.length && (this.p = new k(arguments[0], arguments[1], arguments[2]))
    }

    function mc(a) {
        this.constraint = this._isOnConstraint = null;
        M.call(this, a)
    }

    function Y() {
        this.data = this.next = this.vertex = this._rot = null
    }

    function $d(a) {
        this.subdiv = null;
        this.isUsingTolerance = !1;
        this.subdiv = a;
        this.isUsingTolerance = 0 < a.getTolerance()
    }

    function dg() {}

    function $e(a) {
        this.lastEdge = this.subdiv = null;
        this.subdiv = a;
        this.init()
    }

    function ad() {
        if (this.seg = null, 1 ===
            arguments.length)
            if ("string" == typeof arguments[0]) la.call(this, arguments[0]);
            else {
                if (arguments[0] instanceof A) {
                    var a = arguments[0];
                    la.call(this, "Locate failed to converge (at edge: " + a + ").  Possible causes include invalid Subdivision topology or very close sites");
                    this.seg = new A(a)
                }
            }
        else 2 === arguments.length && (a = arguments[1], la.call(this, ad.msgWithSpatial(arguments[0], a)), this.seg = new A(a))
    }

    function bd() {}

    function Wa(a, b) {
        this.visitedKey = 0;
        this.quadEdges = new l;
        this.edgeCoincidenceTolerance = this.tolerance =
            this.startingEdge = null;
        this.frameVertex = Array(3).fill(null);
        this.locator = this.frameEnv = null;
        this.seg = new A;
        this.triEdges = Array(3).fill(null);
        this.tolerance = b;
        this.edgeCoincidenceTolerance = b / Wa.EDGE_COINCIDENCE_TOL_FACTOR;
        this.createFrame(a);
        this.startingEdge = this.initSubdiv();
        this.locator = new $e(this)
    }

    function af() {}

    function bf() {
        this.triList = new l
    }

    function cf() {
        this.triList = new l
    }

    function df() {
        this.coordList = new Z;
        this.triCoords = new l
    }

    function Gc() {
        if (this.ls = null, this.data = null, 2 === arguments.length) this.ls =
            new A(arguments[0], arguments[1]);
        else if (3 === arguments.length) {
            var a = arguments[2];
            this.ls = new A(arguments[0], arguments[1]);
            this.data = a
        } else if (6 === arguments.length) {
            var a = arguments[3],
                b = arguments[4],
                c = arguments[5];
            Gc.call(this, new k(arguments[0], arguments[1], arguments[2]), new k(a, b, c))
        } else if (7 === arguments.length) {
            var a = arguments[3],
                b = arguments[4],
                c = arguments[5],
                d = arguments[6];
            Gc.call(this, new k(arguments[0], arguments[1], arguments[2]), new k(a, b, c), d)
        }
    }

    function ae() {}

    function ef() {
        if (this.p = null,
            this.data = null, this.left = null, this.right = null, this.count = null, 2 === arguments.length) {
            var a = arguments[1];
            this.p = new k(arguments[0]);
            this.right = this.left = null;
            this.count = 1;
            this.data = a
        } else 3 === arguments.length && (a = arguments[2], this.p = new k(arguments[0], arguments[1]), this.right = this.left = null, this.count = 1, this.data = a)
    }

    function Hc() {
        (this.root = null, this.numberOfNodes = null, this.tolerance = null, 0 === arguments.length) ? Hc.call(this, 0): 1 === arguments.length && (this.tolerance = arguments[0])
    }

    function ff(a, b) {
        this.matchNode =
            this.tolerance = null;
        this.matchDist = 0;
        this.p = null;
        this.p = a;
        this.tolerance = b
    }

    function nc(a, b) {
        this.segVertices = this.initialVertices = null;
        this.segments = new l;
        this.convexHull = this.incDel = this.subdiv = null;
        this.splitFinder = new Zd;
        this.tolerance = this.splitPt = this.computeAreaEnv = this.vertexFactory = this.kdt = null;
        this.initialVertices = new l(a);
        this.tolerance = b;
        this.kdt = new Hc(b)
    }

    function ua() {
        this.siteCoords = null;
        this.tolerance = 0;
        this.subdiv = null
    }

    function cd() {
        this.constraintLines = this.siteCoords = null;
        this.tolerance =
            0;
        this.subdiv = null;
        this.constraintVertexMap = new ea
    }

    function be() {
        this.siteCoords = null;
        this.tolerance = 0;
        this.diagramEnv = this.clipEnv = this.subdiv = null
    }

    function ka() {
        if (this.componentIndex = 0, this.segmentIndex = 0, this.segmentFraction = 0, 0 !== arguments.length)
            if (1 === arguments.length) {
                var a = arguments[0];
                this.componentIndex = a.componentIndex;
                this.segmentIndex = a.segmentIndex;
                this.segmentFraction = a.segmentFraction
            } else if (2 === arguments.length) ka.call(this, 0, arguments[0], arguments[1]);
        else if (3 === arguments.length) {
            var a =
                arguments[1],
                b = arguments[2];
            this.componentIndex = arguments[0];
            this.segmentIndex = a;
            this.segmentFraction = b;
            this.normalize()
        } else if (4 === arguments.length) {
            var a = arguments[1],
                b = arguments[2],
                c = arguments[3];
            this.componentIndex = arguments[0];
            this.segmentIndex = a;
            this.segmentFraction = b;
            c && this.normalize()
        }
    }

    function kb() {
        if (this.linearGeom = null, this.numLines = null, this.currentLine = null, this.componentIndex = 0, this.vertexIndex = 0, 1 === arguments.length) kb.call(this, arguments[0], 0, 0);
        else if (2 === arguments.length) {
            var a =
                arguments[1];
            kb.call(this, arguments[0], a.getComponentIndex(), kb.segmentEndVertexIndex(a))
        } else if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            if (!u(a, kd)) throw new K("Lineal geometry is required");
            this.linearGeom = a;
            this.numLines = a.getNumGeometries();
            this.componentIndex = b;
            this.vertexIndex = c;
            this.loadCurrentLine()
        }
    }

    function Lb(a) {
        this.linearGeom = null;
        this.linearGeom = a
    }

    function dd(a) {
        this.linearGeom = null;
        this.linearGeom = a
    }

    function gf(a) {
        this.geomFact = null;
        this.lines = new l;
        this.coordList = null;
        this.fixInvalidLines = this.ignoreInvalidLines = !1;
        this.lastPt = null;
        this.geomFact = a
    }

    function ed(a) {
        this.line = null;
        this.line = a
    }

    function hf(a) {
        this.linearGeom = null;
        this.linearGeom = a;
        this.checkGeometryType()
    }

    function Vb(a) {
        this.linearGeom = null;
        this.linearGeom = a
    }

    function Xa(a) {
        this.linearGeom = null;
        this.linearGeom = a
    }

    function eg(a) {
        this.linearGeom = null;
        this.linearGeom = a
    }

    function jf() {}
    "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
        configurable: !0,
        value: function(a) {
            if (void 0 ===
                this || null === this) throw new TypeError(this + " is not an object");
            var b = Object(this),
                c = Math.max(Math.min(b.length, 9007199254740991), 0) || 0,
                d = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0,
                d = 0 > d ? Math.max(c + d, 0) : Math.min(d, c),
                e = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : c,
                e = 0 > e ? Math.max(c + arguments[2], 0) : Math.min(e, c);
            for (; d < e;) b[d] = a, ++d;
            return b
        },
        writable: !0
    });
    Number.isFinite = Number.isFinite || function(a) {
        return "number" == typeof a && isFinite(a)
    };
    Number.isInteger = Number.isInteger ||
        function(a) {
            return "number" == typeof a && isFinite(a) && Math.floor(a) === a
        };
    Number.parseFloat = Number.parseFloat || parseFloat;
    Number.isNaN = Number.isNaN || function(a) {
        return a !== a
    };
    Math.trunc = Math.trunc || function(a) {
        return 0 > a ? Math.ceil(a) : Math.floor(a)
    };
    var g = function(a, b) {
        for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c])
    };
    g(wb.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return wb
        }
    });
    wb.equalsWithTolerance = function(a, b, c) {
        return Math.abs(a - b) <= c
    };
    v.isNaN = function(a) {
        return Number.isNaN(a)
    };
    v.doubleToLongBits = function(a) {
        return a
    };
    v.longBitsToDouble = function(a) {
        return a
    };
    v.isInfinite = function(a) {
        return !Number.isFinite(a)
    };
    v.MAX_VALUE = Number.MAX_VALUE;
    la.prototype = Object.create(Error.prototype);
    la.prototype.constructor = Error;
    var x = function(a, b) {
        a.prototype = Object.create(b.prototype);
        a.prototype.constructor = a
    };
    x(oc, la);
    g(oc.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return oc
        }
    });
    g(t.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return t
        }
    });
    t.shouldNeverReachHere =
        function() {
            if (0 === arguments.length) t.shouldNeverReachHere(null);
            else if (1 === arguments.length) {
                var a = arguments[0];
                throw new oc("Should never reach here" + (null !== a ? ": " + a : ""));
            }
        };
    t.isTrue = function() {
        if (1 === arguments.length) t.isTrue(arguments[0], null);
        else if (2 === arguments.length) {
            var a = arguments[1];
            if (!arguments[0]) throw null === a ? new oc : new oc(a);
        }
    };
    t.equals = function() {
        if (2 === arguments.length) t.equals(arguments[0], arguments[1], null);
        else if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c =
                arguments[2];
            if (!b.equals(a)) throw new oc("Expected " + a + " but encountered " + b + (null !== c ? ": " + c : ""));
        }
    };
    g(k.prototype, {
        setOrdinate: function(a, b) {
            switch (a) {
                case k.X:
                    this.x = b;
                    break;
                case k.Y:
                    this.y = b;
                    break;
                case k.Z:
                    this.z = b;
                    break;
                default:
                    throw new K("Invalid ordinate index: " + a);
            }
        },
        equals2D: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                return this.x === a.x && this.y === a.y
            }
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return !!wb.equalsWithTolerance(this.x, a.x, b) && !!wb.equalsWithTolerance(this.y,
                    a.y, b)
            }
        },
        getOrdinate: function(a) {
            switch (a) {
                case k.X:
                    return this.x;
                case k.Y:
                    return this.y;
                case k.Z:
                    return this.z
            }
            throw new K("Invalid ordinate index: " + a);
        },
        equals3D: function(a) {
            return this.x === a.x && this.y === a.y && (this.z === a.z || v.isNaN(this.z) && v.isNaN(a.z))
        },
        equals: function(a) {
            return a instanceof k && this.equals2D(a)
        },
        equalInZ: function(a, b) {
            return wb.equalsWithTolerance(this.z, a.z, b)
        },
        compareTo: function(a) {
            return this.x < a.x ? -1 : this.x > a.x ? 1 : this.y < a.y ? -1 : this.y > a.y ? 1 : 0
        },
        clone: function() {
            return null
        },
        copy: function() {
            return new k(this)
        },
        toString: function() {
            return "(" + this.x + ", " + this.y + ", " + this.z + ")"
        },
        distance3D: function(a) {
            var b = this.x - a.x,
                c = this.y - a.y;
            a = this.z - a.z;
            return Math.sqrt(b * b + c * c + a * a)
        },
        distance: function(a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return Math.sqrt(b * b + a * a)
        },
        hashCode: function() {
            var a = 17;
            return a = 37 * a + k.hashCode(this.x), 37 * a + k.hashCode(this.y)
        },
        setCoordinate: function(a) {
            this.x = a.x;
            this.y = a.y;
            this.z = a.z
        },
        interfaces_: function() {
            return [Aa, gd, Ba]
        },
        getClass: function() {
            return k
        }
    });
    k.hashCode =
        function() {
            if (1 === arguments.length) {
                var a = v.doubleToLongBits(arguments[0]);
                return Math.trunc(a ^ a >>> 32)
            }
        };
    g(Xb.prototype, {
        compare: function(a, b) {
            var c = Xb.compare(a.x, b.x);
            if (0 !== c) return c;
            c = Xb.compare(a.y, b.y);
            return 0 !== c ? c : 2 >= this.dimensionsToTest ? 0 : Xb.compare(a.z, b.z)
        },
        interfaces_: function() {
            return [Wb]
        },
        getClass: function() {
            return Xb
        }
    });
    Xb.compare = function(a, b) {
        return a < b ? -1 : a > b ? 1 : v.isNaN(a) ? v.isNaN(b) ? 0 : -1 : v.isNaN(b) ? 1 : 0
    };
    k.DimensionalComparator = Xb;
    k.serialVersionUID = 0x5cbf2c235c7e5800;
    k.NULL_ORDINATE =
        v.NaN;
    k.X = 0;
    k.Y = 1;
    k.Z = 2;
    hd.prototype.hasNext = function() {};
    hd.prototype.next = function() {};
    hd.prototype.remove = function() {};
    T.prototype.add = function() {};
    T.prototype.addAll = function() {};
    T.prototype.isEmpty = function() {};
    T.prototype.iterator = function() {};
    T.prototype.size = function() {};
    T.prototype.toArray = function() {};
    T.prototype.remove = function() {};
    nf.prototype = Error();
    nf.prototype.name = "IndexOutOfBoundsException";
    ga.prototype = Object.create(T.prototype);
    ga.prototype.constructor = ga;
    ga.prototype.get = function() {};
    ga.prototype.set = function() {};
    ga.prototype.isEmpty = function() {};
    Ic.prototype = Error();
    Ic.prototype.name = "NoSuchElementException";
    id.prototype = Error();
    id.prototype.name = "OperationNotSupported";
    l.prototype = Object.create(ga.prototype);
    l.prototype.constructor = l;
    l.prototype.ensureCapacity = function() {};
    l.prototype.interfaces_ = function() {
        return [ga, T]
    };
    l.prototype.add = function(a) {
        return 1 === arguments.length ? this.array_.push(a) : this.array_.splice(arguments[0], arguments[1]), !0
    };
    l.prototype.clear = function() {
        this.array_ = []
    };
    l.prototype.addAll = function(a) {
        for (a = a.iterator(); a.hasNext();) this.add(a.next());
        return !0
    };
    l.prototype.set = function(a, b) {
        var c = this.array_[a];
        return this.array_[a] = b, c
    };
    l.prototype.iterator = function() {
        return new ce(this)
    };
    l.prototype.get = function(a) {
        if (0 > a || a >= this.size()) throw new nf;
        return this.array_[a]
    };
    l.prototype.isEmpty = function() {
        return 0 === this.array_.length
    };
    l.prototype.size = function() {
        return this.array_.length
    };
    l.prototype.toArray = function() {
        for (var a = [], b = 0, c = this.array_.length; b <
            c; b++) a.push(this.array_[b]);
        return a
    };
    l.prototype.remove = function(a) {
        for (var b = !1, c = 0, d = this.array_.length; c < d; c++)
            if (this.array_[c] === a) {
                this.array_.splice(c, 1);
                b = !0;
                break
            }
        return b
    };
    var ce = function(a) {
        this.arrayList_ = a;
        this.position_ = 0
    };
    ce.prototype.next = function() {
        if (this.position_ === this.arrayList_.size()) throw new Ic;
        return this.arrayList_.get(this.position_++)
    };
    ce.prototype.hasNext = function() {
        return this.position_ < this.arrayList_.size()
    };
    ce.prototype.set = function(a) {
        return this.arrayList_.set(this.position_ -
            1, a)
    };
    ce.prototype.remove = function() {
        this.arrayList_.remove(this.arrayList_.get(this.position_))
    };
    x(Z, l);
    g(Z.prototype, {
        getCoordinate: function(a) {
            return this.get(a)
        },
        addAll: function() {
            if (2 === arguments.length) {
                for (var a = arguments[1], b = !1, c = arguments[0].iterator(); c.hasNext();) this.add(c.next(), a), b = !0;
                return b
            }
            return l.prototype.addAll.apply(this, arguments)
        },
        clone: function() {
            for (var a = l.prototype.clone.call(this), b = 0; b < this.size(); b++) a.add(b, this.get(b).copy());
            return a
        },
        toCoordinateArray: function() {
            return this.toArray(Z.coordArrayType)
        },
        add: function() {
            if (1 === arguments.length) l.prototype.add.call(this, arguments[0]);
            else if (2 === arguments.length) {
                if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) return this.add(arguments[0], arguments[1], !0), !0;
                if (arguments[0] instanceof k && "boolean" == typeof arguments[1]) {
                    var a = arguments[0];
                    if (!arguments[1] && 1 <= this.size() && this.get(this.size() - 1).equals2D(a)) return null;
                    l.prototype.add.call(this, a)
                } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) return this.add(arguments[0],
                    arguments[1]), !0
            } else if (3 === arguments.length) {
                if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                    var b = arguments[0],
                        c = arguments[1];
                    if (arguments[2])
                        for (a = 0; a < b.length; a++) this.add(b[a], c);
                    else
                        for (a = b.length - 1; 0 <= a; a--) this.add(b[a], c);
                    return !0
                }
                if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof k) {
                    a = arguments[0];
                    b = arguments[1];
                    if (!arguments[2] && (c = this.size(), 0 < c && (0 < a && this.get(a - 1).equals2D(b) || a < c && this.get(a).equals2D(b)))) return null;
                    l.prototype.add.call(this, a, b)
                }
            } else if (4 === arguments.length) {
                var b = arguments[0],
                    c = arguments[1],
                    a = arguments[2],
                    d = arguments[3],
                    e = 1;
                for (a > d && (e = -1); a !== d; a += e) this.add(b[a], c);
                return !0
            }
        },
        closeRing: function() {
            0 < this.size() && this.add(new k(this.get(0)), !1)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Z
        }
    });
    Z.coordArrayType = [].fill(null);
    g(y.prototype, {
        getArea: function() {
            return this.getWidth() * this.getHeight()
        },
        equals: function(a) {
            return a instanceof y ? this.isNull() ? a.isNull() : this.maxx ===
                a.getMaxX() && this.maxy === a.getMaxY() && this.minx === a.getMinX() && this.miny === a.getMinY() : !1
        },
        intersection: function(a) {
            return this.isNull() || a.isNull() || !this.intersects(a) ? new y : new y(this.minx > a.minx ? this.minx : a.minx, this.maxx < a.maxx ? this.maxx : a.maxx, this.miny > a.miny ? this.miny : a.miny, this.maxy < a.maxy ? this.maxy : a.maxy)
        },
        isNull: function() {
            return this.maxx < this.minx
        },
        getMaxX: function() {
            return this.maxx
        },
        covers: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof k) {
                    var a = arguments[0];
                    return this.covers(a.x,
                        a.y)
                }
                if (arguments[0] instanceof y) return a = arguments[0], !this.isNull() && !a.isNull() && a.getMinX() >= this.minx && a.getMaxX() <= this.maxx && a.getMinY() >= this.miny && a.getMaxY() <= this.maxy
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return !this.isNull() && a >= this.minx && a <= this.maxx && b >= this.miny && b <= this.maxy
            }
        },
        intersects: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof y) {
                    var a = arguments[0];
                    return !this.isNull() && !a.isNull() && !(a.minx > this.maxx || a.maxx < this.minx || a.miny > this.maxy ||
                        a.maxy < this.miny)
                }
                if (arguments[0] instanceof k) return a = arguments[0], this.intersects(a.x, a.y)
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return !this.isNull() && !(a > this.maxx || a < this.minx || b > this.maxy || b < this.miny)
            }
        },
        getMinY: function() {
            return this.miny
        },
        getMinX: function() {
            return this.minx
        },
        expandToInclude: function() {
            if (1 === arguments.length)
                if (arguments[0] instanceof k) {
                    var a = arguments[0];
                    this.expandToInclude(a.x, a.y)
                } else {
                    if (arguments[0] instanceof y) {
                        a = arguments[0];
                        if (a.isNull()) return null;
                        this.isNull() ? (this.minx = a.getMinX(), this.maxx = a.getMaxX(), this.miny = a.getMinY(), this.maxy = a.getMaxY()) : (a.minx < this.minx && (this.minx = a.minx), a.maxx > this.maxx && (this.maxx = a.maxx), a.miny < this.miny && (this.miny = a.miny), a.maxy > this.maxy && (this.maxy = a.maxy))
                    }
                }
            else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                this.isNull() ? (this.minx = a, this.maxx = a, this.miny = b, this.maxy = b) : (a < this.minx && (this.minx = a), a > this.maxx && (this.maxx = a), b < this.miny && (this.miny = b), b > this.maxy && (this.maxy = b))
            }
        },
        minExtent: function() {
            if (this.isNull()) return 0;
            var a = this.getWidth(),
                b = this.getHeight();
            return a < b ? a : b
        },
        getWidth: function() {
            return this.isNull() ? 0 : this.maxx - this.minx
        },
        compareTo: function(a) {
            return this.isNull() ? a.isNull() ? 0 : -1 : a.isNull() ? 1 : this.minx < a.minx ? -1 : this.minx > a.minx ? 1 : this.miny < a.miny ? -1 : this.miny > a.miny ? 1 : this.maxx < a.maxx ? -1 : this.maxx > a.maxx ? 1 : this.maxy < a.maxy ? -1 : this.maxy > a.maxy ? 1 : 0
        },
        translate: function(a, b) {
            if (this.isNull()) return null;
            this.init(this.getMinX() + a, this.getMaxX() + a, this.getMinY() + b, this.getMaxY() + b)
        },
        toString: function() {
            return "Env[" +
                this.minx + " : " + this.maxx + ", " + this.miny + " : " + this.maxy + "]"
        },
        setToNull: function() {
            this.minx = 0;
            this.maxx = -1;
            this.miny = 0;
            this.maxy = -1
        },
        getHeight: function() {
            return this.isNull() ? 0 : this.maxy - this.miny
        },
        maxExtent: function() {
            if (this.isNull()) return 0;
            var a = this.getWidth(),
                b = this.getHeight();
            return a > b ? a : b
        },
        expandBy: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.expandBy(a, a)
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                if (this.isNull()) return null;
                this.minx -= a;
                this.maxx +=
                    a;
                this.miny -= b;
                this.maxy += b;
                (this.minx > this.maxx || this.miny > this.maxy) && this.setToNull()
            }
        },
        contains: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof y || arguments[0] instanceof k) return this.covers(arguments[0])
            } else if (2 === arguments.length) return this.covers(arguments[0], arguments[1])
        },
        centre: function() {
            return this.isNull() ? null : new k((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2)
        },
        init: function() {
            if (0 === arguments.length) this.setToNull();
            else if (1 === arguments.length)
                if (arguments[0] instanceof k) {
                    var a = arguments[0];
                    this.init(a.x, a.x, a.y, a.y)
                } else arguments[0] instanceof y && (a = arguments[0], this.minx = a.minx, this.maxx = a.maxx, this.miny = a.miny, this.maxy = a.maxy);
            else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                this.init(a.x, b.x, a.y, b.y)
            } else if (4 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = arguments[2],
                    d = arguments[3];
                a < b ? (this.minx = a, this.maxx = b) : (this.minx = b, this.maxx = a);
                c < d ? (this.miny = c, this.maxy = d) : (this.miny = d, this.maxy = c)
            }
        },
        getMaxY: function() {
            return this.maxy
        },
        distance: function(a) {
            if (this.intersects(a)) return 0;
            var b = 0;
            this.maxx < a.minx ? b = a.minx - this.maxx : this.minx > a.maxx && (b = this.minx - a.maxx);
            var c = 0;
            return this.maxy < a.miny ? c = a.miny - this.maxy : this.miny > a.maxy && (c = this.miny - a.maxy), 0 === b ? c : 0 === c ? b : Math.sqrt(b * b + c * c)
        },
        hashCode: function() {
            var a = 17;
            return a = 37 * a + k.hashCode(this.minx), a = 37 * a + k.hashCode(this.maxx), a = 37 * a + k.hashCode(this.miny), 37 * a + k.hashCode(this.maxy)
        },
        interfaces_: function() {
            return [Aa, Ba]
        },
        getClass: function() {
            return y
        }
    });
    y.intersects = function() {
        if (3 ===
            arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            return c.x >= (a.x < b.x ? a.x : b.x) && c.x <= (a.x > b.x ? a.x : b.x) && c.y >= (a.y < b.y ? a.y : b.y) && c.y <= (a.y > b.y ? a.y : b.y)
        }
        if (4 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2],
                d = arguments[3],
                e = Math.min(c.x, d.x),
                f = Math.max(c.x, d.x),
                D = Math.min(a.x, b.x),
                g = Math.max(a.x, b.x);
            return !(D > f) && !(g < e) && (e = Math.min(c.y, d.y), f = Math.max(c.y, d.y), D = Math.min(a.y, b.y), g = Math.max(a.y, b.y), !(D > f) && !(g < e))
        }
    };
    y.serialVersionUID = 0x51845cd552189800;
    x(xb, of );
    g(xb.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return xb
        }
    });
    g(h.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return h
        }
    });
    h.toLocationSymbol = function(a) {
        switch (a) {
            case h.EXTERIOR:
                return "e";
            case h.BOUNDARY:
                return "b";
            case h.INTERIOR:
                return "i";
            case h.NONE:
                return "-"
        }
        throw new K("Unknown location value: " + a);
    };
    h.INTERIOR = 0;
    h.BOUNDARY = 1;
    h.EXTERIOR = 2;
    h.NONE = -1;
    var u = function(a, b) {
        return a.interfaces_ && -1 < a.interfaces_().indexOf(b)
    };
    g(Oa.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Oa
        }
    });
    Oa.log10 = function(a) {
        a = Math.log(a);
        return v.isInfinite(a) ? a : v.isNaN(a) ? a : a / Oa.LOG_10
    };
    Oa.min = function(a, b, c, d) {
        return b < a && (a = b), c < a && (a = c), d < a && (a = d), a
    };
    Oa.clamp = function(a, b, c) {
        if ("number" == typeof c && "number" == typeof a && "number" == typeof b || Number.isInteger(c) && Number.isInteger(a) && Number.isInteger(b)) return a < b ? b : a > c ? c : a
    };
    Oa.wrap = function(a, b) {
        return 0 > a ? b - -a % b : a % b
    };
    Oa.max = function() {
        if (3 === arguments.length) {
            var a = arguments[1],
                b = arguments[2],
                c = arguments[0];
            return a >
                c && (c = a), b > c && (c = b), c
        }
        if (4 === arguments.length) {
            var a = arguments[1],
                b = arguments[2],
                d = arguments[3],
                c = arguments[0];
            return a > c && (c = a), b > c && (c = b), d > c && (c = d), c
        }
    };
    Oa.average = function(a, b) {
        return (a + b) / 2
    };
    Oa.LOG_10 = Math.log(10);
    Ya.prototype.append = function(a) {
        this.str += a
    };
    Ya.prototype.setCharAt = function(a, b) {
        this.str = this.str.substr(0, a) + b + this.str.substr(a + 1)
    };
    Ya.prototype.toString = function(a) {
        return this.str
    };
    db.prototype.intValue = function() {
        return this.value
    };
    db.prototype.compareTo = function(a) {
        return this.value <
            a ? -1 : this.value > a ? 1 : 0
    };
    db.isNaN = function(a) {
        return Number.isNaN(a)
    };
    jd.isWhitespace = function(a) {
        return 32 >= a && 0 <= a || 127 == a
    };
    jd.toUpperCase = function(a) {
        return a.toUpperCase()
    };
    g(m.prototype, {
        le: function(a) {
            return this.hi < a.hi || this.hi === a.hi && this.lo <= a.lo
        },
        extractSignificantDigits: function(a, b) {
            var c = this.abs(),
                d = m.magnitude(c.hi),
                e = m.TEN.pow(d),
                c = c.divide(e);
            c.gt(m.TEN) ? (c = c.divide(m.TEN), d += 1) : c.lt(m.ONE) && (c = c.multiply(m.TEN), --d);
            for (var e = d + 1, f = new Ya, D = m.MAX_PRINT_DIGITS - 1, g = 0; g <= D; g++) {
                a &&
                    g === e && f.append(".");
                var h = Math.trunc(c.hi);
                if (0 > h) break;
                var k = !1,
                    l = 0;
                9 < h ? (k = !0, l = "9") : l = "0" + h;
                f.append(l);
                c = c.subtract(m.valueOf(h)).multiply(m.TEN);
                k && c.selfAdd(m.TEN);
                h = !0;
                k = m.magnitude(c.hi);
                if (0 > k && Math.abs(k) >= D - g && (h = !1), !h) break
            }
            return b[0] = d, f.toString()
        },
        sqr: function() {
            return this.multiply(this)
        },
        doubleValue: function() {
            return this.hi + this.lo
        },
        subtract: function(a) {
            if (a instanceof m) return this.add(a.negate());
            if ("number" == typeof a) return this.add(-a)
        },
        equals: function() {
            if (1 === arguments.length) {
                var a =
                    arguments[0];
                return this.hi === a.hi && this.lo === a.lo
            }
        },
        isZero: function() {
            return 0 === this.hi && 0 === this.lo
        },
        selfSubtract: function(a) {
            if (a instanceof m) return this.isNaN() ? this : this.selfAdd(-a.hi, -a.lo);
            if ("number" == typeof a) return this.isNaN() ? this : this.selfAdd(-a, 0)
        },
        getSpecialNumberString: function() {
            return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null
        },
        min: function(a) {
            return this.le(a) ? this : a
        },
        selfDivide: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof m) {
                    var a = arguments[0];
                    return this.selfDivide(a.hi,
                        a.lo)
                }
                if ("number" == typeof arguments[0]) return this.selfDivide(arguments[0], 0)
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = null,
                    d = null,
                    e = null,
                    f = null,
                    D = null,
                    g = null,
                    h = null,
                    k = null;
                return D = this.hi / a, g = m.SPLIT * D, c = g - D, k = m.SPLIT * a, c = g - c, d = D - c, e = k - a, h = D * a, e = k - e, f = a - e, k = c * e - h + c * f + d * e + d * f, g = (this.hi - h - k + this.lo - D * b) / a, k = D + g, this.hi = k, this.lo = D - k + g, this
            }
        },
        dump: function() {
            return "DD\x3c" + this.hi + ", " + this.lo + "\x3e"
        },
        divide: function(a) {
            if (a instanceof m) {
                var b = null,
                    c = null,
                    d = null,
                    e = null,
                    f =
                    null,
                    D = b = null,
                    e = null,
                    f = this.hi / a.hi,
                    b = m.SPLIT * f,
                    e = m.SPLIT * a.hi,
                    b = b - (b - f),
                    c = f - b,
                    d = e - a.hi,
                    D = f * a.hi,
                    d = e - d,
                    e = a.hi - d,
                    e = b * d - D + b * e + c * d + c * e,
                    b = (this.hi - D - e + this.lo - f * a.lo) / a.hi,
                    e = f + b;
                return new m(e, f - e + b)
            }
            if ("number" == typeof a) return v.isNaN(a) ? m.createNaN() : m.copy(this).selfDivide(a, 0)
        },
        ge: function(a) {
            return this.hi > a.hi || this.hi === a.hi && this.lo >= a.lo
        },
        pow: function(a) {
            if (0 === a) return m.valueOf(1);
            var b = new m(this),
                c = m.valueOf(1),
                d = Math.abs(a);
            if (1 < d)
                for (; 0 < d;) 1 == d % 2 && c.selfMultiply(b), 0 < (d /= 2) && (b = b.sqr());
            else c = b;
            return 0 > a ? c.reciprocal() : c
        },
        ceil: function() {
            if (this.isNaN()) return m.NaN;
            var a = Math.ceil(this.hi),
                b = 0;
            return a === this.hi && (b = Math.ceil(this.lo)), new m(a, b)
        },
        compareTo: function(a) {
            return this.hi < a.hi ? -1 : this.hi > a.hi ? 1 : this.lo < a.lo ? -1 : this.lo > a.lo ? 1 : 0
        },
        rint: function() {
            return this.isNaN() ? this : this.add(.5).floor()
        },
        setValue: function(a) {
            if (a instanceof m || "number" == typeof a) return this.init(a), this
        },
        max: function(a) {
            return this.ge(a) ? this : a
        },
        sqrt: function() {
            if (this.isZero()) return m.valueOf(0);
            if (this.isNegative()) return m.NaN;
            var a = 1 / Math.sqrt(this.hi),
                b = m.valueOf(this.hi * a),
                a = .5 * this.subtract(b.sqr()).hi * a;
            return b.add(a)
        },
        selfAdd: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof m) {
                    var a = arguments[0];
                    return this.selfAdd(a.hi, a.lo)
                }
                if ("number" == typeof arguments[0]) {
                    var b = arguments[0],
                        c = null,
                        d = null,
                        e = null,
                        f = null,
                        D = a = null;
                    return e = this.hi + b, a = e - this.hi, f = e - a, f = b - a + (this.hi - f), D = f + this.lo, c = e + D, d = D + (e - c), this.hi = c + d, this.lo = d + (c - this.hi), this
                }
            } else if (2 === arguments.length) return f =
                arguments[0], c = arguments[1], D = b = null, e = this.hi + f, b = this.lo + c, a = e - this.hi, D = b - this.lo, f = f - a + (this.hi - (e - a)), D = c - D + (this.lo - (b - D)), a = f + b, c = e + a, a = D + (a + (e - c)), e = c + a, this.hi = e, this.lo = a + (c - e), this
        },
        selfMultiply: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof m) {
                    var a = arguments[0];
                    return this.selfMultiply(a.hi, a.lo)
                }
                if ("number" == typeof arguments[0]) return this.selfMultiply(arguments[0], 0)
            } else if (2 === arguments.length) {
                var b = arguments[0],
                    c = arguments[1],
                    d = null,
                    e = null,
                    f = null,
                    D = null,
                    f = a = null,
                    a = m.SPLIT * this.hi,
                    d = a - this.hi,
                    f = m.SPLIT * b,
                    d = a - d,
                    e = this.hi - d,
                    a = this.hi * b,
                    f = f - (f - b),
                    D = b - f,
                    f = d * f - a + d * D + e * f + e * D + (this.hi * c + this.lo * b),
                    b = a + f;
                return this.hi = b, this.lo = f + (a - b), this
            }
        },
        selfSqr: function() {
            return this.selfMultiply(this)
        },
        floor: function() {
            if (this.isNaN()) return m.NaN;
            var a = Math.floor(this.hi),
                b = 0;
            return a === this.hi && (b = Math.floor(this.lo)), new m(a, b)
        },
        negate: function() {
            return this.isNaN() ? this : new m(-this.hi, -this.lo)
        },
        clone: function() {
            return null
        },
        multiply: function(a) {
            if (a instanceof m) return a.isNaN() ?
                m.createNaN() : m.copy(this).selfMultiply(a);
            if ("number" == typeof a) return v.isNaN(a) ? m.createNaN() : m.copy(this).selfMultiply(a, 0)
        },
        isNaN: function() {
            return v.isNaN(this.hi)
        },
        intValue: function() {
            return Math.trunc(this.hi)
        },
        toString: function() {
            var a = m.magnitude(this.hi);
            return -3 <= a && 20 >= a ? this.toStandardNotation() : this.toSciNotation()
        },
        toStandardNotation: function() {
            var a = this.getSpecialNumberString();
            if (null !== a) return a;
            var b = Array(1).fill(null),
                a = this.extractSignificantDigits(!0, b),
                b = b[0] + 1,
                c = a;
            "." ===
            a.charAt(0) ? c = "0" + a : 0 > b ? c = "0." + m.stringOfChar("0", -b) + a : -1 === a.indexOf(".") && (b = m.stringOfChar("0", b - a.length), c = a + b + ".0");
            return this.isNegative() ? "-" + c : c
        },
        reciprocal: function() {
            var a = null,
                b = null,
                c = null,
                d = null,
                e = null,
                f = a = null,
                d = null,
                e = 1 / this.hi,
                a = m.SPLIT * e,
                d = m.SPLIT * this.hi,
                a = a - (a - e),
                b = e - a,
                c = d - this.hi,
                f = e * this.hi,
                c = d - c,
                d = this.hi - c,
                d = a * c - f + a * d + b * c + b * d,
                a = (1 - f - d - e * this.lo) / this.hi,
                b = e + a;
            return new m(b, e - b + a)
        },
        toSciNotation: function() {
            if (this.isZero()) return m.SCI_NOT_ZERO;
            var a = this.getSpecialNumberString();
            if (null !== a) return a;
            var b = Array(1).fill(null),
                a = this.extractSignificantDigits(!1, b),
                b = m.SCI_NOT_EXPONENT_CHAR + b[0];
            if ("0" === a.charAt(0)) throw new IllegalStateException("Found leading zero: " + a);
            var c = "";
            1 < a.length && (c = a.substring(1));
            a = a.charAt(0) + "." + c;
            return this.isNegative() ? "-" + a + b : a + b
        },
        abs: function() {
            return this.isNaN() ? m.NaN : this.isNegative() ? this.negate() : new m(this)
        },
        isPositive: function() {
            return 0 < this.hi || 0 === this.hi && 0 < this.lo
        },
        lt: function(a) {
            return this.hi < a.hi || this.hi === a.hi && this.lo <
                a.lo
        },
        add: function(a) {
            if (a instanceof m || "number" == typeof a) return m.copy(this).selfAdd(a)
        },
        init: function() {
            if (1 === arguments.length)
                if ("number" == typeof arguments[0]) this.hi = arguments[0], this.lo = 0;
                else {
                    if (arguments[0] instanceof m) {
                        var a = arguments[0];
                        this.hi = a.hi;
                        this.lo = a.lo
                    }
                }
            else 2 === arguments.length && (a = arguments[1], this.hi = arguments[0], this.lo = a)
        },
        gt: function(a) {
            return this.hi > a.hi || this.hi === a.hi && this.lo > a.lo
        },
        isNegative: function() {
            return 0 > this.hi || 0 === this.hi && 0 > this.lo
        },
        trunc: function() {
            return this.isNaN() ?
                m.NaN : this.isPositive() ? this.floor() : this.ceil()
        },
        signum: function() {
            return 0 < this.hi ? 1 : 0 > this.hi ? -1 : 0 < this.lo ? 1 : 0 > this.lo ? -1 : 0
        },
        interfaces_: function() {
            return [Ba, Aa, gd]
        },
        getClass: function() {
            return m
        }
    });
    m.sqr = function(a) {
        return m.valueOf(a).selfMultiply(a)
    };
    m.valueOf = function(a) {
        if ("string" == typeof a) return m.parse(a);
        if ("number" == typeof a) return new m(a)
    };
    m.sqrt = function(a) {
        return m.valueOf(a).sqrt()
    };
    m.parse = function(a) {
        for (var b = 0, c = a.length; jd.isWhitespace(a.charAt(b));) b++;
        var d = !1;
        if (b < c) {
            var e =
                a.charAt(b);
            "-" !== e && "+" !== e || (b++, "-" === e && (d = !0))
        }
        for (var e = new m, f = 0, D = 0, g = 0; !(b >= c);) {
            var h = a.charAt(b);
            if (b++, jd.isDigit(h)) h -= 0, e.selfMultiply(m.TEN), e.selfAdd(h), f++;
            else {
                if ("." !== h) {
                    if ("e" === h || "E" === h) {
                        b = a.substring(b);
                        try {
                            g = db.parseInt(b)
                        } catch (k) {
                            throw k instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + b + " in string " + a) : k;
                        }
                        break
                    }
                    throw new NumberFormatException("Unexpected character '" + h + "' at position " + b + " in string " + a);
                }
                D = f
            }
        }
        a = e;
        f = f - D - g;
        0 === f ? a = e : 0 < f ? (a =
            m.TEN.pow(f), a = e.divide(a)) : 0 > f && (a = m.TEN.pow(-f), a = e.multiply(a));
        return d ? a.negate() : a
    };
    m.createNaN = function() {
        return new m(v.NaN, v.NaN)
    };
    m.copy = function(a) {
        return new m(a)
    };
    m.magnitude = function(a) {
        a = Math.abs(a);
        var b = Math.trunc(Math.floor(Math.log(a) / Math.log(10)));
        return 10 * Math.pow(10, b) <= a && (b += 1), b
    };
    m.stringOfChar = function(a, b) {
        for (var c = new Ya, d = 0; d < b; d++) c.append(a);
        return c.toString()
    };
    m.PI = new m(3.141592653589793, 1.2246467991473532E-16);
    m.TWO_PI = new m(6.283185307179586, 2.4492935982947064E-16);
    m.PI_2 = new m(1.5707963267948966, 6.123233995736766E-17);
    m.E = new m(2.718281828459045, 1.4456468917292502E-16);
    m.NaN = new m(v.NaN, v.NaN);
    m.EPS = 1.23259516440783E-32;
    m.SPLIT = 134217729;
    m.MAX_PRINT_DIGITS = 32;
    m.TEN = m.valueOf(10);
    m.ONE = m.valueOf(1);
    m.SCI_NOT_EXPONENT_CHAR = "E";
    m.SCI_NOT_ZERO = "0.0E0";
    g(Ga.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ga
        }
    });
    Ga.orientationIndex = function(a, b, c) {
        var d = Ga.orientationIndexFilter(a, b, c);
        if (1 >= d) return d;
        d = m.valueOf(b.x).selfAdd(-a.x);
        a = m.valueOf(b.y).selfAdd(-a.y);
        var e = m.valueOf(c.x).selfAdd(-b.x);
        b = m.valueOf(c.y).selfAdd(-b.y);
        return d.selfMultiply(b).selfSubtract(a.selfMultiply(e)).signum()
    };
    Ga.signOfDet2x2 = function(a, b, c, d) {
        return a.multiply(d).selfSubtract(b.multiply(c)).signum()
    };
    Ga.intersection = function(a, b, c, d) {
        var e = m.valueOf(d.y).selfSubtract(c.y).selfMultiply(m.valueOf(b.x).selfSubtract(a.x)),
            f = m.valueOf(d.x).selfSubtract(c.x).selfMultiply(m.valueOf(b.y).selfSubtract(a.y)),
            e = e.subtract(f),
            f = m.valueOf(d.x).selfSubtract(c.x).selfMultiply(m.valueOf(a.y).selfSubtract(c.y)),
            g = m.valueOf(d.y).selfSubtract(c.y).selfMultiply(m.valueOf(a.x).selfSubtract(c.x)),
            f = f.subtract(g).selfDivide(e).doubleValue(),
            f = m.valueOf(a.x).selfAdd(m.valueOf(b.x).selfSubtract(a.x).selfMultiply(f)).doubleValue(),
            g = m.valueOf(b.x).selfSubtract(a.x).selfMultiply(m.valueOf(a.y).selfSubtract(c.y));
        a = m.valueOf(b.y).selfSubtract(a.y).selfMultiply(m.valueOf(a.x).selfSubtract(c.x));
        a = g.subtract(a).selfDivide(e).doubleValue();
        return new k(f, m.valueOf(c.y).selfAdd(m.valueOf(d.y).selfSubtract(c.y).selfMultiply(a)).doubleValue())
    };
    Ga.orientationIndexFilter = function(a, b, c) {
        var d = null,
            d = (a.x - c.x) * (b.y - c.y);
        b = (a.y - c.y) * (b.x - c.x);
        a = d - b;
        if (0 < d) {
            if (0 >= b) return Ga.signum(a);
            d += b
        } else {
            if (!(0 > d) || 0 <= b) return Ga.signum(a);
            d = -d - b
        }
        d *= Ga.DP_SAFE_EPSILON;
        return a >= d || -a >= d ? Ga.signum(a) : 2
    };
    Ga.signum = function(a) {
        return 0 < a ? 1 : 0 > a ? -1 : 0
    };
    Ga.DP_SAFE_EPSILON = 1E-15;
    g(Q.prototype, {
        setOrdinate: function(a, b, c) {},
        size: function() {},
        getOrdinate: function(a, b) {},
        getCoordinate: function() {
            1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0],
                arguments[1])
        },
        getCoordinateCopy: function(a) {},
        getDimension: function() {},
        getX: function(a) {},
        clone: function() {},
        expandEnvelope: function(a) {},
        copy: function() {},
        getY: function(a) {},
        toCoordinateArray: function() {},
        interfaces_: function() {
            return [gd]
        },
        getClass: function() {
            return Q
        }
    });
    Q.X = 0;
    Q.Y = 1;
    Q.Z = 2;
    Q.M = 3;
    U.arraycopy = function(a, b, c, d, e) {
        for (var f = 0, g = b; g < b + e; g++) c[d + f] = a[g], f++
    };
    U.getProperty = function(a) {
        return {
            "line.separator": "\n"
        }[a]
    };
    g(Ha.prototype, {
        getY: function() {
            var a = this.y / this.w;
            if (v.isNaN(a) ||
                v.isInfinite(a)) throw new xb;
            return a
        },
        getX: function() {
            var a = this.x / this.w;
            if (v.isNaN(a) || v.isInfinite(a)) throw new xb;
            return a
        },
        getCoordinate: function() {
            var a = new k;
            return a.x = this.getX(), a.y = this.getY(), a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ha
        }
    });
    Ha.intersection = function(a, b, c, d) {
        var e = a.y - b.y,
            f = b.x - a.x;
        a = a.x * b.y - b.x * a.y;
        b = c.y - d.y;
        var g = d.x - c.x;
        c = c.x * d.y - d.x * c.y;
        d = e * g - b * f;
        f = (f * c - g * a) / d;
        e = (b * a - e * c) / d;
        if (v.isNaN(f) || v.isInfinite(f) || v.isNaN(e) || v.isInfinite(e)) throw new xb;
        return new k(f, e)
    };
    g(de.prototype, {
        create: function() {
            1 === arguments.length ? arguments[0] instanceof Array ? arguments[0] : u(arguments[0], Q) && arguments[0] : 2 === arguments.length && (arguments[0], arguments[1])
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return de
        }
    });
    g(eb.prototype, {
        filter: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return eb
        }
    });
    g(r.prototype, {
        isGeometryCollection: function() {
            return this.getSortIndex() === r.SORTINDEX_GEOMETRYCOLLECTION
        },
        getFactory: function() {
            return this.factory
        },
        getGeometryN: function(a) {
            return this
        },
        getArea: function() {
            return 0
        },
        isRectangle: function() {
            return !1
        },
        equals: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof r) {
                    var a = arguments[0];
                    return null !== a && this.equalsTopo(a)
                }
                if (arguments[0] instanceof Object) return a = arguments[0], a instanceof r ? this.equalsExact(a) : !1
            }
        },
        equalsExact: function(a) {
            return this === a || this.equalsExact(a, 0)
        },
        geometryChanged: function() {
            this.apply(r.geometryChangedFilter)
        },
        geometryChangedAction: function() {
            this.envelope = null
        },
        equalsNorm: function(a) {
            return null !== a && this.norm().equalsExact(a.norm())
        },
        getLength: function() {
            return 0
        },
        getNumGeometries: function() {
            return 1
        },
        compareTo: function() {
            if (1 === arguments.length) {
                var a = arguments[0],
                    b = a;
                return this.getSortIndex() !== b.getSortIndex() ? this.getSortIndex() - b.getSortIndex() : this.isEmpty() && b.isEmpty() ? 0 : this.isEmpty() ? -1 : b.isEmpty() ? 1 : this.compareToSameClass(a)
            }
            if (2 === arguments.length) {
                var a = arguments[0],
                    c = arguments[1],
                    b = a;
                return this.getSortIndex() !== b.getSortIndex() ? this.getSortIndex() -
                    b.getSortIndex() : this.isEmpty() && b.isEmpty() ? 0 : this.isEmpty() ? -1 : b.isEmpty() ? 1 : this.compareToSameClass(a, c)
            }
        },
        getUserData: function() {
            return this.userData
        },
        getSRID: function() {
            return this.SRID
        },
        getEnvelope: function() {
            return this.getFactory().toGeometry(this.getEnvelopeInternal())
        },
        checkNotGeometryCollection: function(a) {
            if (a.getSortIndex() === r.SORTINDEX_GEOMETRYCOLLECTION) throw new K("This method does not support GeometryCollection arguments");
        },
        equal: function(a, b, c) {
            return 0 === c ? a.equals(b) : a.distance(b) <=
                c
        },
        norm: function() {
            var a = this.copy();
            return a.normalize(), a
        },
        getPrecisionModel: function() {
            return this.factory.getPrecisionModel()
        },
        getEnvelopeInternal: function() {
            return null === this.envelope && (this.envelope = this.computeEnvelopeInternal()), new y(this.envelope)
        },
        setSRID: function(a) {
            this.SRID = a
        },
        setUserData: function(a) {
            this.userData = a
        },
        compare: function(a, b) {
            for (var c = a.iterator(), d = b.iterator(); c.hasNext() && d.hasNext();) {
                var e = c.next(),
                    f = d.next(),
                    e = e.compareTo(f);
                if (0 !== e) return e
            }
            return c.hasNext() ?
                1 : d.hasNext() ? -1 : 0
        },
        hashCode: function() {
            return this.getEnvelopeInternal().hashCode()
        },
        isGeometryCollectionOrDerived: function() {
            return this.getSortIndex() === r.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === r.SORTINDEX_MULTIPOINT || this.getSortIndex() === r.SORTINDEX_MULTILINESTRING || this.getSortIndex() === r.SORTINDEX_MULTIPOLYGON
        },
        interfaces_: function() {
            return [gd, Aa, Ba]
        },
        getClass: function() {
            return r
        }
    });
    r.hasNonEmptyElements = function(a) {
        for (var b = 0; b < a.length; b++)
            if (!a[b].isEmpty()) return !0;
        return !1
    };
    r.hasNullElements = function(a) {
        for (var b = 0; b < a.length; b++)
            if (null === a[b]) return !0;
        return !1
    };
    r.serialVersionUID = 0x799ea46522854c00;
    r.SORTINDEX_POINT = 0;
    r.SORTINDEX_MULTIPOINT = 1;
    r.SORTINDEX_LINESTRING = 2;
    r.SORTINDEX_LINEARRING = 3;
    r.SORTINDEX_MULTILINESTRING = 4;
    r.SORTINDEX_POLYGON = 5;
    r.SORTINDEX_MULTIPOLYGON = 6;
    r.SORTINDEX_GEOMETRYCOLLECTION = 7;
    r.geometryChangedFilter = {
        interfaces_: function() {
            return [eb]
        },
        filter: function(a) {
            a.geometryChangedAction()
        }
    };
    g(Yb.prototype, {
        filter: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Yb
        }
    });
    g(ha.prototype, {
        isInBoundary: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ha
        }
    });
    g(ee.prototype, {
        isInBoundary: function(a) {
            return 1 == a % 2
        },
        interfaces_: function() {
            return [ha]
        },
        getClass: function() {
            return ee
        }
    });
    g(fe.prototype, {
        isInBoundary: function(a) {
            return 0 < a
        },
        interfaces_: function() {
            return [ha]
        },
        getClass: function() {
            return fe
        }
    });
    g(ge.prototype, {
        isInBoundary: function(a) {
            return 1 < a
        },
        interfaces_: function() {
            return [ha]
        },
        getClass: function() {
            return ge
        }
    });
    g(he.prototype, {
        isInBoundary: function(a) {
            return 1 === a
        },
        interfaces_: function() {
            return [ha]
        },
        getClass: function() {
            return he
        }
    });
    ha.Mod2BoundaryNodeRule = ee;
    ha.EndPointBoundaryNodeRule = fe;
    ha.MultiValentEndPointBoundaryNodeRule = ge;
    ha.MonoValentEndPointBoundaryNodeRule = he;
    ha.MOD2_BOUNDARY_RULE = new ee;
    ha.ENDPOINT_BOUNDARY_RULE = new fe;
    ha.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new ge;
    ha.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new he;
    ha.OGC_SFS_BOUNDARY_RULE = ha.MOD2_BOUNDARY_RULE;
    g(z.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return z
        }
    });
    z.isRing = function(a) {
        return !(4 > a.length) && !!a[0].equals2D(a[a.length - 1])
    };
    z.ptNotInList = function(a, b) {
        for (var c = 0; c < a.length; c++) {
            var d = a[c];
            if (0 > z.indexOf(d, b)) return d
        }
        return null
    };
    z.scroll = function(a, b) {
        var c = z.indexOf(b, a);
        if (0 > c) return null;
        var d = Array(a.length).fill(null);
        U.arraycopy(a, c, d, 0, a.length - c);
        U.arraycopy(a, 0, d, a.length - c, c);
        U.arraycopy(d, 0, a, 0, a.length)
    };
    z.equals = function() {
        if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            if (a === b) return !0;
            if (null === a || null === b || a.length !== b.length) return !1;
            for (var c = 0; c < a.length; c++)
                if (!a[c].equals(b[c])) return !1;
            return !0
        }
        if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                d = arguments[2];
            if (a === b) return !0;
            if (null === a || null === b || a.length !== b.length) return !1;
            for (c = 0; c < a.length; c++)
                if (0 !== d.compare(a[c], b[c])) return !1;
            return !0
        }
    };
    z.intersection = function(a, b) {
        for (var c = new Z, d = 0; d < a.length; d++) b.intersects(a[d]) && c.add(a[d], !0);
        return c.toCoordinateArray()
    };
    z.hasRepeatedPoints = function(a) {
        for (var b =
                1; b < a.length; b++)
            if (a[b - 1].equals(a[b])) return !0;
        return !1
    };
    z.removeRepeatedPoints = function(a) {
        return z.hasRepeatedPoints(a) ? (new Z(a, !1)).toCoordinateArray() : a
    };
    z.reverse = function(a) {
        for (var b = a.length - 1, c = Math.trunc(b / 2), d = 0; d <= c; d++) {
            var e = a[d];
            a[d] = a[b - d];
            a[b - d] = e
        }
    };
    z.removeNull = function(a) {
        for (var b = 0, c = 0; c < a.length; c++) null !== a[c] && b++;
        var d = Array(b).fill(null);
        if (0 === b) return d;
        for (c = b = 0; c < a.length; c++) null !== a[c] && (d[b++] = a[c]);
        return d
    };
    z.copyDeep = function() {
        if (1 === arguments.length) {
            for (var a =
                    arguments[0], b = Array(a.length).fill(null), c = 0; c < a.length; c++) b[c] = new k(a[c]);
            return b
        }
        if (5 === arguments.length)
            for (var a = arguments[0], b = arguments[1], d = arguments[2], e = arguments[3], f = arguments[4], c = 0; c < f; c++) d[e + c] = new k(a[b + c])
    };
    z.isEqualReversed = function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (0 !== a[c].compareTo(b[a.length - c - 1])) return !1;
        return !0
    };
    z.envelope = function(a) {
        for (var b = new y, c = 0; c < a.length; c++) b.expandToInclude(a[c]);
        return b
    };
    z.toCoordinateArray = function(a) {
        return a.toArray(z.coordArrayType)
    };
    z.atLeastNCoordinatesOrNothing = function(a, b) {
        return b.length >= a ? b : []
    };
    z.indexOf = function(a, b) {
        for (var c = 0; c < b.length; c++)
            if (a.equals(b[c])) return c;
        return -1
    };
    z.increasingDirection = function(a) {
        for (var b = 0; b < Math.trunc(a.length / 2); b++) {
            var c = a[b].compareTo(a[a.length - 1 - b]);
            if (0 !== c) return c
        }
        return 1
    };
    z.compare = function(a, b) {
        for (var c = 0; c < a.length && c < b.length;) {
            var d = a[c].compareTo(b[c]);
            if (0 !== d) return d;
            c++
        }
        return c < b.length ? -1 : c < a.length ? 1 : 0
    };
    z.minCoordinate = function(a) {
        for (var b = null, c = 0; c < a.length; c++)(null ===
            b || 0 < b.compareTo(a[c])) && (b = a[c]);
        return b
    };
    z.extract = function(a, b, c) {
        b = Oa.clamp(b, 0, a.length);
        c = Oa.clamp(c, -1, a.length);
        var d = c - b + 1;
        0 > c && (d = 0);
        b >= a.length && (d = 0);
        c < b && (d = 0);
        var e = Array(d).fill(null);
        if (0 === d) return e;
        for (d = 0; b <= c; b++) e[d++] = a[b];
        return e
    };
    g(pf.prototype, {
        compare: function(a, b) {
            return z.compare(a, b)
        },
        interfaces_: function() {
            return [Wb]
        },
        getClass: function() {
            return pf
        }
    });
    g(qf.prototype, {
        compare: function(a, b) {
            if (a.length < b.length) return -1;
            if (a.length > b.length) return 1;
            if (0 === a.length) return 0;
            var c = z.compare(a, b);
            return z.isEqualReversed(a, b) ? 0 : c
        },
        OLDcompare: function(a, b) {
            if (a.length < b.length) return -1;
            if (a.length > b.length) return 1;
            if (0 === a.length) return 0;
            for (var c = z.increasingDirection(a), d = z.increasingDirection(b), e = 0 < c ? 0 : a.length - 1, f = 0 < d ? 0 : a.length - 1, g = 0; g < a.length; g++) {
                var h = a[e].compareTo(b[f]);
                if (0 !== h) return h;
                e += c;
                f += d
            }
            return 0
        },
        interfaces_: function() {
            return [Wb]
        },
        getClass: function() {
            return qf
        }
    });
    z.ForwardComparator = pf;
    z.BidirectionalComparator = qf;
    z.coordArrayType = [].fill(null);
    pc.prototype.get = function() {};
    pc.prototype.put = function() {};
    pc.prototype.size = function() {};
    pc.prototype.values = function() {};
    pc.prototype.entrySet = function() {};
    gg.prototype = new pc;
    ie.prototype = new T;
    ie.prototype.contains = function() {};
    ma.prototype = new ie;
    ma.prototype.contains = function(a) {
        for (var b = 0, c = this.array_.length; b < c; b++)
            if (this.array_[b] === a) return !0;
        return !1
    };
    ma.prototype.add = function(a) {
        return !this.contains(a) && (this.array_.push(a), !0)
    };
    ma.prototype.addAll = function(a) {
        for (a = a.iterator(); a.hasNext();) this.add(a.next());
        return !0
    };
    ma.prototype.remove = function(a) {
        throw new javascript.util.OperationNotSupported;
    };
    ma.prototype.size = function() {
        return this.array_.length
    };
    ma.prototype.isEmpty = function() {
        return 0 === this.array_.length
    };
    ma.prototype.toArray = function() {
        for (var a = [], b = 0, c = this.array_.length; b < c; b++) a.push(this.array_[b]);
        return a
    };
    ma.prototype.iterator = function() {
        return new kf(this)
    };
    var kf = function(a) {
        this.hashSet_ = a;
        this.position_ = 0
    };
    kf.prototype.next = function() {
        if (this.position_ === this.hashSet_.size()) throw new Ic;
        return this.hashSet_.array_[this.position_++]
    };
    kf.prototype.hasNext = function() {
        return this.position_ < this.hashSet_.size()
    };
    kf.prototype.remove = function() {
        throw new id;
    };
    ea.prototype = new gg;
    ea.prototype.get = function(a) {
        for (var b = this.root_; null !== b;) {
            var c = a.compareTo(b.key);
            if (0 > c) b = b.left;
            else {
                if (!(0 < c)) return b.value;
                b = b.right
            }
        }
        return null
    };
    ea.prototype.put = function(a, b) {
        if (null === this.root_) return this.root_ = {
            key: a,
            value: b,
            left: null,
            right: null,
            parent: null,
            color: 0,
            getValue: function() {
                return this.value
            },
            getKey: function() {
                return this.key
            }
        }, this.size_ = 1, null;
        var c, d, e = this.root_;
        do
            if (c = e, 0 > (d = a.compareTo(e.key))) e = e.left;
            else {
                if (!(0 < d)) return c = e.value, e.value = b, c;
                e = e.right
            }
        while (null !== e);
        e = {
            key: a,
            left: null,
            right: null,
            value: b,
            parent: c,
            color: 0,
            getValue: function() {
                return this.value
            },
            getKey: function() {
                return this.key
            }
        };
        return 0 > d ? c.left = e : c.right = e, this.fixAfterInsertion(e), this.size_++, null
    };
    ea.prototype.fixAfterInsertion = function(a) {
        for (a.color = 1; null != a && a != this.root_ && 1 == a.parent.color;)
            if (R(a) ==
                rf(R(R(a)))) {
                var b = hg(R(R(a)));
                1 == (null == b ? 0 : b.color) ? (yb(R(a), 0), yb(b, 0), yb(R(R(a)), 1), a = R(R(a))) : (a == hg(R(a)) && (a = R(a), this.rotateLeft(a)), yb(R(a), 0), yb(R(R(a)), 1), this.rotateRight(R(R(a))))
            } else b = rf(R(R(a))), 1 == (null == b ? 0 : b.color) ? (yb(R(a), 0), yb(b, 0), yb(R(R(a)), 1), a = R(R(a))) : (a == rf(R(a)) && (a = R(a), this.rotateRight(a)), yb(R(a), 0), yb(R(R(a)), 1), this.rotateLeft(R(R(a))));
        this.root_.color = 0
    };
    ea.prototype.values = function() {
        var a = new l,
            b = this.getFirstEntry();
        if (null !== b)
            for (a.add(b.value); null !== (b =
                    ea.successor(b));) a.add(b.value);
        return a
    };
    ea.prototype.entrySet = function() {
        var a = new ma,
            b = this.getFirstEntry();
        if (null !== b)
            for (a.add(b); null !== (b = ea.successor(b));) a.add(b);
        return a
    };
    ea.prototype.rotateLeft = function(a) {
        if (null != a) {
            var b = a.right;
            a.right = b.left;
            null != b.left && (b.left.parent = a);
            b.parent = a.parent;
            null == a.parent ? this.root_ = b : a.parent.left == a ? a.parent.left = b : a.parent.right = b;
            b.left = a;
            a.parent = b
        }
    };
    ea.prototype.rotateRight = function(a) {
        if (null != a) {
            var b = a.left;
            a.left = b.right;
            null != b.right &&
                (b.right.parent = a);
            b.parent = a.parent;
            null == a.parent ? this.root_ = b : a.parent.right == a ? a.parent.right = b : a.parent.left = b;
            b.right = a;
            a.parent = b
        }
    };
    ea.prototype.getFirstEntry = function() {
        var a = this.root_;
        if (null != a)
            for (; null != a.left;) a = a.left;
        return a
    };
    ea.successor = function(a) {
        if (null === a) return null;
        if (null !== a.right) {
            for (var b = a.right; null !== b.left;) b = b.left;
            return b
        }
        for (b = a.parent; null !== b && a === b.right;) a = b, b = b.parent;
        return b
    };
    ea.prototype.size = function() {
        return this.size_
    };
    g(kd.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return kd
        }
    });
    ig.prototype = new ie;
    va.prototype = new ig;
    va.prototype.contains = function(a) {
        for (var b = 0, c = this.array_.length; b < c; b++)
            if (0 === this.array_[b].compareTo(a)) return !0;
        return !1
    };
    va.prototype.add = function(a) {
        if (this.contains(a)) return !1;
        for (var b = 0, c = this.array_.length; b < c; b++)
            if (1 === this.array_[b].compareTo(a)) return this.array_.splice(b, 0, a), !0;
        return this.array_.push(a), !0
    };
    va.prototype.addAll = function(a) {
        for (a = a.iterator(); a.hasNext();) this.add(a.next());
        return !0
    };
    va.prototype.remove =
        function(a) {
            throw new id;
        };
    va.prototype.size = function() {
        return this.array_.length
    };
    va.prototype.isEmpty = function() {
        return 0 === this.array_.length
    };
    va.prototype.toArray = function() {
        for (var a = [], b = 0, c = this.array_.length; b < c; b++) a.push(this.array_[b]);
        return a
    };
    va.prototype.iterator = function() {
        return new lf(this)
    };
    var lf = function(a) {
        this.treeSet_ = a;
        this.position_ = 0
    };
    lf.prototype.next = function() {
        if (this.position_ === this.treeSet_.size()) throw new Ic;
        return this.treeSet_.array_[this.position_++]
    };
    lf.prototype.hasNext =
        function() {
            return this.position_ < this.treeSet_.size()
        };
    lf.prototype.remove = function() {
        throw new id;
    };
    zb.sort = function() {
        var a, b, c, d = arguments[0];
        if (1 === arguments.length) return c = function(a, b) {
            return a.compareTo(b)
        }, void d.sort(c);
        if (2 === arguments.length) b = arguments[1], c = function(a, c) {
            return b.compare(a, c)
        }, d.sort(c);
        else if (3 === arguments.length)
            for (a = d.slice(arguments[1], arguments[2]), a.sort(), c = d.slice(0, arguments[1]).concat(a, d.slice(arguments[2], d.length)), d.splice(0, d.length), a = 0; a < c.length; a++) d.push(c[a]);
        else if (4 === arguments.length)
            for (a = d.slice(arguments[1], arguments[2]), b = arguments[3], c = function(a, c) {
                    return b.compare(a, c)
                }, a.sort(c), c = d.slice(0, arguments[1]).concat(a, d.slice(arguments[2], d.length)), d.splice(0, d.length), a = 0; a < c.length; a++) d.push(c[a])
    };
    zb.asList = function(a) {
        for (var b = new l, c = 0, d = a.length; c < d; c++) b.add(a[c]);
        return b
    };
    g(n.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return n
        }
    });
    n.toDimensionSymbol = function(a) {
        switch (a) {
            case n.FALSE:
                return n.SYM_FALSE;
            case n.TRUE:
                return n.SYM_TRUE;
            case n.DONTCARE:
                return n.SYM_DONTCARE;
            case n.P:
                return n.SYM_P;
            case n.L:
                return n.SYM_L;
            case n.A:
                return n.SYM_A
        }
        throw new K("Unknown dimension value: " + a);
    };
    n.toDimensionValue = function(a) {
        switch (jd.toUpperCase(a)) {
            case n.SYM_FALSE:
                return n.FALSE;
            case n.SYM_TRUE:
                return n.TRUE;
            case n.SYM_DONTCARE:
                return n.DONTCARE;
            case n.SYM_P:
                return n.P;
            case n.SYM_L:
                return n.L;
            case n.SYM_A:
                return n.A
        }
        throw new K("Unknown dimension symbol: " + a);
    };
    n.P = 0;
    n.L = 1;
    n.A = 2;
    n.FALSE = -1;
    n.TRUE = -2;
    n.DONTCARE = -3;
    n.SYM_FALSE = "F";
    n.SYM_TRUE =
        "T";
    n.SYM_DONTCARE = "*";
    n.SYM_P = "0";
    n.SYM_L = "1";
    n.SYM_A = "2";
    g(Ab.prototype, {
        filter: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ab
        }
    });
    g(qc.prototype, {
        filter: function(a, b) {},
        isDone: function() {},
        isGeometryChanged: function() {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return qc
        }
    });
    x(F, r);
    g(F.prototype, {
        computeEnvelopeInternal: function() {
            for (var a = new y, b = 0; b < this.geometries.length; b++) a.expandToInclude(this.geometries[b].getEnvelopeInternal());
            return a
        },
        getGeometryN: function(a) {
            return this.geometries[a]
        },
        getSortIndex: function() {
            return r.SORTINDEX_GEOMETRYCOLLECTION
        },
        getCoordinates: function() {
            for (var a = Array(this.getNumPoints()).fill(null), b = -1, c = 0; c < this.geometries.length; c++)
                for (var d = this.geometries[c].getCoordinates(), e = 0; e < d.length; e++) b++, a[b] = d[e];
            return a
        },
        getArea: function() {
            for (var a = 0, b = 0; b < this.geometries.length; b++) a += this.geometries[b].getArea();
            return a
        },
        equalsExact: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                if (!this.isEquivalentClass(a) || this.geometries.length !==
                    a.geometries.length) return !1;
                for (var c = 0; c < this.geometries.length; c++)
                    if (!this.geometries[c].equalsExact(a.geometries[c], b)) return !1;
                return !0
            }
            return r.prototype.equalsExact.apply(this, arguments)
        },
        normalize: function() {
            for (var a = 0; a < this.geometries.length; a++) this.geometries[a].normalize();
            zb.sort(this.geometries)
        },
        getCoordinate: function() {
            return this.isEmpty() ? null : this.geometries[0].getCoordinate()
        },
        getBoundaryDimension: function() {
            for (var a = n.FALSE, b = 0; b < this.geometries.length; b++) a = Math.max(a, this.geometries[b].getBoundaryDimension());
            return a
        },
        getDimension: function() {
            for (var a = n.FALSE, b = 0; b < this.geometries.length; b++) a = Math.max(a, this.geometries[b].getDimension());
            return a
        },
        getLength: function() {
            for (var a = 0, b = 0; b < this.geometries.length; b++) a += this.geometries[b].getLength();
            return a
        },
        getNumPoints: function() {
            for (var a = 0, b = 0; b < this.geometries.length; b++) a += this.geometries[b].getNumPoints();
            return a
        },
        getNumGeometries: function() {
            return this.geometries.length
        },
        reverse: function() {
            for (var a = Array(this.geometries.length).fill(null), b = 0; b <
                this.geometries.length; b++) a[b] = this.geometries[b].reverse();
            return this.getFactory().createGeometryCollection(a)
        },
        compareToSameClass: function() {
            if (1 === arguments.length) {
                var a = arguments[0],
                    b = new va(zb.asList(this.geometries)),
                    a = new va(zb.asList(a.geometries));
                return this.compare(b, a)
            }
            if (2 === arguments.length) {
                for (var b = arguments[1], a = arguments[0], c = this.getNumGeometries(), d = a.getNumGeometries(), e = 0; e < c && e < d;) {
                    var f = this.getGeometryN(e),
                        g = a.getGeometryN(e),
                        f = f.compareToSameClass(g, b);
                    if (0 !== f) return f;
                    e++
                }
                return e < c ? 1 : e < d ? -1 : 0
            }
        },
        apply: function(a) {
            if (u(a, Yb))
                for (var b = 0; b < this.geometries.length; b++) this.geometries[b].apply(a);
            else if (u(a, qc)) {
                if (0 === this.geometries.length) return null;
                for (b = 0; b < this.geometries.length && (this.geometries[b].apply(a), !a.isDone()); b++);
                a.isGeometryChanged() && this.geometryChanged()
            } else if (u(a, Ab))
                for (a.filter(this), b = 0; b < this.geometries.length; b++) this.geometries[b].apply(a);
            else if (u(a, eb))
                for (a.filter(this), b = 0; b < this.geometries.length; b++) this.geometries[b].apply(a)
        },
        getBoundary: function() {
            return this.checkNotGeometryCollection(this), t.shouldNeverReachHere(), null
        },
        clone: function() {
            var a = r.prototype.clone.call(this);
            a.geometries = Array(this.geometries.length).fill(null);
            for (var b = 0; b < this.geometries.length; b++) a.geometries[b] = this.geometries[b].clone();
            return a
        },
        getGeometryType: function() {
            return "GeometryCollection"
        },
        copy: function() {
            for (var a = Array(this.geometries.length).fill(null), b = 0; b < a.length; b++) a[b] = this.geometries[b].copy();
            return new F(a, this.factory)
        },
        isEmpty: function() {
            for (var a = 0; a < this.geometries.length; a++)
                if (!this.geometries[a].isEmpty()) return !1;
            return !0
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return F
        }
    });
    F.serialVersionUID = -0x4f07bcb1f857d800;
    x(wa, F);
    g(wa.prototype, {
        getSortIndex: function() {
            return r.SORTINDEX_MULTILINESTRING
        },
        equalsExact: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return !!this.isEquivalentClass(a) && F.prototype.equalsExact.call(this, a, b)
            }
            return F.prototype.equalsExact.apply(this, arguments)
        },
        getBoundaryDimension: function() {
            return this.isClosed() ? n.FALSE : 0
        },
        isClosed: function() {
            if (this.isEmpty()) return !1;
            for (var a = 0; a < this.geometries.length; a++)
                if (!this.geometries[a].isClosed()) return !1;
            return !0
        },
        getDimension: function() {
            return 1
        },
        reverse: function() {
            for (var a = this.geometries.length, b = Array(a).fill(null), c = 0; c < this.geometries.length; c++) b[a - 1 - c] = this.geometries[c].reverse();
            return this.getFactory().createMultiLineString(b)
        },
        getBoundary: function() {
            return (new Ob(this)).getBoundary()
        },
        getGeometryType: function() {
            return "MultiLineString"
        },
        copy: function() {
            for (var a = Array(this.geometries.length).fill(null), b = 0; b < a.length; b++) a[b] = this.geometries[b].copy();
            return new wa(a, this.factory)
        },
        interfaces_: function() {
            return [kd]
        },
        getClass: function() {
            return wa
        }
    });
    wa.serialVersionUID = 0x7155d2ab4afa8000;
    g(Ob.prototype, {
        boundaryMultiLineString: function(a) {
            if (this.geom.isEmpty()) return this.getEmptyMultiPoint();
            a = this.computeBoundaryCoordinates(a);
            return 1 === a.length ? this.geomFact.createPoint(a[0]) : this.geomFact.createMultiPointFromCoords(a)
        },
        getBoundary: function() {
            return this.geom instanceof
            C ? this.boundaryLineString(this.geom) : this.geom instanceof wa ? this.boundaryMultiLineString(this.geom) : this.geom.getBoundary()
        },
        boundaryLineString: function(a) {
            return this.geom.isEmpty() ? this.getEmptyMultiPoint() : a.isClosed() ? this.bnRule.isInBoundary(2) ? a.getStartPoint() : this.geomFact.createMultiPoint() : this.geomFact.createMultiPoint([a.getStartPoint(), a.getEndPoint()])
        },
        getEmptyMultiPoint: function() {
            return this.geomFact.createMultiPoint()
        },
        computeBoundaryCoordinates: function(a) {
            var b = new l;
            this.endpointMap =
                new ea;
            for (var c = 0; c < a.getNumGeometries(); c++) {
                var d = a.getGeometryN(c);
                0 !== d.getNumPoints() && (this.addEndpoint(d.getCoordinateN(0)), this.addEndpoint(d.getCoordinateN(d.getNumPoints() - 1)))
            }
            for (a = this.endpointMap.entrySet().iterator(); a.hasNext();) c = a.next(), d = c.getValue().count, this.bnRule.isInBoundary(d) && b.add(c.getKey());
            return z.toCoordinateArray(b)
        },
        addEndpoint: function(a) {
            var b = this.endpointMap.get(a);
            null === b && (b = new sf, this.endpointMap.put(a, b));
            b.count++
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ob
        }
    });
    Ob.getBoundary = function() {
        if (1 === arguments.length) {
            var a = new Ob(arguments[0]);
            return a.getBoundary()
        }
        if (2 === arguments.length) return a = new Ob(arguments[0], arguments[1]), a.getBoundary()
    };
    g(sf.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return sf
        }
    });
    g(Pa.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Pa
        }
    });
    Pa.chars = function(a, b) {
        for (var c = Array(b).fill(null), d = 0; d < b; d++) c[d] = a;
        return new String(c)
    };
    Pa.getStackTrace = function() {
        if (1 ===
            arguments.length) {
            var a = arguments[0],
                b = new rg,
                c = new pg(b);
            return a.printStackTrace(c), b.toString()
        }
        if (2 === arguments.length) {
            for (var a = arguments[1], b = "", c = new qg(Pa.getStackTrace(arguments[0])), c = new tg(c), d = 0; d < a; d++) try {
                b += c.readLine() + Pa.NEWLINE
            } catch (e) {
                if (!(e instanceof sg)) throw e;
                t.shouldNeverReachHere()
            }
            return b
        }
    };
    Pa.split = function(a, b) {
        for (var c = b.length, d = new l, e = "" + a, f = e.indexOf(b); 0 <= f;) {
            var g = e.substring(0, f);
            d.add(g);
            e = e.substring(f + c);
            f = e.indexOf(b)
        }
        0 < e.length && d.add(e);
        c = Array(d.size()).fill(null);
        for (e = 0; e < c.length; e++) c[e] = d.get(e);
        return c
    };
    Pa.toString = function() {
        if (1 === arguments.length) return Pa.SIMPLE_ORDINATE_FORMAT.format(arguments[0])
    };
    Pa.spaces = function(a) {
        return Pa.chars(" ", a)
    };
    Pa.NEWLINE = U.getProperty("line.separator");
    Pa.SIMPLE_ORDINATE_FORMAT = new function() {}("0.#");
    g(da.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return da
        }
    });
    da.copyCoord = function(a, b, c, d) {
        for (var e = Math.min(a.getDimension(), c.getDimension()), f = 0; f < e; f++) c.setOrdinate(d, f, a.getOrdinate(b,
            f))
    };
    da.isRing = function(a) {
        var b = a.size();
        return 0 === b || !(3 >= b) && a.getOrdinate(0, Q.X) === a.getOrdinate(b - 1, Q.X) && a.getOrdinate(0, Q.Y) === a.getOrdinate(b - 1, Q.Y)
    };
    da.isEqual = function(a, b) {
        var c = a.size();
        if (c !== b.size()) return !1;
        for (var d = Math.min(a.getDimension(), b.getDimension()), e = 0; e < c; e++)
            for (var f = 0; f < d; f++) {
                var g = a.getOrdinate(e, f),
                    h = b.getOrdinate(e, f);
                if (!(a.getOrdinate(e, f) === b.getOrdinate(e, f) || v.isNaN(g) && v.isNaN(h))) return !1
            }
        return !0
    };
    da.extend = function(a, b, c) {
        a = a.create(c, b.getDimension());
        var d = b.size();
        if (da.copy(b, 0, a, 0, d), 0 < d)
            for (var e = d; e < c; e++) da.copy(b, d - 1, a, e, 1);
        return a
    };
    da.reverse = function(a) {
        for (var b = a.size() - 1, c = Math.trunc(b / 2), d = 0; d <= c; d++) da.swap(a, d, b - d)
    };
    da.swap = function(a, b, c) {
        if (b === c) return null;
        for (var d = 0; d < a.getDimension(); d++) {
            var e = a.getOrdinate(b, d);
            a.setOrdinate(b, d, a.getOrdinate(c, d));
            a.setOrdinate(c, d, e)
        }
    };
    da.copy = function(a, b, c, d, e) {
        for (var f = 0; f < e; f++) da.copyCoord(a, b + f, c, d + f)
    };
    da.toString = function() {
        if (1 === arguments.length) {
            var a = arguments[0],
                b = a.size();
            if (0 === b) return "()";
            var c = a.getDimension(),
                d = new Ya;
            d.append("(");
            for (var e = 0; e < b; e++) {
                0 < e && d.append(" ");
                for (var f = 0; f < c; f++) 0 < f && d.append(","), d.append(Pa.toString(a.getOrdinate(e, f)))
            }
            return d.append(")"), d.toString()
        }
    };
    da.ensureValidRing = function(a, b) {
        var c = b.size();
        return 0 === c ? b : 3 >= c ? da.createClosedRing(a, b, 4) : b.getOrdinate(0, Q.X) === b.getOrdinate(c - 1, Q.X) && b.getOrdinate(0, Q.Y) === b.getOrdinate(c - 1, Q.Y) ? b : da.createClosedRing(a, b, c + 1)
    };
    da.createClosedRing = function(a, b, c) {
        a = a.create(c, b.getDimension());
        var d = b.size();
        for (da.copy(b, 0, a, 0, d); d < c; d++) da.copy(b, 0, a, d, 1);
        return a
    };
    x(C, r);
    g(C.prototype, {
        computeEnvelopeInternal: function() {
            return this.isEmpty() ? new y : this.points.expandEnvelope(new y)
        },
        isRing: function() {
            return this.isClosed() && this.isSimple()
        },
        getSortIndex: function() {
            return r.SORTINDEX_LINESTRING
        },
        getCoordinates: function() {
            return this.points.toCoordinateArray()
        },
        equalsExact: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                if (!this.isEquivalentClass(a) || this.points.size() !==
                    a.points.size()) return !1;
                for (var c = 0; c < this.points.size(); c++)
                    if (!this.equal(this.points.getCoordinate(c), a.points.getCoordinate(c), b)) return !1;
                return !0
            }
            return r.prototype.equalsExact.apply(this, arguments)
        },
        normalize: function() {
            for (var a = 0; a < Math.trunc(this.points.size() / 2); a++) {
                var b = this.points.size() - 1 - a;
                if (!this.points.getCoordinate(a).equals(this.points.getCoordinate(b))) return 0 < this.points.getCoordinate(a).compareTo(this.points.getCoordinate(b)) && da.reverse(this.points), null
            }
        },
        getCoordinate: function() {
            return this.isEmpty() ?
                null : this.points.getCoordinate(0)
        },
        getBoundaryDimension: function() {
            return this.isClosed() ? n.FALSE : 0
        },
        isClosed: function() {
            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))
        },
        getEndPoint: function() {
            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1)
        },
        getDimension: function() {
            return 1
        },
        getLength: function() {
            return q.computeLength(this.points)
        },
        getNumPoints: function() {
            return this.points.size()
        },
        reverse: function() {
            var a = this.points.copy();
            return da.reverse(a),
                this.getFactory().createLineString(a)
        },
        compareToSameClass: function() {
            if (1 === arguments.length) {
                for (var a = arguments[0], b = 0, c = 0; b < this.points.size() && c < a.points.size();) {
                    var d = this.points.getCoordinate(b).compareTo(a.points.getCoordinate(c));
                    if (0 !== d) return d;
                    b++;
                    c++
                }
                return b < this.points.size() ? 1 : c < a.points.size() ? -1 : 0
            }
            if (2 === arguments.length) return arguments[1].compare(this.points, arguments[0].points)
        },
        apply: function(a) {
            if (u(a, Yb))
                for (var b = 0; b < this.points.size(); b++) a.filter(this.points.getCoordinate(b));
            else if (u(a, qc)) {
                if (0 === this.points.size()) return null;
                for (b = 0; b < this.points.size() && (a.filter(this.points, b), !a.isDone()); b++);
                a.isGeometryChanged() && this.geometryChanged()
            } else u(a, Ab) ? a.filter(this) : u(a, eb) && a.filter(this)
        },
        getBoundary: function() {
            return (new Ob(this)).getBoundary()
        },
        isEquivalentClass: function(a) {
            return a instanceof C
        },
        clone: function() {
            var a = r.prototype.clone.call(this);
            return a.points = this.points.clone(), a
        },
        getCoordinateN: function(a) {
            return this.points.getCoordinate(a)
        },
        getGeometryType: function() {
            return "LineString"
        },
        copy: function() {
            return new C(this.points.copy(), this.factory)
        },
        getCoordinateSequence: function() {
            return this.points
        },
        isEmpty: function() {
            return 0 === this.points.size()
        },
        init: function(a) {
            if (null === a && (a = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === a.size()) throw new K("Invalid number of points in LineString (found " + a.size() + " - must be 0 or \x3e\x3d 2)");
            this.points = a
        },
        isCoordinate: function(a) {
            for (var b = 0; b < this.points.size(); b++)
                if (this.points.getCoordinate(b).equals(a)) return !0;
            return !1
        },
        getStartPoint: function() {
            return this.isEmpty() ? null : this.getPointN(0)
        },
        getPointN: function(a) {
            return this.getFactory().createPoint(this.points.getCoordinate(a))
        },
        interfaces_: function() {
            return [kd]
        },
        getClass: function() {
            return C
        }
    });
    C.serialVersionUID = 0x2b2b51ba435c8e00;
    g(je.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return je
        }
    });
    x(W, r);
    g(W.prototype, {
        computeEnvelopeInternal: function() {
            if (this.isEmpty()) return new y;
            var a = new y;
            return a.expandToInclude(this.coordinates.getX(0),
                this.coordinates.getY(0)), a
        },
        getSortIndex: function() {
            return r.SORTINDEX_POINT
        },
        getCoordinates: function() {
            return this.isEmpty() ? [] : [this.getCoordinate()]
        },
        equalsExact: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return !!this.isEquivalentClass(a) && (!(!this.isEmpty() || !a.isEmpty()) || this.isEmpty() === a.isEmpty() && this.equal(a.getCoordinate(), this.getCoordinate(), b))
            }
            return r.prototype.equalsExact.apply(this, arguments)
        },
        normalize: function() {},
        getCoordinate: function() {
            return 0 !==
                this.coordinates.size() ? this.coordinates.getCoordinate(0) : null
        },
        getBoundaryDimension: function() {
            return n.FALSE
        },
        getDimension: function() {
            return 0
        },
        getNumPoints: function() {
            return this.isEmpty() ? 0 : 1
        },
        reverse: function() {
            return this.copy()
        },
        getX: function() {
            if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point");
            return this.getCoordinate().x
        },
        compareToSameClass: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                return this.getCoordinate().compareTo(a.getCoordinate())
            }
            if (2 ===
                arguments.length) return arguments[1].compare(this.coordinates, arguments[0].coordinates)
        },
        apply: function(a) {
            if (u(a, Yb)) {
                if (this.isEmpty()) return null;
                a.filter(this.getCoordinate())
            } else if (u(a, qc)) {
                if (this.isEmpty()) return null;
                a.filter(this.coordinates, 0);
                a.isGeometryChanged() && this.geometryChanged()
            } else u(a, Ab) ? a.filter(this) : u(a, eb) && a.filter(this)
        },
        getBoundary: function() {
            return this.getFactory().createGeometryCollection(null)
        },
        clone: function() {
            var a = r.prototype.clone.call(this);
            return a.coordinates =
                this.coordinates.clone(), a
        },
        getGeometryType: function() {
            return "Point"
        },
        copy: function() {
            return new W(this.coordinates.copy(), this.factory)
        },
        getCoordinateSequence: function() {
            return this.coordinates
        },
        getY: function() {
            if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point");
            return this.getCoordinate().y
        },
        isEmpty: function() {
            return 0 === this.coordinates.size()
        },
        init: function(a) {
            null === a && (a = this.getFactory().getCoordinateSequenceFactory().create([]));
            t.isTrue(1 >= a.size());
            this.coordinates = a
        },
        isSimple: function() {
            return !0
        },
        interfaces_: function() {
            return [je]
        },
        getClass: function() {
            return W
        }
    });
    W.serialVersionUID = 0x44077bad161cbc00;
    g(Bb.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Bb
        }
    });
    x(O, r);
    g(O.prototype, {
        computeEnvelopeInternal: function() {
            return this.shell.getEnvelopeInternal()
        },
        getSortIndex: function() {
            return r.SORTINDEX_POLYGON
        },
        getCoordinates: function() {
            if (this.isEmpty()) return [];
            for (var a = Array(this.getNumPoints()).fill(null), b = -1, c = this.shell.getCoordinates(),
                    d = 0; d < c.length; d++) b++, a[b] = c[d];
            for (c = 0; c < this.holes.length; c++)
                for (var d = this.holes[c].getCoordinates(), e = 0; e < d.length; e++) b++, a[b] = d[e];
            return a
        },
        getArea: function() {
            var a;
            a = 0 + Math.abs(q.signedArea(this.shell.getCoordinateSequence()));
            for (var b = 0; b < this.holes.length; b++) a -= Math.abs(q.signedArea(this.holes[b].getCoordinateSequence()));
            return a
        },
        isRectangle: function() {
            if (0 !== this.getNumInteriorRing() || null === this.shell || 5 !== this.shell.getNumPoints()) return !1;
            for (var a = this.shell.getCoordinateSequence(),
                    b = this.getEnvelopeInternal(), c = 0; 5 > c; c++) {
                var d = a.getX(c);
                if (d !== b.getMinX() && d !== b.getMaxX()) return !1;
                var e = a.getY(c);
                if (e !== b.getMinY() && e !== b.getMaxY()) return !1
            }
            for (var b = a.getX(0), f = a.getY(0), c = 1; 4 >= c; c++) {
                d = a.getX(c);
                e = a.getY(c);
                if (d !== b === (e !== f)) return !1;
                b = d;
                f = e
            }
            return !0
        },
        equalsExact: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                if (!this.isEquivalentClass(a) || !this.shell.equalsExact(a.shell, b) || this.holes.length !== a.holes.length) return !1;
                for (var c = 0; c < this.holes.length; c++)
                    if (!this.holes[c].equalsExact(a.holes[c],
                            b)) return !1;
                return !0
            }
            return r.prototype.equalsExact.apply(this, arguments)
        },
        normalize: function() {
            if (0 === arguments.length) {
                this.normalize(this.shell, !0);
                for (var a = 0; a < this.holes.length; a++) this.normalize(this.holes[a], !1);
                zb.sort(this.holes)
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                if (a.isEmpty()) return null;
                var c = Array(a.getCoordinates().length - 1).fill(null);
                U.arraycopy(a.getCoordinates(), 0, c, 0, c.length);
                var d = z.minCoordinate(a.getCoordinates());
                z.scroll(c, d);
                U.arraycopy(c, 0,
                    a.getCoordinates(), 0, c.length);
                a.getCoordinates()[c.length] = c[0];
                q.isCCW(a.getCoordinates()) === b && z.reverse(a.getCoordinates())
            }
        },
        getCoordinate: function() {
            return this.shell.getCoordinate()
        },
        getNumInteriorRing: function() {
            return this.holes.length
        },
        getBoundaryDimension: function() {
            return 1
        },
        getDimension: function() {
            return 2
        },
        getLength: function() {
            var a;
            a = 0 + this.shell.getLength();
            for (var b = 0; b < this.holes.length; b++) a += this.holes[b].getLength();
            return a
        },
        getNumPoints: function() {
            for (var a = this.shell.getNumPoints(),
                    b = 0; b < this.holes.length; b++) a += this.holes[b].getNumPoints();
            return a
        },
        reverse: function() {
            var a = this.copy();
            a.shell = this.shell.copy().reverse();
            a.holes = Array(this.holes.length).fill(null);
            for (var b = 0; b < this.holes.length; b++) a.holes[b] = this.holes[b].copy().reverse();
            return a
        },
        convexHull: function() {
            return this.getExteriorRing().convexHull()
        },
        compareToSameClass: function() {
            if (1 === arguments.length) {
                var a = this.shell,
                    b = arguments[0].shell;
                return a.compareToSameClass(b)
            }
            if (2 === arguments.length) {
                var c = arguments[1],
                    d = arguments[0],
                    a = this.shell,
                    b = d.shell,
                    a = a.compareToSameClass(b, c);
                if (0 !== a) return a;
                for (var a = this.getNumInteriorRing(), b = d.getNumInteriorRing(), e = 0; e < a && e < b;) {
                    var f = this.getInteriorRingN(e),
                        g = d.getInteriorRingN(e),
                        f = f.compareToSameClass(g, c);
                    if (0 !== f) return f;
                    e++
                }
                return e < a ? 1 : e < b ? -1 : 0
            }
        },
        apply: function(a) {
            if (u(a, Yb)) {
                this.shell.apply(a);
                for (var b = 0; b < this.holes.length; b++) this.holes[b].apply(a)
            } else if (u(a, qc)) {
                if (this.shell.apply(a), !a.isDone())
                    for (b = 0; b < this.holes.length && (this.holes[b].apply(a), !a.isDone()); b++);
                a.isGeometryChanged() && this.geometryChanged()
            } else if (u(a, Ab)) a.filter(this);
            else if (u(a, eb))
                for (a.filter(this), this.shell.apply(a), b = 0; b < this.holes.length; b++) this.holes[b].apply(a)
        },
        getBoundary: function() {
            if (this.isEmpty()) return this.getFactory().createMultiLineString();
            var a = Array(this.holes.length + 1).fill(null);
            a[0] = this.shell;
            for (var b = 0; b < this.holes.length; b++) a[b + 1] = this.holes[b];
            return 1 >= a.length ? this.getFactory().createLinearRing(a[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(a)
        },
        clone: function() {
            var a = r.prototype.clone.call(this);
            a.shell = this.shell.clone();
            a.holes = Array(this.holes.length).fill(null);
            for (var b = 0; b < this.holes.length; b++) a.holes[b] = this.holes[b].clone();
            return a
        },
        getGeometryType: function() {
            return "Polygon"
        },
        copy: function() {
            for (var a = this.shell.copy(), b = Array(this.holes.length).fill(null), c = 0; c < b.length; c++) b[c] = this.holes[c].copy();
            return new O(a, b, this.factory)
        },
        getExteriorRing: function() {
            return this.shell
        },
        isEmpty: function() {
            return this.shell.isEmpty()
        },
        getInteriorRingN: function(a) {
            return this.holes[a]
        },
        interfaces_: function() {
            return [Bb]
        },
        getClass: function() {
            return O
        }
    });
    O.serialVersionUID = -0x307ffefd8dc97200;
    x(Ia, F);
    g(Ia.prototype, {
        getSortIndex: function() {
            return r.SORTINDEX_MULTIPOINT
        },
        isValid: function() {
            return !0
        },
        equalsExact: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return !!this.isEquivalentClass(a) && F.prototype.equalsExact.call(this, a, b)
            }
            return F.prototype.equalsExact.apply(this, arguments)
        },
        getCoordinate: function() {
            return 1 === arguments.length ? this.geometries[arguments[0]].getCoordinate() :
                F.prototype.getCoordinate.apply(this, arguments)
        },
        getBoundaryDimension: function() {
            return n.FALSE
        },
        getDimension: function() {
            return 0
        },
        getBoundary: function() {
            return this.getFactory().createGeometryCollection(null)
        },
        getGeometryType: function() {
            return "MultiPoint"
        },
        copy: function() {
            for (var a = Array(this.geometries.length).fill(null), b = 0; b < a.length; b++) a[b] = this.geometries[b].copy();
            return new Ia(a, this.factory)
        },
        interfaces_: function() {
            return [je]
        },
        getClass: function() {
            return Ia
        }
    });
    Ia.serialVersionUID = -0x6fb1ed4162e0fc00;
    x(aa, C);
    g(aa.prototype, {
        getSortIndex: function() {
            return r.SORTINDEX_LINEARRING
        },
        getBoundaryDimension: function() {
            return n.FALSE
        },
        isClosed: function() {
            return !!this.isEmpty() || C.prototype.isClosed.call(this)
        },
        reverse: function() {
            var a = this.points.copy();
            return da.reverse(a), this.getFactory().createLinearRing(a)
        },
        validateConstruction: function() {
            if (!this.isEmpty() && !C.prototype.isClosed.call(this)) throw new K("Points of LinearRing do not form a closed linestring");
            if (1 <= this.getCoordinateSequence().size() &&
                this.getCoordinateSequence().size() < aa.MINIMUM_VALID_SIZE) throw new K("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or \x3e\x3d 4)");
        },
        getGeometryType: function() {
            return "LinearRing"
        },
        copy: function() {
            return new aa(this.points.copy(), this.factory)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return aa
        }
    });
    aa.MINIMUM_VALID_SIZE = 4;
    aa.serialVersionUID = -0x3b229e262367a600;
    x(na, F);
    g(na.prototype, {
        getSortIndex: function() {
            return r.SORTINDEX_MULTIPOLYGON
        },
        equalsExact: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return !!this.isEquivalentClass(a) && F.prototype.equalsExact.call(this, a, b)
            }
            return F.prototype.equalsExact.apply(this, arguments)
        },
        getBoundaryDimension: function() {
            return 1
        },
        getDimension: function() {
            return 2
        },
        reverse: function() {
            for (var a = Array(this.geometries.length).fill(null), b = 0; b < this.geometries.length; b++) a[b] = this.geometries[b].reverse();
            return this.getFactory().createMultiPolygon(a)
        },
        getBoundary: function() {
            if (this.isEmpty()) return this.getFactory().createMultiLineString();
            for (var a = new l, b = 0; b < this.geometries.length; b++)
                for (var c = this.geometries[b].getBoundary(), d = 0; d < c.getNumGeometries(); d++) a.add(c.getGeometryN(d));
            b = Array(a.size()).fill(null);
            return this.getFactory().createMultiLineString(a.toArray(b))
        },
        getGeometryType: function() {
            return "MultiPolygon"
        },
        copy: function() {
            for (var a = Array(this.geometries.length).fill(null), b = 0; b < a.length; b++) a[b] = this.geometries[b].copy();
            return new na(a, this.factory)
        },
        interfaces_: function() {
            return [Bb]
        },
        getClass: function() {
            return na
        }
    });
    na.serialVersionUID = -0x7a5aa1369171980;
    g(Qa.prototype, {
        setCopyUserData: function(a) {
            this.isUserDataCopied = a
        },
        edit: function(a, b) {
            if (null === a) return null;
            var c = this.editInternal(a, b);
            return this.isUserDataCopied && c.setUserData(a.getUserData()), c
        },
        editInternal: function(a, b) {
            return null === this.factory && (this.factory = a.getFactory()), a instanceof F ? this.editGeometryCollection(a, b) : a instanceof O ? this.editPolygon(a, b) : a instanceof W ? b.edit(a, this.factory) : a instanceof C ? b.edit(a, this.factory) : (t.shouldNeverReachHere("Unsupported Geometry class: " +
                a.getClass().getName()), null)
        },
        editGeometryCollection: function(a, b) {
            for (var c = b.edit(a, this.factory), d = new l, e = 0; e < c.getNumGeometries(); e++) {
                var f = this.edit(c.getGeometryN(e), b);
                null === f || f.isEmpty() || d.add(f)
            }
            return c.getClass() === Ia ? this.factory.createMultiPoint(d.toArray([])) : c.getClass() === wa ? this.factory.createMultiLineString(d.toArray([])) : c.getClass() === na ? this.factory.createMultiPolygon(d.toArray([])) : this.factory.createGeometryCollection(d.toArray([]))
        },
        editPolygon: function(a, b) {
            var c = b.edit(a,
                this.factory);
            if (null === c && (c = this.factory.createPolygon(null)), c.isEmpty()) return c;
            var d = this.edit(c.getExteriorRing(), b);
            if (null === d || d.isEmpty()) return this.factory.createPolygon();
            for (var e = new l, f = 0; f < c.getNumInteriorRing(); f++) {
                var g = this.edit(c.getInteriorRingN(f), b);
                null === g || g.isEmpty() || e.add(g)
            }
            return this.factory.createPolygon(d, e.toArray([]))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Qa
        }
    });
    Qa.GeometryEditorOperation = ke;
    g(tf.prototype, {
        edit: function(a, b) {
            return a
        },
        interfaces_: function() {
            return [ke]
        },
        getClass: function() {
            return tf
        }
    });
    g(uf.prototype, {
        edit: function(a, b) {
            var c = this.editCoordinates(a.getCoordinates(), a);
            return null === c ? a : a instanceof aa ? b.createLinearRing(c) : a instanceof C ? b.createLineString(c) : a instanceof W ? 0 < c.length ? b.createPoint(c[0]) : b.createPoint() : a
        },
        interfaces_: function() {
            return [ke]
        },
        getClass: function() {
            return uf
        }
    });
    g(vf.prototype, {
        edit: function(a, b) {
            return a instanceof aa ? b.createLinearRing(this.edit(a.getCoordinateSequence(), a)) : a instanceof
            C ? b.createLineString(this.edit(a.getCoordinateSequence(), a)) : a instanceof W ? b.createPoint(this.edit(a.getCoordinateSequence(), a)) : a
        },
        interfaces_: function() {
            return [ke]
        },
        getClass: function() {
            return vf
        }
    });
    Qa.NoOpGeometryOperation = tf;
    Qa.CoordinateOperation = uf;
    Qa.CoordinateSequenceOperation = vf;
    g(Za.prototype, {
        setOrdinate: function(a, b, c) {
            switch (b) {
                case Q.X:
                    this.coordinates[a].x = c;
                    break;
                case Q.Y:
                    this.coordinates[a].y = c;
                    break;
                case Q.Z:
                    this.coordinates[a].z = c;
                    break;
                default:
                    throw new K("invalid ordinateIndex");
            }
        },
        size: function() {
            return this.coordinates.length
        },
        getOrdinate: function(a, b) {
            switch (b) {
                case Q.X:
                    return this.coordinates[a].x;
                case Q.Y:
                    return this.coordinates[a].y;
                case Q.Z:
                    return this.coordinates[a].z
            }
            return v.NaN
        },
        getCoordinate: function() {
            if (1 === arguments.length) return this.coordinates[arguments[0]];
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                b.x = this.coordinates[a].x;
                b.y = this.coordinates[a].y;
                b.z = this.coordinates[a].z
            }
        },
        getCoordinateCopy: function(a) {
            return new k(this.coordinates[a])
        },
        getDimension: function() {
            return this.dimension
        },
        getX: function(a) {
            return this.coordinates[a].x
        },
        clone: function() {
            for (var a = Array(this.size()).fill(null), b = 0; b < this.coordinates.length; b++) a[b] = this.coordinates[b].clone();
            return new Za(a, this.dimension)
        },
        expandEnvelope: function(a) {
            for (var b = 0; b < this.coordinates.length; b++) a.expandToInclude(this.coordinates[b]);
            return a
        },
        copy: function() {
            for (var a = Array(this.size()).fill(null), b = 0; b < this.coordinates.length; b++) a[b] = this.coordinates[b].copy();
            return new Za(a,
                this.dimension)
        },
        toString: function() {
            if (0 < this.coordinates.length) {
                var a = new Ya(17 * this.coordinates.length);
                a.append("(");
                a.append(this.coordinates[0]);
                for (var b = 1; b < this.coordinates.length; b++) a.append(", "), a.append(this.coordinates[b]);
                return a.append(")"), a.toString()
            }
            return "()"
        },
        getY: function(a) {
            return this.coordinates[a].y
        },
        toCoordinateArray: function() {
            return this.coordinates
        },
        interfaces_: function() {
            return [Q, Ba]
        },
        getClass: function() {
            return Za
        }
    });
    Za.serialVersionUID = -0xcb44a778db18e00;
    g(Pb.prototype, {
        readResolve: function() {
            return Pb.instance()
        },
        create: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof Array || u(arguments[0], Q)) return new Za(arguments[0])
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return 3 < b && (b = 3), 2 > b ? new Za(a) : new Za(a, b)
            }
        },
        interfaces_: function() {
            return [de, Ba]
        },
        getClass: function() {
            return Pb
        }
    });
    Pb.instance = function() {
        return Pb.instanceObject
    };
    Pb.serialVersionUID = -0x38e49fa6cf6f2e00;
    Pb.instanceObject = new Pb;
    var ub, yg = Object.defineProperty,
        zg = function(a,
            b) {
            function c(a) {
                if (!this || this.constructor !== c) return new c(a);
                this._keys = [];
                this._values = [];
                this._itp = [];
                this.objectOnly = b;
                a && vg.call(this, a)
            }
            return b || yg(a, "size", {
                get: wg
            }), a.constructor = c, c.prototype = a, c
        }({
            "delete": function(a) {
                return this.has(a) && (this._keys.splice(ub, 1), this._values.splice(ub, 1), this._itp.forEach(function(a) {
                    ub < a[0] && a[0]--
                })), -1 < ub
            },
            has: function(a) {
                var b = this._keys;
                if (this.objectOnly && a !== Object(a)) throw new TypeError("Invalid value used as weak collection key");
                if (a !== a || 0 ===
                    a)
                    for (ub = b.length; ub-- && !ug(b[ub], a););
                else ub = b.indexOf(a);
                return -1 < ub
            },
            get: function(a) {
                return this.has(a) ? this._values[ub] : void 0
            },
            set: function(a, b) {
                return this.has(a) ? this._values[ub] = b : this._values[this._keys.push(a) - 1] = b, this
            },
            keys: function() {
                return wf(this._itp, this._keys)
            },
            values: function() {
                return wf(this._itp, this._values)
            },
            entries: function() {
                return wf(this._itp, this._keys, this._values)
            },
            forEach: function(a, b) {
                for (var c = this.entries();;) {
                    var d = c.next();
                    if (d.done) break;
                    a.call(b, d.value[1], d.value[0],
                        this)
                }
            },
            clear: function() {
                (this._keys || 0).length = this._values.length = 0
            }
        }),
        xg = "undefined" != typeof Map && Map.prototype.values ? Map : zg;
    Cb.prototype = new pc;
    Cb.prototype.get = function(a) {
        return this.map_.get(a) || null
    };
    Cb.prototype.put = function(a, b) {
        return this.map_.set(a, b), b
    };
    Cb.prototype.values = function() {
        for (var a = new l, b = this.map_.values(), c = b.next(); !c.done;) a.add(c.value), c = b.next();
        return a
    };
    Cb.prototype.entrySet = function() {
        var a = new ma;
        return this.map_.entries().forEach(function(b) {
                return a.add(b)
            }),
            a
    };
    Cb.prototype.size = function() {
        return this.map_.size()
    };
    g(L.prototype, {
        equals: function(a) {
            return a instanceof L ? this.modelType === a.modelType && this.scale === a.scale : !1
        },
        compareTo: function(a) {
            var b = this.getMaximumSignificantDigits();
            a = a.getMaximumSignificantDigits();
            return (new db(b)).compareTo(new db(a))
        },
        getScale: function() {
            return this.scale
        },
        isFloating: function() {
            return this.modelType === L.FLOATING || this.modelType === L.FLOATING_SINGLE
        },
        getType: function() {
            return this.modelType
        },
        toString: function() {
            var a =
                "UNKNOWN";
            return this.modelType === L.FLOATING ? a = "Floating" : this.modelType === L.FLOATING_SINGLE ? a = "Floating-Single" : this.modelType === L.FIXED && (a = "Fixed (Scale\x3d" + this.getScale() + ")"), a
        },
        makePrecise: function(a) {
            if ("number" == typeof a) return v.isNaN(a) || this.modelType === L.FLOATING_SINGLE ? a : this.modelType === L.FIXED ? Math.round(a * this.scale) / this.scale : a;
            if (a instanceof k) {
                if (this.modelType === L.FLOATING) return null;
                a.x = this.makePrecise(a.x);
                a.y = this.makePrecise(a.y)
            }
        },
        getMaximumSignificantDigits: function() {
            var a =
                16;
            return this.modelType === L.FLOATING ? a = 16 : this.modelType === L.FLOATING_SINGLE ? a = 6 : this.modelType === L.FIXED && (a = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), a
        },
        setScale: function(a) {
            this.scale = Math.abs(a)
        },
        interfaces_: function() {
            return [Ba, Aa]
        },
        getClass: function() {
            return L
        }
    });
    L.mostPrecise = function(a, b) {
        return 0 <= a.compareTo(b) ? a : b
    };
    g(mb.prototype, {
        readResolve: function() {
            return mb.nameToTypeMap.get(this.name)
        },
        toString: function() {
            return this.name
        },
        interfaces_: function() {
            return [Ba]
        },
        getClass: function() {
            return mb
        }
    });
    mb.serialVersionUID = -0x4cb98acd40a6b400;
    mb.nameToTypeMap = new Cb;
    L.Type = mb;
    L.serialVersionUID = 0x6bee6404e9a25c00;
    L.FIXED = new mb("FIXED");
    L.FLOATING = new mb("FLOATING");
    L.FLOATING_SINGLE = new mb("FLOATING SINGLE");
    L.maximumPreciseValue = 9007199254740992;
    g(E.prototype, {
        toGeometry: function(a) {
            return a.isNull() ? this.createPoint(null) : a.getMinX() === a.getMaxX() && a.getMinY() === a.getMaxY() ? this.createPoint(new k(a.getMinX(), a.getMinY())) : a.getMinX() === a.getMaxX() || a.getMinY() ===
                a.getMaxY() ? this.createLineString([new k(a.getMinX(), a.getMinY()), new k(a.getMaxX(), a.getMaxY())]) : this.createPolygon(this.createLinearRing([new k(a.getMinX(), a.getMinY()), new k(a.getMinX(), a.getMaxY()), new k(a.getMaxX(), a.getMaxY()), new k(a.getMaxX(), a.getMinY()), new k(a.getMinX(), a.getMinY())]), null)
        },
        createLineString: function() {
            if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
            if (1 === arguments.length) {
                if (arguments[0] instanceof Array) {
                    var a = arguments[0];
                    return this.createLineString(null !== a ? this.getCoordinateSequenceFactory().create(a) : null)
                }
                if (u(arguments[0], Q)) return new C(arguments[0], this)
            }
        },
        createMultiLineString: function() {
            if (0 === arguments.length) return new wa(null, this);
            if (1 === arguments.length) return new wa(arguments[0], this)
        },
        buildGeometry: function(a) {
            for (var b = null, c = !1, d = !1, e = a.iterator(); e.hasNext();) {
                var f = e.next(),
                    g = f.getClass();
                null === b && (b = g);
                g !== b && (c = !0);
                f.isGeometryCollectionOrDerived() && (d = !0)
            }
            if (null === b) return this.createGeometryCollection();
            if (c || d) return this.createGeometryCollection(E.toGeometryArray(a));
            b = a.iterator().next();
            if (1 < a.size()) {
                if (b instanceof O) return this.createMultiPolygon(E.toPolygonArray(a));
                if (b instanceof C) return this.createMultiLineString(E.toLineStringArray(a));
                if (b instanceof W) return this.createMultiPoint(E.toPointArray(a));
                t.shouldNeverReachHere("Unhandled class: " + b.getClass().getName())
            }
            return b
        },
        createMultiPointFromCoords: function(a) {
            return this.createMultiPoint(null !== a ? this.getCoordinateSequenceFactory().create(a) :
                null)
        },
        createPoint: function() {
            if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
            if (1 === arguments.length) {
                if (arguments[0] instanceof k) {
                    var a = arguments[0];
                    return this.createPoint(null !== a ? this.getCoordinateSequenceFactory().create([a]) : null)
                }
                if (u(arguments[0], Q)) return new W(arguments[0], this)
            }
        },
        getCoordinateSequenceFactory: function() {
            return this.coordinateSequenceFactory
        },
        createPolygon: function() {
            if (0 === arguments.length) return new O(null, null, this);
            if (1 ===
                arguments.length) {
                if (u(arguments[0], Q) || arguments[0] instanceof Array) return this.createPolygon(this.createLinearRing(arguments[0]));
                if (arguments[0] instanceof aa) return this.createPolygon(arguments[0], null)
            } else if (2 === arguments.length) return new O(arguments[0], arguments[1], this)
        },
        getSRID: function() {
            return this.SRID
        },
        createGeometryCollection: function() {
            if (0 === arguments.length) return new F(null, this);
            if (1 === arguments.length) return new F(arguments[0], this)
        },
        createGeometry: function(a) {
            return (new Qa(this)).edit(a, {
                edit: function() {
                    if (2 === arguments.length) {
                        var a = arguments[0];
                        return arguments[1], this.coordinateSequenceFactory.create(a)
                    }
                }
            })
        },
        getPrecisionModel: function() {
            return this.precisionModel
        },
        createLinearRing: function() {
            if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
            if (1 === arguments.length) {
                if (arguments[0] instanceof Array) {
                    var a = arguments[0];
                    return this.createLinearRing(null !== a ? this.getCoordinateSequenceFactory().create(a) : null)
                }
                if (u(arguments[0], Q)) return new aa(arguments[0],
                    this)
            }
        },
        createMultiPolygon: function() {
            if (0 === arguments.length) return new na(null, this);
            if (1 === arguments.length) return new na(arguments[0], this)
        },
        createMultiPoint: function() {
            if (0 === arguments.length) return new Ia(null, this);
            if (1 === arguments.length) {
                if (arguments[0] instanceof Array) return new Ia(arguments[0], this);
                if (arguments[0] instanceof Array) {
                    var a = arguments[0];
                    return this.createMultiPoint(null !== a ? this.getCoordinateSequenceFactory().create(a) : null)
                }
                if (u(arguments[0], Q)) {
                    a = arguments[0];
                    if (null ===
                        a) return this.createMultiPoint([].fill(null));
                    for (var b = Array(a.size()).fill(null), c = 0; c < a.size(); c++) {
                        var d = this.getCoordinateSequenceFactory().create(1, a.getDimension());
                        da.copy(a, c, d, 0, 1);
                        b[c] = this.createPoint(d)
                    }
                    return this.createMultiPoint(b)
                }
            }
        },
        interfaces_: function() {
            return [Ba]
        },
        getClass: function() {
            return E
        }
    });
    E.toMultiPolygonArray = function(a) {
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.toGeometryArray = function(a) {
        if (null === a) return null;
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.getDefaultCoordinateSequenceFactory = function() {
        return Pb.instance()
    };
    E.toMultiLineStringArray = function(a) {
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.toLineStringArray = function(a) {
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.toMultiPointArray = function(a) {
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.toLinearRingArray = function(a) {
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.toPointArray = function(a) {
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.toPolygonArray = function(a) {
        var b = Array(a.size()).fill(null);
        return a.toArray(b)
    };
    E.createPointFromInternalCoord = function(a, b) {
        return b.getPrecisionModel().makePrecise(a), b.getFactory().createPoint(a)
    };
    E.serialVersionUID = -0x5ea75f2051eeb400;
    var Ag = /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
        Bg = /^\s*(\w+)\s*EMPTY\s*$/,
        fg = /\s+/,
        og = /\)\s*,\s*\(/,
        Cg = /\)\s*\)\s*,\s*\(\s*\(/,
        mf = /^\s*\(?(.*?)\)?\s*$/;
    g(xf.prototype, {
        read: function(a) {
            var b, c, d;
            a = a.replace(/[\n\r]/g, " ");
            var e = Ag.exec(a);
            if (-1 !== a.search("EMPTY") &&
                (e = Bg.exec(a), e[2] = void 0), e && (c = e[1].toLowerCase(), d = e[2], fd[c] && (b = fd[c].apply(this, [d]))), void 0 === b) throw Error("Could not parse WKT " + a);
            return b
        },
        write: function(a) {
            return this.extractGeometry(a)
        },
        extractGeometry: function(a) {
            var b = a.getGeometryType().toLowerCase();
            if (!Mb[b]) return null;
            var c = b.toUpperCase();
            return a.isEmpty() ? c + " EMPTY" : c + "(" + Mb[b].apply(this, [a]) + ")"
        }
    });
    var Mb = {
            coordinate: function(a) {
                return a.x + " " + a.y
            },
            point: function(a) {
                return Mb.coordinate.call(this, a.coordinates.coordinates[0])
            },
            multipoint: function(a) {
                for (var b = [], c = 0, d = a.geometries.length; c < d; ++c) b.push("(" + Mb.point.apply(this, [a.geometries[c]]) + ")");
                return b.join(",")
            },
            linestring: function(a) {
                for (var b = [], c = 0, d = a.points.coordinates.length; c < d; ++c) b.push(Mb.coordinate.apply(this, [a.points.coordinates[c]]));
                return b.join(",")
            },
            linearring: function(a) {
                for (var b = [], c = 0, d = a.points.coordinates.length; c < d; ++c) b.push(Mb.coordinate.apply(this, [a.points.coordinates[c]]));
                return b.join(",")
            },
            multilinestring: function(a) {
                for (var b = [],
                        c = 0, d = a.geometries.length; c < d; ++c) b.push("(" + Mb.linestring.apply(this, [a.geometries[c]]) + ")");
                return b.join(",")
            },
            polygon: function(a) {
                var b = [];
                b.push("(" + Mb.linestring.apply(this, [a.shell]) + ")");
                for (var c = 0, d = a.holes.length; c < d; ++c) b.push("(" + Mb.linestring.apply(this, [a.holes[c]]) + ")");
                return b.join(",")
            },
            multipolygon: function(a) {
                for (var b = [], c = 0, d = a.geometries.length; c < d; ++c) b.push("(" + Mb.polygon.apply(this, [a.geometries[c]]) + ")");
                return b.join(",")
            },
            geometrycollection: function(a) {
                for (var b = [], c =
                        0, d = a.geometries.length; c < d; ++c) b.push(this.extractGeometry(a.geometries[c]));
                return b.join(",")
            }
        },
        fd = {
            point: function(a) {
                if (void 0 === a) return this.geometryFactory.createPoint();
                a = a.trim().split(fg);
                return this.geometryFactory.createPoint(new k(Number.parseFloat(a[0]), Number.parseFloat(a[1])))
            },
            multipoint: function(a) {
                if (void 0 === a) return this.geometryFactory.createMultiPoint();
                for (var b = a.trim().split(","), c = [], d = 0, e = b.length; d < e; ++d) a = b[d].replace(mf, "$1"), c.push(fd.point.apply(this, [a]));
                return this.geometryFactory.createMultiPoint(c)
            },
            linestring: function(a) {
                if (void 0 === a) return this.geometryFactory.createLineString();
                for (var b = a.trim().split(","), c = [], d = 0, e = b.length; d < e; ++d) a = b[d].trim().split(fg), c.push(new k(Number.parseFloat(a[0]), Number.parseFloat(a[1])));
                return this.geometryFactory.createLineString(c)
            },
            linearring: function(a) {
                if (void 0 === a) return this.geometryFactory.createLinearRing();
                for (var b = a.trim().split(","), c = [], d = 0, e = b.length; d < e; ++d) a = b[d].trim().split(fg), c.push(new k(Number.parseFloat(a[0]), Number.parseFloat(a[1])));
                return this.geometryFactory.createLinearRing(c)
            },
            multilinestring: function(a) {
                if (void 0 === a) return this.geometryFactory.createMultiLineString();
                for (var b = a.trim().split(og), c = [], d = 0, e = b.length; d < e; ++d) a = b[d].replace(mf, "$1"), c.push(fd.linestring.apply(this, [a]));
                return this.geometryFactory.createMultiLineString(c)
            },
            polygon: function(a) {
                if (void 0 === a) return this.geometryFactory.createPolygon();
                var b, c;
                a = a.trim().split(og);
                for (var d = [], e = 0, f = a.length; e < f; ++e) b = a[e].replace(mf, "$1"), b = fd.linestring.apply(this, [b]), b = this.geometryFactory.createLinearRing(b.points), 0 === e ? c = b : d.push(b);
                return this.geometryFactory.createPolygon(c, d)
            },
            multipolygon: function(a) {
                if (void 0 === a) return this.geometryFactory.createMultiPolygon();
                for (var b = a.trim().split(Cg), c = [], d = 0, e = b.length; d < e; ++d) a = b[d].replace(mf, "$1"), c.push(fd.polygon.apply(this, [a]));
                return this.geometryFactory.createMultiPolygon(c)
            },
            geometrycollection: function(a) {
                if (void 0 === a) return this.geometryFactory.createGeometryCollection();
                a = a.replace(/,\s*([A-Za-z])/g,
                    "|$1");
                a = a.trim().split("|");
                for (var b = [], c = 0, d = a.length; c < d; ++c) b.push(this.read(a[c]));
                return this.geometryFactory.createGeometryCollection(b)
            }
        };
    g(ra.prototype, {
        write: function(a) {
            return this.parser.write(a)
        }
    });
    g(ra, {
        toLineString: function(a, b) {
            if (2 !== arguments.length) throw Error("Not implemented");
            return "LINESTRING ( " + a.x + " " + a.y + ", " + b.x + " " + b.y + " )"
        }
    });
    g(P.prototype, {
        getIndexAlongSegment: function(a, b) {
            return this.computeIntLineIndex(), this.intLineIndex[a][b]
        },
        getTopologySummary: function() {
            var a =
                new Ya;
            return this.isEndPoint() && a.append(" endpoint"), this._isProper && a.append(" proper"), this.isCollinear() && a.append(" collinear"), a.toString()
        },
        computeIntersection: function(a, b, c, d) {
            this.inputLines[0][0] = a;
            this.inputLines[0][1] = b;
            this.inputLines[1][0] = c;
            this.inputLines[1][1] = d;
            this.result = this.computeIntersect(a, b, c, d)
        },
        getIntersectionNum: function() {
            return this.result
        },
        computeIntLineIndex: function() {
            if (0 === arguments.length) null === this.intLineIndex && (this.intLineIndex = Array(2).fill().map(function() {
                    return Array(2)
                }),
                this.computeIntLineIndex(0), this.computeIntLineIndex(1));
            else if (1 === arguments.length) {
                var a = arguments[0],
                    b = this.getEdgeDistance(a, 0),
                    c = this.getEdgeDistance(a, 1);
                b > c ? (this.intLineIndex[a][0] = 0, this.intLineIndex[a][1] = 1) : (this.intLineIndex[a][0] = 1, this.intLineIndex[a][1] = 0)
            }
        },
        isProper: function() {
            return this.hasIntersection() && this._isProper
        },
        setPrecisionModel: function(a) {
            this.precisionModel = a
        },
        isInteriorIntersection: function() {
            if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
            if (1 === arguments.length) {
                for (var a = arguments[0], b = 0; b < this.result; b++)
                    if (!this.intPt[b].equals2D(this.inputLines[a][0]) && !this.intPt[b].equals2D(this.inputLines[a][1])) return !0;
                return !1
            }
        },
        getIntersection: function(a) {
            return this.intPt[a]
        },
        isEndPoint: function() {
            return this.hasIntersection() && !this._isProper
        },
        hasIntersection: function() {
            return this.result !== P.NO_INTERSECTION
        },
        getEdgeDistance: function(a, b) {
            return P.computeEdgeDistance(this.intPt[b], this.inputLines[a][0], this.inputLines[a][1])
        },
        isCollinear: function() {
            return this.result ===
                P.COLLINEAR_INTERSECTION
        },
        toString: function() {
            return ra.toLineString(this.inputLines[0][0], this.inputLines[0][1]) + " - " + ra.toLineString(this.inputLines[1][0], this.inputLines[1][1]) + this.getTopologySummary()
        },
        getEndpoint: function(a, b) {
            return this.inputLines[a][b]
        },
        isIntersection: function(a) {
            for (var b = 0; b < this.result; b++)
                if (this.intPt[b].equals2D(a)) return !0;
            return !1
        },
        getIntersectionAlongSegment: function(a, b) {
            return this.computeIntLineIndex(), this.intPt[this.intLineIndex[a][b]]
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return P
        }
    });
    P.computeEdgeDistance = function(a, b, c) {
        var d = Math.abs(c.x - b.x),
            e = Math.abs(c.y - b.y),
            f = -1;
        if (a.equals(b)) f = 0;
        else if (a.equals(c)) f = d > e ? d : e;
        else {
            c = Math.abs(a.x - b.x);
            var g = Math.abs(a.y - b.y),
                f = d > e ? c : g;
            0 !== f || a.equals(b) || (f = Math.max(c, g))
        }
        return t.isTrue(!(0 === f && !a.equals(b)), "Bad distance calculation"), f
    };
    P.nonRobustComputeEdgeDistance = function(a, b, c) {
        c = a.x - b.x;
        var d = a.y - b.y;
        c = Math.sqrt(c * c + d * d);
        return t.isTrue(!(0 === c && !a.equals(b)), "Invalid distance calculation"), c
    };
    P.DONT_INTERSECT = 0;
    P.DO_INTERSECT = 1;
    P.COLLINEAR = 2;
    P.NO_INTERSECTION = 0;
    P.POINT_INTERSECTION = 1;
    P.COLLINEAR_INTERSECTION = 2;
    x(ia, P);
    g(ia.prototype, {
        isInSegmentEnvelopes: function(a) {
            var b = new y(this.inputLines[0][0], this.inputLines[0][1]),
                c = new y(this.inputLines[1][0], this.inputLines[1][1]);
            return b.contains(a) && c.contains(a)
        },
        computeIntersection: function() {
            if (3 !== arguments.length) return P.prototype.computeIntersection.apply(this, arguments);
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            if (this._isProper = !1, y.intersects(b, c, a) && 0 === q.orientationIndex(b, c, a) && 0 === q.orientationIndex(c, b, a)) return this._isProper = !0, (a.equals(b) || a.equals(c)) && (this._isProper = !1), this.result = P.POINT_INTERSECTION, null;
            this.result = P.NO_INTERSECTION
        },
        normalizeToMinimum: function(a, b, c, d, e) {
            e.x = this.smallestInAbsValue(a.x, b.x, c.x, d.x);
            e.y = this.smallestInAbsValue(a.y, b.y, c.y, d.y);
            a.x -= e.x;
            a.y -= e.y;
            b.x -= e.x;
            b.y -= e.y;
            c.x -= e.x;
            c.y -= e.y;
            d.x -= e.x;
            d.y -= e.y
        },
        safeHCoordinateIntersection: function(a, b, c, d) {
            var e = null;
            try {
                e = Ha.intersection(a,
                    b, c, d)
            } catch (f) {
                if (!(f instanceof xb)) throw f;
                e = ia.nearestEndpoint(a, b, c, d)
            }
            return e
        },
        intersection: function(a, b, c, d) {
            var e = this.intersectionWithNormalization(a, b, c, d);
            return this.isInSegmentEnvelopes(e) || (e = new k(ia.nearestEndpoint(a, b, c, d))), null !== this.precisionModel && this.precisionModel.makePrecise(e), e
        },
        smallestInAbsValue: function(a, b, c, d) {
            var e = Math.abs(a);
            return Math.abs(b) < e && (a = b, e = Math.abs(b)), Math.abs(c) < e && (a = c, e = Math.abs(c)), Math.abs(d) < e && (a = d), a
        },
        checkDD: function(a, b, c, d, e) {
            a = Ga.intersection(a,
                b, c, d);
            b = this.isInSegmentEnvelopes(a);
            U.out.println("DD in env \x3d " + b + "  --------------------- " + a);
            1E-4 < e.distance(a) && U.out.println("Distance \x3d " + e.distance(a))
        },
        intersectionWithNormalization: function(a, b, c, d) {
            a = new k(a);
            b = new k(b);
            c = new k(c);
            var e = new k(d);
            d = new k;
            this.normalizeToEnvCentre(a, b, c, e, d);
            a = this.safeHCoordinateIntersection(a, b, c, e);
            return a.x += d.x, a.y += d.y, a
        },
        computeCollinearIntersection: function(a, b, c, d) {
            var e = y.intersects(a, b, c),
                f = y.intersects(a, b, d),
                g = y.intersects(c, d, a),
                h =
                y.intersects(c, d, b);
            return e && f ? (this.intPt[0] = c, this.intPt[1] = d, P.COLLINEAR_INTERSECTION) : g && h ? (this.intPt[0] = a, this.intPt[1] = b, P.COLLINEAR_INTERSECTION) : e && g ? (this.intPt[0] = c, this.intPt[1] = a, !c.equals(a) || f || h ? P.COLLINEAR_INTERSECTION : P.POINT_INTERSECTION) : e && h ? (this.intPt[0] = c, this.intPt[1] = b, !c.equals(b) || f || g ? P.COLLINEAR_INTERSECTION : P.POINT_INTERSECTION) : f && g ? (this.intPt[0] = d, this.intPt[1] = a, !d.equals(a) || e || h ? P.COLLINEAR_INTERSECTION : P.POINT_INTERSECTION) : f && h ? (this.intPt[0] = d, this.intPt[1] =
                b, !d.equals(b) || e || g ? P.COLLINEAR_INTERSECTION : P.POINT_INTERSECTION) : P.NO_INTERSECTION
        },
        normalizeToEnvCentre: function(a, b, c, d, e) {
            var f = a.x < b.x ? a.x : b.x,
                g = a.y < b.y ? a.y : b.y,
                h = a.x > b.x ? a.x : b.x,
                k = a.y > b.y ? a.y : b.y,
                l = c.x < d.x ? c.x : d.x,
                m = c.y < d.y ? c.y : d.y,
                n = c.x > d.x ? c.x : d.x,
                p = c.y > d.y ? c.y : d.y;
            e.x = ((f > l ? f : l) + (h < n ? h : n)) / 2;
            e.y = ((g > m ? g : m) + (k < p ? k : p)) / 2;
            a.x -= e.x;
            a.y -= e.y;
            b.x -= e.x;
            b.y -= e.y;
            c.x -= e.x;
            c.y -= e.y;
            d.x -= e.x;
            d.y -= e.y
        },
        computeIntersect: function(a, b, c, d) {
            if (this._isProper = !1, !y.intersects(a, b, c, d)) return P.NO_INTERSECTION;
            var e = q.orientationIndex(a, b, c),
                f = q.orientationIndex(a, b, d);
            if (0 < e && 0 < f || 0 > e && 0 > f) return P.NO_INTERSECTION;
            var g = q.orientationIndex(c, d, a),
                h = q.orientationIndex(c, d, b);
            return 0 < g && 0 < h || 0 > g && 0 > h ? P.NO_INTERSECTION : 0 === e && 0 === f && 0 === g && 0 === h ? this.computeCollinearIntersection(a, b, c, d) : (0 === e || 0 === f || 0 === g || 0 === h ? (this._isProper = !1, a.equals2D(c) || a.equals2D(d) ? this.intPt[0] = a : b.equals2D(c) || b.equals2D(d) ? this.intPt[0] = b : 0 === e ? this.intPt[0] = new k(c) : 0 === f ? this.intPt[0] = new k(d) : 0 === g ? this.intPt[0] = new k(a) :
                0 === h && (this.intPt[0] = new k(b))) : (this._isProper = !0, this.intPt[0] = this.intersection(a, b, c, d)), P.POINT_INTERSECTION)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ia
        }
    });
    ia.nearestEndpoint = function(a, b, c, d) {
        var e = a,
            f = q.distancePointLine(a, c, d),
            g = q.distancePointLine(b, c, d);
        return g < f && (f = g, e = b), g = q.distancePointLine(c, a, b), g < f && (f = g, e = c), g = q.distancePointLine(d, a, b), g < f && (e = d), e
    };
    g(rc.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return rc
        }
    });
    rc.orientationIndex = function(a,
        b, c) {
        return rc.signOfDet2x2(b.x - a.x, b.y - a.y, c.x - b.x, c.y - b.y)
    };
    rc.signOfDet2x2 = function(a, b, c, d) {
        var e = null,
            f = null,
            g = null;
        if (e = 1, 0 === a || 0 === d) return 0 === b || 0 === c ? 0 : 0 < b ? 0 < c ? -e : e : 0 < c ? e : -e;
        if (0 === b || 0 === c) return 0 < d ? 0 < a ? e : -e : 0 < a ? -e : e;
        if (0 < b ? 0 < d ? b <= d || (e = -e, f = a, a = c, c = f, f = b, b = d, d = f) : b <= -d ? (e = -e, c = -c, d = -d) : (f = a, a = -c, c = f, f = b, b = -d, d = f) : 0 < d ? -b <= d ? (e = -e, a = -a, b = -b) : (f = -a, a = c, c = f, f = -b, b = d, d = f) : b >= d ? (a = -a, b = -b, c = -c, d = -d) : (e = -e, f = -a, a = -c, c = f, f = -b, b = -d, d = f), 0 < a) {
            if (!(0 < c && a <= c)) return e
        } else {
            if (0 < c || !(a >= c)) return -e;
            e = -e;
            a = -a;
            c = -c
        }
        for (;;) {
            if (g = Math.floor(c / a), c -= g * a, 0 > (d -= g * b)) return -e;
            if (d > b) return e;
            if (a > c + c) {
                if (b < d + d) return e
            } else {
                if (b > d + d) return -e;
                c = a - c;
                d = b - d;
                e = -e
            }
            if (0 === d) return 0 === c ? 0 : -e;
            if (0 === c || (g = Math.floor(a / c), a -= g * c, 0 > (b -= g * d))) return e;
            if (b > d) return -e;
            if (c > a + a) {
                if (d < b + b) return -e
            } else {
                if (d > b + b) return e;
                a = c - a;
                b = d - b;
                e = -e
            }
            if (0 === b) return 0 === a ? 0 : e;
            if (0 === a) return -e
        }
    };
    g(sc.prototype, {
        countSegment: function(a, b) {
            if (a.x < this.p.x && b.x < this.p.x) return null;
            if (this.p.x === b.x && this.p.y === b.y) return this.isPointOnSegment = !0, null;
            if (a.y === this.p.y && b.y === this.p.y) {
                var c = a.x,
                    d = b.x;
                return c > d && (c = b.x, d = a.x), this.p.x >= c && this.p.x <= d && (this.isPointOnSegment = !0), null
            }
            if (a.y > this.p.y && b.y <= this.p.y || b.y > this.p.y && a.y <= this.p.y) {
                var c = a.y - this.p.y,
                    d = b.y - this.p.y,
                    e = rc.signOfDet2x2(a.x - this.p.x, c, b.x - this.p.x, d);
                if (0 === e) return this.isPointOnSegment = !0, null;
                d < c && (e = -e);
                0 < e && this.crossingCount++
            }
        },
        isPointInPolygon: function() {
            return this.getLocation() !== h.EXTERIOR
        },
        getLocation: function() {
            return this.isPointOnSegment ? h.BOUNDARY :
                1 == this.crossingCount % 2 ? h.INTERIOR : h.EXTERIOR
        },
        isOnSegment: function() {
            return this.isPointOnSegment
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return sc
        }
    });
    sc.locatePointInRing = function(a, b) {
        if (a instanceof k && u(b, Q)) {
            for (var c = new sc(a), d = new k, e = new k, f = 1; f < b.size() && (b.getCoordinate(f, d), b.getCoordinate(f - 1, e), c.countSegment(d, e), !c.isOnSegment()); f++);
            return c.getLocation()
        }
        if (a instanceof k && b instanceof Array) {
            c = new sc(a);
            for (f = 1; f < b.length && (d = b[f], e = b[f - 1], c.countSegment(d, e), !c.isOnSegment()); f++);
            return c.getLocation()
        }
    };
    g(q.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return q
        }
    });
    q.orientationIndex = function(a, b, c) {
        return Ga.orientationIndex(a, b, c)
    };
    q.signedArea = function(a) {
        if (a instanceof Array) {
            if (3 > a.length) return 0;
            for (var b = 0, c = a[0].x, d = 1; d < a.length - 1; d++) b += (a[d].x - c) * (a[d - 1].y - a[d + 1].y);
            return b / 2
        }
        if (u(a, Q)) {
            var e = a.size();
            if (3 > e) return 0;
            var f = new k,
                g = new k,
                h = new k;
            a.getCoordinate(0, g);
            a.getCoordinate(1, h);
            c = g.x;
            h.x -= c;
            b = 0;
            for (d = 1; d < e - 1; d++) f.y = g.y, g.x = h.x, g.y = h.y,
                a.getCoordinate(d + 1, h), h.x -= c, b += g.x * (f.y - h.y);
            return b / 2
        }
    };
    q.distanceLineLine = function(a, b, c, d) {
        if (a.equals(b)) return q.distancePointLine(a, c, d);
        if (c.equals(d)) return q.distancePointLine(d, a, b);
        var e = !1;
        if (y.intersects(a, b, c, d)) {
            var f = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);
            if (0 === f) e = !0;
            else {
                var g = ((a.y - c.y) * (b.x - a.x) - (a.x - c.x) * (b.y - a.y)) / f,
                    f = ((a.y - c.y) * (d.x - c.x) - (a.x - c.x) * (d.y - c.y)) / f;
                (0 > f || 1 < f || 0 > g || 1 < g) && (e = !0)
            }
        } else e = !0;
        return e ? Oa.min(q.distancePointLine(a, c, d), q.distancePointLine(b, c, d),
            q.distancePointLine(c, a, b), q.distancePointLine(d, a, b)) : 0
    };
    q.isPointInRing = function(a, b) {
        return q.locatePointInRing(a, b) !== h.EXTERIOR
    };
    q.computeLength = function(a) {
        var b = a.size();
        if (1 >= b) return 0;
        var c = 0,
            d = new k;
        a.getCoordinate(0, d);
        for (var e = d.x, f = d.y, g = 1; g < b; g++) {
            a.getCoordinate(g, d);
            var h = d.x,
                l = d.y,
                e = h - e,
                f = l - f,
                c = c + Math.sqrt(e * e + f * f),
                e = h,
                f = l
        }
        return c
    };
    q.isCCW = function(a) {
        var b = a.length - 1;
        if (3 > b) throw new K("Ring has fewer than 4 points, so orientation cannot be determined");
        for (var c = a[0], d = 0, e = 1; e <=
            b; e++) {
            var f = a[e];
            f.y > c.y && (c = f, d = e)
        }
        f = d;
        do 0 > --f && (f = b); while (a[f].equals2D(c) && f !== d);
        e = d;
        do e = (e + 1) % b; while (a[e].equals2D(c) && e !== d);
        b = a[f];
        a = a[e];
        if (b.equals2D(c) || a.equals2D(c) || b.equals2D(a)) return !1;
        c = q.computeOrientation(b, c, a);
        return 0 === c ? b.x > a.x : 0 < c
    };
    q.locatePointInRing = function(a, b) {
        return sc.locatePointInRing(a, b)
    };
    q.distancePointLinePerpendicular = function(a, b, c) {
        var d = (c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (c.y - b.y);
        return Math.abs(((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)) / d) * Math.sqrt(d)
    };
    q.computeOrientation =
        function(a, b, c) {
            return q.orientationIndex(a, b, c)
        };
    q.distancePointLine = function() {
        if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            if (0 === b.length) throw new K("Line array must contain at least one vertex");
            for (var c = a.distance(b[0]), d = 0; d < b.length - 1; d++) {
                var e = q.distancePointLine(a, b[d], b[d + 1]);
                e < c && (c = e)
            }
            return c
        }
        if (3 === arguments.length) {
            a = arguments[0];
            b = arguments[1];
            c = arguments[2];
            if (b.x === c.x && b.y === c.y) return a.distance(b);
            d = (c.x - b.x) * (c.x - b.x) + (c.y - b.y) * (c.y - b.y);
            e = ((a.x - b.x) * (c.x - b.x) +
                (a.y - b.y) * (c.y - b.y)) / d;
            return 0 >= e ? a.distance(b) : 1 <= e ? a.distance(c) : Math.abs(((b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)) / d) * Math.sqrt(d)
        }
    };
    q.isOnLine = function(a, b) {
        for (var c = new ia, d = 1; d < b.length; d++)
            if (c.computeIntersection(a, b[d - 1], b[d]), c.hasIntersection()) return !0;
        return !1
    };
    q.CLOCKWISE = -1;
    q.RIGHT = q.CLOCKWISE;
    q.COUNTERCLOCKWISE = 1;
    q.LEFT = q.COUNTERCLOCKWISE;
    q.COLLINEAR = 0;
    q.STRAIGHT = q.COLLINEAR;
    g(A.prototype, {
        minX: function() {
            return Math.min(this.p0.x, this.p1.x)
        },
        orientationIndex: function(a) {
            if (a instanceof A) {
                var b = q.orientationIndex(this.p0, this.p1, a.p0);
                a = q.orientationIndex(this.p0, this.p1, a.p1);
                return 0 <= b && 0 <= a ? Math.max(b, a) : 0 >= b && 0 >= a ? Math.max(b, a) : 0
            }
            if (a instanceof k) return q.orientationIndex(this.p0, this.p1, a)
        },
        toGeometry: function(a) {
            return a.createLineString([this.p0, this.p1])
        },
        isVertical: function() {
            return this.p0.x === this.p1.x
        },
        equals: function(a) {
            return a instanceof A ? this.p0.equals(a.p0) && this.p1.equals(a.p1) : !1
        },
        intersection: function(a) {
            var b = new ia;
            return b.computeIntersection(this.p0, this.p1,
                a.p0, a.p1), b.hasIntersection() ? b.getIntersection(0) : null
        },
        project: function(a) {
            if (a instanceof k) {
                if (a.equals(this.p0) || a.equals(this.p1)) return new k(a);
                var b = this.projectionFactor(a),
                    c = new k;
                return c.x = this.p0.x + b * (this.p1.x - this.p0.x), c.y = this.p0.y + b * (this.p1.y - this.p0.y), c
            }
            if (a instanceof A) {
                var d = this.projectionFactor(a.p0),
                    b = this.projectionFactor(a.p1);
                if (1 <= d && 1 <= b || 0 >= d && 0 >= b) return null;
                c = this.project(a.p0);
                0 > d && (c = this.p0);
                1 < d && (c = this.p1);
                a = this.project(a.p1);
                return 0 > b && (a = this.p0), 1 < b &&
                    (a = this.p1), new A(c, a)
            }
        },
        normalize: function() {
            0 > this.p1.compareTo(this.p0) && this.reverse()
        },
        angle: function() {
            return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)
        },
        getCoordinate: function(a) {
            return 0 === a ? this.p0 : this.p1
        },
        distancePerpendicular: function(a) {
            return q.distancePointLinePerpendicular(a, this.p0, this.p1)
        },
        minY: function() {
            return Math.min(this.p0.y, this.p1.y)
        },
        midPoint: function() {
            return A.midPoint(this.p0, this.p1)
        },
        projectionFactor: function(a) {
            if (a.equals(this.p0)) return 0;
            if (a.equals(this.p1)) return 1;
            var b = this.p1.x - this.p0.x,
                c = this.p1.y - this.p0.y,
                d = b * b + c * c;
            return 0 >= d ? v.NaN : ((a.x - this.p0.x) * b + (a.y - this.p0.y) * c) / d
        },
        closestPoints: function(a) {
            var b = this.intersection(a);
            if (null !== b) return [b, b];
            var b = Array(2).fill(null),
                c = v.MAX_VALUE,
                d = null,
                e = this.closestPoint(a.p0),
                c = e.distance(a.p0);
            b[0] = e;
            b[1] = a.p0;
            e = this.closestPoint(a.p1);
            (d = e.distance(a.p1)) < c && (c = d, b[0] = e, b[1] = a.p1);
            e = a.closestPoint(this.p0);
            (d = e.distance(this.p0)) < c && (c = d, b[0] = this.p0, b[1] = e);
            a = a.closestPoint(this.p1);
            return d = a.distance(this.p1),
                d < c && (b[0] = this.p1, b[1] = a), b
        },
        closestPoint: function(a) {
            var b = this.projectionFactor(a);
            return 0 < b && 1 > b ? this.project(a) : this.p0.distance(a) < this.p1.distance(a) ? this.p0 : this.p1
        },
        maxX: function() {
            return Math.max(this.p0.x, this.p1.x)
        },
        getLength: function() {
            return this.p0.distance(this.p1)
        },
        compareTo: function(a) {
            var b = this.p0.compareTo(a.p0);
            return 0 !== b ? b : this.p1.compareTo(a.p1)
        },
        reverse: function() {
            var a = this.p0;
            this.p0 = this.p1;
            this.p1 = a
        },
        equalsTopo: function(a) {
            return this.p0.equals(a.p0) && this.p1.equals(a.p1) ||
                this.p0.equals(a.p1) && this.p1.equals(a.p0)
        },
        lineIntersection: function(a) {
            try {
                return Ha.intersection(this.p0, this.p1, a.p0, a.p1)
            } catch (b) {
                if (!(b instanceof xb)) throw b;
            }
            return null
        },
        maxY: function() {
            return Math.max(this.p0.y, this.p1.y)
        },
        pointAlongOffset: function(a, b) {
            var c = this.p0.x + a * (this.p1.x - this.p0.x),
                d = this.p0.y + a * (this.p1.y - this.p0.y),
                e = this.p1.x - this.p0.x,
                f = this.p1.y - this.p0.y,
                g = Math.sqrt(e * e + f * f),
                h = 0,
                l = 0;
            if (0 !== b) {
                if (0 >= g) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
                h = b * e / g;
                l = b * f / g
            }
            return new k(c - l, d + h)
        },
        setCoordinates: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.setCoordinates(a.p0, a.p1)
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                this.p0.x = a.x;
                this.p0.y = a.y;
                this.p1.x = b.x;
                this.p1.y = b.y
            }
        },
        segmentFraction: function(a) {
            a = this.projectionFactor(a);
            return 0 > a ? a = 0 : (1 < a || v.isNaN(a)) && (a = 1), a
        },
        toString: function() {
            return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")"
        },
        isHorizontal: function() {
            return this.p0.y ===
                this.p1.y
        },
        distance: function(a) {
            if (a instanceof A) return q.distanceLineLine(this.p0, this.p1, a.p0, a.p1);
            if (a instanceof k) return q.distancePointLine(a, this.p0, this.p1)
        },
        pointAlong: function(a) {
            var b = new k;
            return b.x = this.p0.x + a * (this.p1.x - this.p0.x), b.y = this.p0.y + a * (this.p1.y - this.p0.y), b
        },
        hashCode: function() {
            var a = java.lang.Double.doubleToLongBits(this.p0.x),
                a = a ^ 31 * java.lang.Double.doubleToLongBits(this.p0.y),
                a = Math.trunc(a) ^ Math.trunc(a >> 32),
                b = java.lang.Double.doubleToLongBits(this.p1.x);
            return b ^=
                31 * java.lang.Double.doubleToLongBits(this.p1.y), a ^ Math.trunc(b) ^ Math.trunc(b >> 32)
        },
        interfaces_: function() {
            return [Aa, Ba]
        },
        getClass: function() {
            return A
        }
    });
    A.midPoint = function(a, b) {
        return new k((a.x + b.x) / 2, (a.y + b.y) / 2)
    };
    A.serialVersionUID = 0x2d2172135f411c00;
    g(N.prototype, {
        isIntersects: function() {
            return !this.isDisjoint()
        },
        isCovers: function() {
            return (N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) || N.isTrue(this.matrix[h.INTERIOR][h.BOUNDARY]) || N.isTrue(this.matrix[h.BOUNDARY][h.INTERIOR]) || N.isTrue(this.matrix[h.BOUNDARY][h.BOUNDARY])) &&
                this.matrix[h.EXTERIOR][h.INTERIOR] === n.FALSE && this.matrix[h.EXTERIOR][h.BOUNDARY] === n.FALSE
        },
        isCoveredBy: function() {
            return (N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) || N.isTrue(this.matrix[h.INTERIOR][h.BOUNDARY]) || N.isTrue(this.matrix[h.BOUNDARY][h.INTERIOR]) || N.isTrue(this.matrix[h.BOUNDARY][h.BOUNDARY])) && this.matrix[h.INTERIOR][h.EXTERIOR] === n.FALSE && this.matrix[h.BOUNDARY][h.EXTERIOR] === n.FALSE
        },
        set: function() {
            if (1 === arguments.length)
                for (var a = arguments[0], b = 0; b < a.length; b++) this.matrix[Math.trunc(b /
                    3)][b % 3] = n.toDimensionValue(a.charAt(b));
            else 3 === arguments.length && (this.matrix[arguments[0]][arguments[1]] = arguments[2])
        },
        isContains: function() {
            return N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) && this.matrix[h.EXTERIOR][h.INTERIOR] === n.FALSE && this.matrix[h.EXTERIOR][h.BOUNDARY] === n.FALSE
        },
        setAtLeast: function() {
            if (1 === arguments.length)
                for (var a = arguments[0], b = 0; b < a.length; b++) this.setAtLeast(Math.trunc(b / 3), b % 3, n.toDimensionValue(a.charAt(b)));
            else if (3 === arguments.length) {
                var a = arguments[0],
                    b =
                    arguments[1],
                    c = arguments[2];
                this.matrix[a][b] < c && (this.matrix[a][b] = c)
            }
        },
        setAtLeastIfValid: function(a, b, c) {
            0 <= a && 0 <= b && this.setAtLeast(a, b, c)
        },
        isWithin: function() {
            return N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) && this.matrix[h.INTERIOR][h.EXTERIOR] === n.FALSE && this.matrix[h.BOUNDARY][h.EXTERIOR] === n.FALSE
        },
        isTouches: function(a, b) {
            return a > b ? this.isTouches(b, a) : (a === n.A && b === n.A || a === n.L && b === n.L || a === n.L && b === n.A || a === n.P && b === n.A || a === n.P && b === n.L) && this.matrix[h.INTERIOR][h.INTERIOR] === n.FALSE &&
                (N.isTrue(this.matrix[h.INTERIOR][h.BOUNDARY]) || N.isTrue(this.matrix[h.BOUNDARY][h.INTERIOR]) || N.isTrue(this.matrix[h.BOUNDARY][h.BOUNDARY]))
        },
        isOverlaps: function(a, b) {
            return a === n.P && b === n.P || a === n.A && b === n.A ? N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) && N.isTrue(this.matrix[h.INTERIOR][h.EXTERIOR]) && N.isTrue(this.matrix[h.EXTERIOR][h.INTERIOR]) : a === n.L && b === n.L && 1 === this.matrix[h.INTERIOR][h.INTERIOR] && N.isTrue(this.matrix[h.INTERIOR][h.EXTERIOR]) && N.isTrue(this.matrix[h.EXTERIOR][h.INTERIOR])
        },
        isEquals: function(a, b) {
            return a === b && N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) && this.matrix[h.INTERIOR][h.EXTERIOR] === n.FALSE && this.matrix[h.BOUNDARY][h.EXTERIOR] === n.FALSE && this.matrix[h.EXTERIOR][h.INTERIOR] === n.FALSE && this.matrix[h.EXTERIOR][h.BOUNDARY] === n.FALSE
        },
        toString: function() {
            for (var a = new Ya("123456789"), b = 0; 3 > b; b++)
                for (var c = 0; 3 > c; c++) a.setCharAt(3 * b + c, n.toDimensionSymbol(this.matrix[b][c]));
            return a.toString()
        },
        setAll: function(a) {
            for (var b = 0; 3 > b; b++)
                for (var c = 0; 3 > c; c++) this.matrix[b][c] =
                    a
        },
        get: function(a, b) {
            return this.matrix[a][b]
        },
        transpose: function() {
            var a = this.matrix[1][0];
            return this.matrix[1][0] = this.matrix[0][1], this.matrix[0][1] = a, a = this.matrix[2][0], this.matrix[2][0] = this.matrix[0][2], this.matrix[0][2] = a, a = this.matrix[2][1], this.matrix[2][1] = this.matrix[1][2], this.matrix[1][2] = a, this
        },
        matches: function(a) {
            if (9 !== a.length) throw new K("Should be length 9: " + a);
            for (var b = 0; 3 > b; b++)
                for (var c = 0; 3 > c; c++)
                    if (!N.matches(this.matrix[b][c], a.charAt(3 * b + c))) return !1;
            return !0
        },
        add: function(a) {
            for (var b =
                    0; 3 > b; b++)
                for (var c = 0; 3 > c; c++) this.setAtLeast(b, c, a.get(b, c))
        },
        isDisjoint: function() {
            return this.matrix[h.INTERIOR][h.INTERIOR] === n.FALSE && this.matrix[h.INTERIOR][h.BOUNDARY] === n.FALSE && this.matrix[h.BOUNDARY][h.INTERIOR] === n.FALSE && this.matrix[h.BOUNDARY][h.BOUNDARY] === n.FALSE
        },
        isCrosses: function(a, b) {
            return a === n.P && b === n.L || a === n.P && b === n.A || a === n.L && b === n.A ? N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) && N.isTrue(this.matrix[h.INTERIOR][h.EXTERIOR]) : a === n.L && b === n.P || a === n.A && b === n.P || a === n.A &&
                b === n.L ? N.isTrue(this.matrix[h.INTERIOR][h.INTERIOR]) && N.isTrue(this.matrix[h.EXTERIOR][h.INTERIOR]) : a === n.L && b === n.L && 0 === this.matrix[h.INTERIOR][h.INTERIOR]
        },
        interfaces_: function() {
            return [gd]
        },
        getClass: function() {
            return N
        }
    });
    N.matches = function(a, b) {
        if (Number.isInteger(a) && "string" == typeof b) return b === n.SYM_DONTCARE || b === n.SYM_TRUE && (0 <= a || a === n.TRUE) || b === n.SYM_FALSE && a === n.FALSE || b === n.SYM_P && a === n.P || b === n.SYM_L && a === n.L || b === n.SYM_A && a === n.A;
        if ("string" == typeof a && "string" == typeof b) return (new N(a)).matches(b)
    };
    N.isTrue = function(a) {
        return 0 <= a || a === n.TRUE
    };
    var Dg = Object.freeze({
        Coordinate: k,
        CoordinateList: Z,
        Envelope: y,
        LineSegment: A,
        GeometryFactory: E,
        Geometry: r,
        Point: W,
        LineString: C,
        LinearRing: aa,
        Polygon: O,
        GeometryCollection: F,
        MultiPoint: Ia,
        MultiLineString: wa,
        MultiPolygon: na,
        Dimension: n,
        IntersectionMatrix: N,
        PrecisionModel: L
    });
    g(Db.prototype, {
        addPoint: function(a) {
            this.ptCount += 1;
            this.ptCentSum.x += a.x;
            this.ptCentSum.y += a.y
        },
        setBasePoint: function(a) {
            null === this.areaBasePt && (this.areaBasePt = a)
        },
        addLineSegments: function(a) {
            for (var b =
                    0, c = 0; c < a.length - 1; c++) {
                var d = a[c].distance(a[c + 1]);
                0 !== d && (b += d, this.lineCentSum.x += (a[c].x + a[c + 1].x) / 2 * d, this.lineCentSum.y += (a[c].y + a[c + 1].y) / 2 * d)
            }
            this.totalLength += b;
            0 === b && 0 < a.length && this.addPoint(a[0])
        },
        addHole: function(a) {
            for (var b = q.isCCW(a), c = 0; c < a.length - 1; c++) this.addTriangle(this.areaBasePt, a[c], a[c + 1], b);
            this.addLineSegments(a)
        },
        getCentroid: function() {
            var a = new k;
            if (0 < Math.abs(this.areasum2)) a.x = this.cg3.x / 3 / this.areasum2, a.y = this.cg3.y / 3 / this.areasum2;
            else if (0 < this.totalLength) a.x =
                this.lineCentSum.x / this.totalLength, a.y = this.lineCentSum.y / this.totalLength;
            else {
                if (!(0 < this.ptCount)) return null;
                a.x = this.ptCentSum.x / this.ptCount;
                a.y = this.ptCentSum.y / this.ptCount
            }
            return a
        },
        addShell: function(a) {
            0 < a.length && this.setBasePoint(a[0]);
            for (var b = !q.isCCW(a), c = 0; c < a.length - 1; c++) this.addTriangle(this.areaBasePt, a[c], a[c + 1], b);
            this.addLineSegments(a)
        },
        addTriangle: function(a, b, c, d) {
            d = d ? 1 : -1;
            Db.centroid3(a, b, c, this.triangleCent3);
            a = Db.area2(a, b, c);
            this.cg3.x += d * a * this.triangleCent3.x;
            this.cg3.y +=
                d * a * this.triangleCent3.y;
            this.areasum2 += d * a
        },
        add: function(a) {
            if (a instanceof O) {
                this.addShell(a.getExteriorRing().getCoordinates());
                for (var b = 0; b < a.getNumInteriorRing(); b++) this.addHole(a.getInteriorRingN(b).getCoordinates())
            } else if (a instanceof r) {
                if (a.isEmpty()) return null;
                if (a instanceof W) this.addPoint(a.getCoordinate());
                else if (a instanceof C) this.addLineSegments(a.getCoordinates());
                else if (a instanceof O) this.add(a);
                else if (a instanceof F)
                    for (b = 0; b < a.getNumGeometries(); b++) this.add(a.getGeometryN(b))
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Db
        }
    });
    Db.area2 = function(a, b, c) {
        return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)
    };
    Db.centroid3 = function(a, b, c, d) {
        return d.x = a.x + b.x + c.x, d.y = a.y + b.y + c.y, null
    };
    Db.getCentroid = function(a) {
        return (new Db(a)).getCentroid()
    };
    le.prototype = Error();
    le.prototype.name = "EmptyStackException";
    xa.prototype = new ga;
    xa.prototype.add = function(a) {
        return this.array_.push(a), !0
    };
    xa.prototype.get = function(a) {
        if (0 > a || a >= this.size()) throw new IndexOutOfBoundsException;
        return this.array_[a]
    };
    xa.prototype.push = function(a) {
        return this.array_.push(a), a
    };
    xa.prototype.pop = function(a) {
        if (0 === this.array_.length) throw new le;
        return this.array_.pop()
    };
    xa.prototype.peek = function() {
        if (0 === this.array_.length) throw new le;
        return this.array_[this.array_.length - 1]
    };
    xa.prototype.empty = function() {
        return 0 === this.array_.length
    };
    xa.prototype.isEmpty = function() {
        return this.empty()
    };
    xa.prototype.search = function(a) {
        return this.array_.indexOf(a)
    };
    xa.prototype.size = function() {
        return this.array_.length
    };
    xa.prototype.toArray = function() {
        for (var a = [], b = 0, c = this.array_.length; b < c; b++) a.push(this.array_[b]);
        return a
    };
    g(Jc.prototype, {
        filter: function(a) {
            this.treeSet.contains(a) || (this.list.add(a), this.treeSet.add(a))
        },
        getCoordinates: function() {
            var a = Array(this.list.size()).fill(null);
            return this.list.toArray(a)
        },
        interfaces_: function() {
            return [Yb]
        },
        getClass: function() {
            return Jc
        }
    });
    Jc.filterCoordinates = function(a) {
        for (var b = new Jc, c = 0; c < a.length; c++) b.filter(a[c]);
        return b.getCoordinates()
    };
    g(Eb.prototype, {
        preSort: function(a) {
            for (var b = null, c = 1; c < a.length; c++)(a[c].y < a[0].y || a[c].y === a[0].y && a[c].x < a[0].x) && (b = a[0], a[0] = a[c], a[c] = b);
            return zb.sort(a, 1, a.length, new Kc(a[0])), a
        },
        computeOctRing: function(a) {
            a = this.computeOctPts(a);
            var b = new Z;
            return b.add(a, !1), 3 > b.size() ? null : (b.closeRing(), b.toCoordinateArray())
        },
        lineOrPolygon: function(a) {
            if (a = this.cleanRing(a), 3 === a.length) return this.geomFactory.createLineString([a[0], a[1]]);
            a = this.geomFactory.createLinearRing(a);
            return this.geomFactory.createPolygon(a,
                null)
        },
        cleanRing: function(a) {
            t.equals(a[0], a[a.length - 1]);
            for (var b = new l, c = null, d = 0; d <= a.length - 2; d++) {
                var e = a[d],
                    f = a[d + 1];
                e.equals(f) || null !== c && this.isBetween(c, e, f) || (b.add(e), c = e)
            }
            b.add(a[a.length - 1]);
            a = Array(b.size()).fill(null);
            return b.toArray(a)
        },
        isBetween: function(a, b, c) {
            return 0 !== q.computeOrientation(a, b, c) ? !1 : a.x !== c.x && (a.x <= b.x && b.x <= c.x || c.x <= b.x && b.x <= a.x) || a.y !== c.y && (a.y <= b.y && b.y <= c.y || c.y <= b.y && b.y <= a.y) ? !0 : !1
        },
        reduce: function(a) {
            var b = this.computeOctRing(a);
            if (null === b) return a;
            for (var c = new va, d = 0; d < b.length; d++) c.add(b[d]);
            for (d = 0; d < a.length; d++) q.isPointInRing(a[d], b) || c.add(a[d]);
            a = z.toCoordinateArray(c);
            return 3 > a.length ? this.padArray3(a) : a
        },
        getConvexHull: function() {
            if (0 === this.inputPts.length) return this.geomFactory.createGeometryCollection(null);
            if (1 === this.inputPts.length) return this.geomFactory.createPoint(this.inputPts[0]);
            if (2 === this.inputPts.length) return this.geomFactory.createLineString(this.inputPts);
            var a = this.inputPts;
            50 < this.inputPts.length && (a = this.reduce(this.inputPts));
            a = this.preSort(a);
            a = this.grahamScan(a);
            a = this.toCoordinateArray(a);
            return this.lineOrPolygon(a)
        },
        padArray3: function(a) {
            for (var b = Array(3).fill(null), c = 0; c < b.length; c++) c < a.length ? b[c] = a[c] : b[c] = a[0];
            return b
        },
        computeOctPts: function(a) {
            for (var b = Array(8).fill(null), c = 0; c < b.length; c++) b[c] = a[0];
            for (c = 1; c < a.length; c++) a[c].x < b[0].x && (b[0] = a[c]), a[c].x - a[c].y < b[1].x - b[1].y && (b[1] = a[c]), a[c].y > b[2].y && (b[2] = a[c]), a[c].x + a[c].y > b[3].x + b[3].y && (b[3] = a[c]), a[c].x > b[4].x && (b[4] = a[c]), a[c].x - a[c].y > b[5].x -
                b[5].y && (b[5] = a[c]), a[c].y < b[6].y && (b[6] = a[c]), a[c].x + a[c].y < b[7].x + b[7].y && (b[7] = a[c]);
            return b
        },
        toCoordinateArray: function(a) {
            for (var b = Array(a.size()).fill(null), c = 0; c < a.size(); c++) {
                var d = a.get(c);
                b[c] = d
            }
            return b
        },
        grahamScan: function(a) {
            var b = null,
                c = new xa;
            c.push(a[0]);
            c.push(a[1]);
            c.push(a[2]);
            for (var d = 3; d < a.length; d++) {
                for (b = c.pop(); !c.empty() && 0 < q.computeOrientation(c.peek(), b, a[d]);) b = c.pop();
                c.push(b);
                c.push(a[d])
            }
            return c.push(a[0]), c
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Eb
        }
    });
    Eb.extractCoordinates = function(a) {
        var b = new Jc;
        return a.apply(b), b.getCoordinates()
    };
    g(Kc.prototype, {
        compare: function(a, b) {
            return Kc.polarCompare(this.origin, a, b)
        },
        interfaces_: function() {
            return [Wb]
        },
        getClass: function() {
            return Kc
        }
    });
    Kc.polarCompare = function(a, b, c) {
        var d = b.x - a.x,
            e = b.y - a.y,
            f = c.x - a.x,
            g = c.y - a.y;
        a = q.computeOrientation(a, b, c);
        if (a === q.COUNTERCLOCKWISE) return 1;
        if (a === q.CLOCKWISE) return -1;
        d = d * d + e * e;
        f = f * f + g * g;
        return d < f ? -1 : d > f ? 1 : 0
    };
    Eb.RadialComparator = Kc;
    g(Ca.prototype, {
        transformPoint: function(a,
            b) {
            return this.factory.createPoint(this.transformCoordinates(a.getCoordinateSequence(), a))
        },
        transformPolygon: function(a, b) {
            var c = !0,
                d = this.transformLinearRing(a.getExteriorRing(), a);
            null !== d && d instanceof aa && !d.isEmpty() || (c = !1);
            for (var e = new l, f = 0; f < a.getNumInteriorRing(); f++) {
                var g = this.transformLinearRing(a.getInteriorRingN(f), a);
                null === g || g.isEmpty() || (g instanceof aa || (c = !1), e.add(g))
            }
            if (c) return this.factory.createPolygon(d, e.toArray([]));
            c = new l;
            return null !== d && c.add(d), c.addAll(e), this.factory.buildGeometry(c)
        },
        createCoordinateSequence: function(a) {
            return this.factory.getCoordinateSequenceFactory().create(a)
        },
        getInputGeometry: function() {
            return this.inputGeom
        },
        transformMultiLineString: function(a, b) {
            for (var c = new l, d = 0; d < a.getNumGeometries(); d++) {
                var e = this.transformLineString(a.getGeometryN(d), a);
                null !== e && (e.isEmpty() || c.add(e))
            }
            return this.factory.buildGeometry(c)
        },
        transformCoordinates: function(a, b) {
            return this.copy(a)
        },
        transformLineString: function(a, b) {
            return this.factory.createLineString(this.transformCoordinates(a.getCoordinateSequence(),
                a))
        },
        transformMultiPoint: function(a, b) {
            for (var c = new l, d = 0; d < a.getNumGeometries(); d++) {
                var e = this.transformPoint(a.getGeometryN(d), a);
                null !== e && (e.isEmpty() || c.add(e))
            }
            return this.factory.buildGeometry(c)
        },
        transformMultiPolygon: function(a, b) {
            for (var c = new l, d = 0; d < a.getNumGeometries(); d++) {
                var e = this.transformPolygon(a.getGeometryN(d), a);
                null !== e && (e.isEmpty() || c.add(e))
            }
            return this.factory.buildGeometry(c)
        },
        copy: function(a) {
            return a.copy()
        },
        transformGeometryCollection: function(a, b) {
            for (var c = new l,
                    d = 0; d < a.getNumGeometries(); d++) {
                var e = this.transform(a.getGeometryN(d));
                null !== e && (this.pruneEmptyGeometry && e.isEmpty() || c.add(e))
            }
            return this.preserveGeometryCollectionType ? this.factory.createGeometryCollection(E.toGeometryArray(c)) : this.factory.buildGeometry(c)
        },
        transform: function(a) {
            if (this.inputGeom = a, this.factory = a.getFactory(), a instanceof W) return this.transformPoint(a, null);
            if (a instanceof Ia) return this.transformMultiPoint(a, null);
            if (a instanceof aa) return this.transformLinearRing(a, null);
            if (a instanceof C) return this.transformLineString(a, null);
            if (a instanceof wa) return this.transformMultiLineString(a, null);
            if (a instanceof O) return this.transformPolygon(a, null);
            if (a instanceof na) return this.transformMultiPolygon(a, null);
            if (a instanceof F) return this.transformGeometryCollection(a, null);
            throw new K("Unknown Geometry subtype: " + a.getClass().getName());
        },
        transformLinearRing: function(a, b) {
            var c = this.transformCoordinates(a.getCoordinateSequence(), a);
            if (null === c) return this.factory.createLinearRing(null);
            var d = c.size();
            return 0 < d && 4 > d && !this.preserveType ? this.factory.createLineString(c) : this.factory.createLinearRing(c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ca
        }
    });
    g(Lc.prototype, {
        snapVertices: function(a, b) {
            for (var c = this._isClosed ? a.size() - 1 : a.size(), d = 0; d < c; d++) {
                var e = a.get(d),
                    e = this.findSnapForVertex(e, b);
                null !== e && (a.set(d, new k(e)), 0 === d && this._isClosed && a.set(a.size() - 1, new k(e)))
            }
        },
        findSnapForVertex: function(a, b) {
            for (var c = 0; c < b.length && !a.equals2D(b[c]); c++)
                if (a.distance(b[c]) <
                    this.snapTolerance) return b[c];
            return null
        },
        snapTo: function(a) {
            var b = new Z(this.srcPts);
            return this.snapVertices(b, a), this.snapSegments(b, a), b.toCoordinateArray()
        },
        snapSegments: function(a, b) {
            if (0 === b.length) return null;
            var c = b.length;
            b[0].equals2D(b[b.length - 1]) && (c = b.length - 1);
            for (var d = 0; d < c; d++) {
                var e = b[d],
                    f = this.findSegmentIndexToSnap(e, a);
                0 <= f && a.add(f + 1, new k(e), !1)
            }
        },
        findSegmentIndexToSnap: function(a, b) {
            for (var c = v.MAX_VALUE, d = -1, e = 0; e < b.size() - 1; e++) {
                if (this.seg.p0 = b.get(e), this.seg.p1 = b.get(e +
                        1), this.seg.p0.equals2D(a) || this.seg.p1.equals2D(a)) {
                    if (this.allowSnappingToSourceVertices) continue;
                    return -1
                }
                var f = this.seg.distance(a);
                f < this.snapTolerance && f < c && (c = f, d = e)
            }
            return d
        },
        setAllowSnappingToSourceVertices: function(a) {
            this.allowSnappingToSourceVertices = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Lc
        }
    });
    Lc.isClosed = function(a) {
        return !(1 >= a.length) && a[0].equals2D(a[a.length - 1])
    };
    g(ya.prototype, {
        snapTo: function(a, b) {
            return (new ld(b, this.extractTargetCoordinates(a))).transform(this.srcGeom)
        },
        snapToSelf: function(a, b) {
            var c = this.extractTargetCoordinates(this.srcGeom),
                d = c = (new ld(a, c, !0)).transform(this.srcGeom);
            return b && u(d, Bb) && (d = c.buffer(0)), d
        },
        computeSnapTolerance: function(a) {
            return this.computeMinimumSegmentLength(a) / 10
        },
        extractTargetCoordinates: function(a) {
            var b = new va;
            a = a.getCoordinates();
            for (var c = 0; c < a.length; c++) b.add(a[c]);
            return b.toArray([].fill(null))
        },
        computeMinimumSegmentLength: function(a) {
            for (var b = v.MAX_VALUE, c = 0; c < a.length - 1; c++) {
                var d = a[c].distance(a[c + 1]);
                d < b && (b =
                    d)
            }
            return b
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ya
        }
    });
    ya.snap = function(a, b, c) {
        var d = Array(2).fill(null);
        a = new ya(a);
        d[0] = a.snapTo(b, c);
        b = new ya(b);
        return d[1] = b.snapTo(d[0], c), d
    };
    ya.computeOverlaySnapTolerance = function() {
        if (1 === arguments.length) {
            var a = arguments[0],
                b = ya.computeSizeBasedSnapTolerance(a),
                a = a.getPrecisionModel();
            a.getType() === L.FIXED && (a = 1 / a.getScale() * 2 / 1.415, a > b && (b = a));
            return b
        }
        if (2 === arguments.length) return b = arguments[1], Math.min(ya.computeOverlaySnapTolerance(arguments[0]),
            ya.computeOverlaySnapTolerance(b))
    };
    ya.computeSizeBasedSnapTolerance = function(a) {
        a = a.getEnvelopeInternal();
        return Math.min(a.getHeight(), a.getWidth()) * ya.SNAP_PRECISION_FACTOR
    };
    ya.snapToSelf = function(a, b, c) {
        return (new ya(a)).snapToSelf(b, c)
    };
    ya.SNAP_PRECISION_FACTOR = 1E-9;
    x(ld, Ca);
    g(ld.prototype, {
        snapLine: function(a, b) {
            var c = new Lc(a, this.snapTolerance);
            return c.setAllowSnappingToSourceVertices(this.isSelfSnap), c.snapTo(b)
        },
        transformCoordinates: function(a, b) {
            var c = a.toCoordinateArray(),
                c = this.snapLine(c,
                    this.snapPts);
            return this.factory.getCoordinateSequenceFactory().create(c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ld
        }
    });
    g(Ra.prototype, {
        getCommon: function() {
            return v.longBitsToDouble(this.commonBits)
        },
        add: function(a) {
            a = v.doubleToLongBits(a);
            return this.isFirst ? (this.commonBits = a, this.commonSignExp = Ra.signExpBits(this.commonBits), this.isFirst = !1, null) : Ra.signExpBits(a) !== this.commonSignExp ? (this.commonBits = 0, null) : (this.commonMantissaBitsCount = Ra.numCommonMostSigMantissaBits(this.commonBits,
                a), void(this.commonBits = Ra.zeroLowerBits(this.commonBits, 64 - (12 + this.commonMantissaBitsCount))))
        },
        toString: function() {
            if (1 === arguments.length) {
                var a = arguments[0],
                    b = v.longBitsToDouble(a),
                    a = "0000000000000000000000000000000000000000000000000000000000000000" + Long.toBinaryString(a),
                    a = a.substring(a.length - 64);
                return a.substring(0, 1) + "  " + a.substring(1, 12) + "(exp) " + a.substring(12) + " [ " + b + " ]"
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ra
        }
    });
    Ra.getBit = function(a, b) {
        return 0 != (a & 1 << b) ?
            1 : 0
    };
    Ra.signExpBits = function(a) {
        return a >> 52
    };
    Ra.zeroLowerBits = function(a, b) {
        return a & ~((1 << b) - 1)
    };
    Ra.numCommonMostSigMantissaBits = function(a, b) {
        for (var c = 0, d = 52; 0 <= d; d--) {
            if (Ra.getBit(a, d) !== Ra.getBit(b, d)) return c;
            c++
        }
        return 52
    };
    g(md.prototype, {
        addCommonBits: function(a) {
            var b = new nd(this.commonCoord);
            a.apply(b);
            a.geometryChanged()
        },
        removeCommonBits: function(a) {
            if (0 === this.commonCoord.x && 0 === this.commonCoord.y) return a;
            var b = new k(this.commonCoord);
            b.x = -b.x;
            b.y = -b.y;
            b = new nd(b);
            return a.apply(b),
                a.geometryChanged(), a
        },
        getCommonCoordinate: function() {
            return this.commonCoord
        },
        add: function(a) {
            a.apply(this.ccFilter);
            this.commonCoord = this.ccFilter.getCommonCoordinate()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return md
        }
    });
    g(me.prototype, {
        filter: function(a) {
            this.commonBitsX.add(a.x);
            this.commonBitsY.add(a.y)
        },
        getCommonCoordinate: function() {
            return new k(this.commonBitsX.getCommon(), this.commonBitsY.getCommon())
        },
        interfaces_: function() {
            return [Yb]
        },
        getClass: function() {
            return me
        }
    });
    g(nd.prototype, {
        filter: function(a, b) {
            var c = a.getOrdinate(b, 0) + this.trans.x,
                d = a.getOrdinate(b, 1) + this.trans.y;
            a.setOrdinate(b, 0, c);
            a.setOrdinate(b, 1, d)
        },
        isDone: function() {
            return !1
        },
        isGeometryChanged: function() {
            return !0
        },
        interfaces_: function() {
            return [qc]
        },
        getClass: function() {
            return nd
        }
    });
    md.CommonCoordinateFilter = me;
    md.Translater = nd;
    g(tc.prototype, {
        next: function() {
            if (this.atStart) return this.atStart = !1, tc.isAtomic(this.parent) && this.index++, this.parent;
            if (null !== this.subcollectionIterator) {
                if (this.subcollectionIterator.hasNext()) return this.subcollectionIterator.next();
                this.subcollectionIterator = null
            }
            if (this.index >= this.max) throw new Ic;
            var a = this.parent.getGeometryN(this.index++);
            return a instanceof F ? (this.subcollectionIterator = new tc(a), this.subcollectionIterator.next()) : a
        },
        remove: function() {
            throw new UnsupportedOperationException(this.getClass().getName());
        },
        hasNext: function() {
            if (this.atStart) return !0;
            if (null !== this.subcollectionIterator) {
                if (this.subcollectionIterator.hasNext()) return !0;
                this.subcollectionIterator = null
            }
            return !(this.index >= this.max)
        },
        interfaces_: function() {
            return [hd]
        },
        getClass: function() {
            return tc
        }
    });
    tc.isAtomic = function(a) {
        return !(a instanceof F)
    };
    g(uc.prototype, {
        locateInternal: function(a, b) {
            if (a instanceof k && b instanceof O) {
                if (b.isEmpty()) return h.EXTERIOR;
                var c = b.getExteriorRing(),
                    c = this.locateInPolygonRing(a, c);
                if (c === h.EXTERIOR) return h.EXTERIOR;
                if (c === h.BOUNDARY) return h.BOUNDARY;
                for (c = 0; c < b.getNumInteriorRing(); c++) {
                    var d = b.getInteriorRingN(c),
                        d = this.locateInPolygonRing(a, d);
                    if (d === h.INTERIOR) return h.EXTERIOR;
                    if (d === h.BOUNDARY) return h.BOUNDARY
                }
                return h.INTERIOR
            }
            if (a instanceof k && b instanceof C) {
                if (!b.getEnvelopeInternal().intersects(a)) return h.EXTERIOR;
                c = b.getCoordinates();
                return b.isClosed() || !a.equals(c[0]) && !a.equals(c[c.length - 1]) ? q.isOnLine(a, c) ? h.INTERIOR : h.EXTERIOR : h.BOUNDARY
            }
            if (a instanceof k && b instanceof W) return b.getCoordinate().equals2D(a) ? h.INTERIOR : h.EXTERIOR
        },
        locateInPolygonRing: function(a, b) {
            return b.getEnvelopeInternal().intersects(a) ? q.locatePointInRing(a, b.getCoordinates()) : h.EXTERIOR
        },
        intersects: function(a, b) {
            return this.locate(a, b) !== h.EXTERIOR
        },
        updateLocationInfo: function(a) {
            a === h.INTERIOR && (this.isIn = !0);
            a === h.BOUNDARY && this.numBoundaries++
        },
        computeLocation: function(a, b) {
            if (b instanceof W && this.updateLocationInfo(this.locateInternal(a, b)), b instanceof C) this.updateLocationInfo(this.locateInternal(a, b));
            else if (b instanceof O) this.updateLocationInfo(this.locateInternal(a, b));
            else if (b instanceof wa)
                for (var c = 0; c < b.getNumGeometries(); c++) {
                    var d = b.getGeometryN(c);
                    this.updateLocationInfo(this.locateInternal(a, d))
                } else if (b instanceof na)
                    for (c =
                        0; c < b.getNumGeometries(); c++) d = b.getGeometryN(c), this.updateLocationInfo(this.locateInternal(a, d));
                else if (b instanceof F)
                for (c = new tc(b); c.hasNext();) d = c.next(), d !== b && this.computeLocation(a, d)
        },
        locate: function(a, b) {
            return b.isEmpty() ? h.EXTERIOR : b instanceof C ? this.locateInternal(a, b) : b instanceof O ? this.locateInternal(a, b) : (this.isIn = !1, this.numBoundaries = 0, this.computeLocation(a, b), this.boundaryRule.isInBoundary(this.numBoundaries) ? h.BOUNDARY : 0 < this.numBoundaries || this.isIn ? h.INTERIOR : h.EXTERIOR)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return uc
        }
    });
    g(Mc.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Mc
        }
    });
    Mc.octant = function(a, b) {
        if ("number" == typeof a && "number" == typeof b) {
            if (0 === a && 0 === b) throw new K("Cannot compute the octant for point ( " + a + ", " + b + " )");
            var c = Math.abs(a),
                d = Math.abs(b);
            return 0 <= a ? 0 <= b ? c >= d ? 0 : 1 : c >= d ? 7 : 6 : 0 <= b ? c >= d ? 3 : 2 : c >= d ? 4 : 5
        }
        if (a instanceof k && b instanceof k) {
            c = b.x - a.x;
            d = b.y - a.y;
            if (0 === c && 0 === d) throw new K("Cannot compute the octant for two identical points " +
                a);
            return Mc.octant(c, d)
        }
    };
    g(od.prototype, {
        getCoordinates: function() {},
        size: function() {},
        getCoordinate: function(a) {},
        isClosed: function() {},
        setData: function(a) {},
        getData: function() {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return od
        }
    });
    g(yf.prototype, {
        getCoordinates: function() {
            return this.pts
        },
        size: function() {
            return this.pts.length
        },
        getCoordinate: function(a) {
            return this.pts[a]
        },
        isClosed: function() {
            return this.pts[0].equals(this.pts[this.pts.length - 1])
        },
        getSegmentOctant: function(a) {
            return a ===
                this.pts.length - 1 ? -1 : Mc.octant(this.getCoordinate(a), this.getCoordinate(a + 1))
        },
        setData: function(a) {
            this.data = a
        },
        getData: function() {
            return this.data
        },
        toString: function() {
            return ra.toLineString(new Za(this.pts))
        },
        interfaces_: function() {
            return [od]
        },
        getClass: function() {
            return yf
        }
    });
    g(ne.prototype, {
        getBounds: function() {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ne
        }
    });
    g(Fb.prototype, {
        getItem: function() {
            return this.item
        },
        getBounds: function() {
            return this.bounds
        },
        interfaces_: function() {
            return [ne,
                Ba
            ]
        },
        getClass: function() {
            return Fb
        }
    });
    g(zf.prototype, {
        poll: function() {
            if (this.isEmpty()) return null;
            var a = this.items.get(1);
            return this.items.set(1, this.items.get(this._size)), --this._size, this.reorder(1), a
        },
        size: function() {
            return this._size
        },
        reorder: function(a) {
            for (var b = null, c = this.items.get(a); 2 * a <= this._size && (b = 2 * a, b !== this._size && 0 > this.items.get(b + 1).compareTo(this.items.get(b)) && b++, 0 > this.items.get(b).compareTo(c)); a = b) this.items.set(a, this.items.get(b));
            this.items.set(a, c)
        },
        clear: function() {
            this._size =
                0;
            this.items.clear()
        },
        isEmpty: function() {
            return 0 === this._size
        },
        add: function(a) {
            this.items.add(null);
            var b = this._size += 1;
            for (this.items.set(0, a); 0 > a.compareTo(this.items.get(Math.trunc(b / 2))); b /= 2) this.items.set(b, this.items.get(Math.trunc(b / 2)));
            this.items.set(b, a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return zf
        }
    });
    g(Zb.prototype, {
        visitItem: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Zb
        }
    });
    g(oe.prototype, {
        insert: function(a, b) {},
        remove: function(a, b) {},
        query: function() {
            1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0], arguments[1])
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return oe
        }
    });
    g(za.prototype, {
        getLevel: function() {
            return this.level
        },
        size: function() {
            return this.childBoundables.size()
        },
        getChildBoundables: function() {
            return this.childBoundables
        },
        addChildBoundable: function(a) {
            t.isTrue(null === this.bounds);
            this.childBoundables.add(a)
        },
        isEmpty: function() {
            return this.childBoundables.isEmpty()
        },
        getBounds: function() {
            return null ===
                this.bounds && (this.bounds = this.computeBounds()), this.bounds
        },
        interfaces_: function() {
            return [ne, Ba]
        },
        getClass: function() {
            return za
        }
    });
    za.serialVersionUID = 0x5a1e55ec41369800;
    var vb = {
        reverseOrder: function() {
            return {
                compare: function(a, b) {
                    return b.compareTo(a)
                }
            }
        },
        min: function(a) {
            return vb.sort(a), a.get(0)
        },
        sort: function(a, b) {
            var c = a.toArray();
            b ? zb.sort(c, b) : zb.sort(c);
            for (var d = a.iterator(), e = 0, f = c.length; e < f; e++) d.next(), d.set(c[e])
        },
        singletonList: function(a) {
            var b = new l;
            return b.add(a), b
        }
    };
    g(Da.prototype, {
        expandToQueue: function(a, b) {
            var c = Da.isComposite(this.boundable1),
                d = Da.isComposite(this.boundable2);
            if (c && d) return Da.area(this.boundable1) > Da.area(this.boundable2) ? (this.expand(this.boundable1, this.boundable2, a, b), null) : (this.expand(this.boundable2, this.boundable1, a, b), null);
            if (c) return this.expand(this.boundable1, this.boundable2, a, b), null;
            if (d) return this.expand(this.boundable2, this.boundable1, a, b), null;
            throw new K("neither boundable is composite");
        },
        isLeaves: function() {
            return !(Da.isComposite(this.boundable1) ||
                Da.isComposite(this.boundable2))
        },
        compareTo: function(a) {
            return this._distance < a._distance ? -1 : this._distance > a._distance ? 1 : 0
        },
        expand: function(a, b, c, d) {
            for (a = a.getChildBoundables().iterator(); a.hasNext();) {
                var e = a.next(),
                    e = new Da(e, b, this.itemDistance);
                e.getDistance() < d && c.add(e)
            }
        },
        getBoundable: function(a) {
            return 0 === a ? this.boundable1 : this.boundable2
        },
        getDistance: function() {
            return this._distance
        },
        distance: function() {
            return this.isLeaves() ? this.itemDistance.distance(this.boundable1, this.boundable2) :
                this.boundable1.getBounds().distance(this.boundable2.getBounds())
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return Da
        }
    });
    Da.area = function(a) {
        return a.getBounds().getArea()
    };
    Da.isComposite = function(a) {
        return a instanceof za
    };
    g(ba.prototype, {
        getNodeCapacity: function() {
            return this.nodeCapacity
        },
        lastNode: function(a) {
            return a.get(a.size() - 1)
        },
        size: function() {
            if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this.root));
            if (1 === arguments.length) {
                for (var a = 0, b = arguments[0].getChildBoundables().iterator(); b.hasNext();) {
                    var c =
                        b.next();
                    c instanceof za ? a += this.size(c) : c instanceof Fb && (a += 1)
                }
                return a
            }
        },
        removeItem: function(a, b) {
            for (var c = null, d = a.getChildBoundables().iterator(); d.hasNext();) {
                var e = d.next();
                e instanceof Fb && e.getItem() === b && (c = e)
            }
            return null !== c && (a.getChildBoundables().remove(c), !0)
        },
        itemsTree: function() {
            if (0 === arguments.length) {
                this.build();
                var a = this.itemsTree(this.root);
                return null === a ? new l : a
            }
            if (1 === arguments.length) {
                for (var b = arguments[0], a = new l, b = b.getChildBoundables().iterator(); b.hasNext();) {
                    var c =
                        b.next();
                    c instanceof za ? (c = this.itemsTree(c), null !== c && a.add(c)) : c instanceof Fb ? a.add(c.getItem()) : t.shouldNeverReachHere()
                }
                return 0 >= a.size() ? null : a
            }
        },
        insert: function(a, b) {
            t.isTrue(!this.built, "Cannot insert items into an STR packed R-tree after it has been built.");
            this.itemBoundables.add(new Fb(a, b))
        },
        boundablesAtLevel: function() {
            if (1 === arguments.length) {
                var a = arguments[0],
                    b = new l;
                return this.boundablesAtLevel(a, this.root, b), b
            }
            if (3 === arguments.length) {
                var a = arguments[0],
                    c = arguments[1],
                    b = arguments[2];
                if (t.isTrue(-2 < a), c.getLevel() === a) return b.add(c), null;
                for (c = c.getChildBoundables().iterator(); c.hasNext();) {
                    var d = c.next();
                    d instanceof za ? this.boundablesAtLevel(a, d, b) : (t.isTrue(d instanceof Fb), -1 === a && b.add(d))
                }
                return null
            }
        },
        query: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.build();
                var b = new l;
                return this.isEmpty() ? b : (this.getIntersectsOp().intersects(this.root.getBounds(), a) && this.query(a, this.root, b), b)
            }
            if (2 === arguments.length) {
                a = arguments[0];
                b = arguments[1];
                if (this.build(),
                    this.isEmpty()) return null;
                this.getIntersectsOp().intersects(this.root.getBounds(), a) && this.query(a, this.root, b)
            } else if (3 === arguments.length)
                if (u(arguments[2], Zb) && arguments[0] instanceof Object && arguments[1] instanceof za)
                    for (var c = arguments[0], d = arguments[2], a = arguments[1].getChildBoundables(), b = 0; b < a.size(); b++) {
                        var e = a.get(b);
                        this.getIntersectsOp().intersects(e.getBounds(), c) && (e instanceof za ? this.query(c, e, d) : e instanceof Fb ? d.visitItem(e.getItem()) : t.shouldNeverReachHere())
                    } else if (u(arguments[2],
                            ga) && arguments[0] instanceof Object && arguments[1] instanceof za)
                        for (c = arguments[0], d = arguments[2], a = arguments[1].getChildBoundables(), b = 0; b < a.size(); b++) e = a.get(b), this.getIntersectsOp().intersects(e.getBounds(), c) && (e instanceof za ? this.query(c, e, d) : e instanceof Fb ? d.add(e.getItem()) : t.shouldNeverReachHere())
        },
        build: function() {
            if (this.built) return null;
            this.root = this.itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this.itemBoundables, -1);
            this.itemBoundables = null;
            this.built = !0
        },
        getRoot: function() {
            return this.build(), this.root
        },
        remove: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                return this.build(), !!this.getIntersectsOp().intersects(this.root.getBounds(), a) && this.remove(a, this.root, b)
            }
            if (3 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = arguments[2],
                    d = this.removeItem(b, c);
                if (d) return !0;
                for (var e = null, f = b.getChildBoundables().iterator(); f.hasNext();) {
                    var g = f.next();
                    if (this.getIntersectsOp().intersects(g.getBounds(), a) && g instanceof za && (d =
                            this.remove(a, g, c))) {
                        e = g;
                        break
                    }
                }
                return null !== e && e.getChildBoundables().isEmpty() && b.getChildBoundables().remove(e), d
            }
        },
        createHigherLevels: function(a, b) {
            t.isTrue(!a.isEmpty());
            var c = this.createParentBoundables(a, b + 1);
            return 1 === c.size() ? c.get(0) : this.createHigherLevels(c, b + 1)
        },
        depth: function() {
            if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this.root));
            if (1 === arguments.length) {
                for (var a = 0, b = arguments[0].getChildBoundables().iterator(); b.hasNext();) {
                    var c = b.next();
                    c instanceof
                    za && (c = this.depth(c), c > a && (a = c))
                }
                return a + 1
            }
        },
        createParentBoundables: function(a, b) {
            t.isTrue(!a.isEmpty());
            var c = new l;
            c.add(this.createNode(b));
            var d = new l(a);
            vb.sort(d, this.getComparator());
            for (d = d.iterator(); d.hasNext();) {
                var e = d.next();
                this.lastNode(c).getChildBoundables().size() === this.getNodeCapacity() && c.add(this.createNode(b));
                this.lastNode(c).addChildBoundable(e)
            }
            return c
        },
        isEmpty: function() {
            return this.built ? this.root.isEmpty() : this.itemBoundables.isEmpty()
        },
        interfaces_: function() {
            return [Ba]
        },
        getClass: function() {
            return ba
        }
    });
    ba.compareDoubles = function(a, b) {
        return a > b ? 1 : a < b ? -1 : 0
    };
    ba.IntersectsOp = function() {};
    ba.serialVersionUID = -0x35ef64c82d4c5400;
    ba.DEFAULT_NODE_CAPACITY = 10;
    g(pe.prototype, {
        distance: function(a, b) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return pe
        }
    });
    x(X, ba);
    g(X.prototype, {
        createParentBoundablesFromVerticalSlices: function(a, b) {
            t.isTrue(0 < a.length);
            for (var c = new l, d = 0; d < a.length; d++) c.addAll(this.createParentBoundablesFromVerticalSlice(a[d], b));
            return c
        },
        createNode: function(a) {
            return new pd(a)
        },
        size: function() {
            return 0 === arguments.length ? ba.prototype.size.call(this) : ba.prototype.size.apply(this, arguments)
        },
        insert: function() {
            if (2 !== arguments.length) return ba.prototype.insert.apply(this, arguments);
            var a = arguments[0],
                b = arguments[1];
            if (a.isNull()) return null;
            ba.prototype.insert.call(this, a, b)
        },
        getIntersectsOp: function() {
            return X.intersectsOp
        },
        verticalSlices: function(a, b) {
            for (var c = Math.trunc(Math.ceil(a.size() / b)), d = Array(b).fill(null), e = a.iterator(), f = 0; f < b; f++) {
                d[f] = new l;
                for (var g = 0; e.hasNext() &&
                    g < c;) {
                    var h = e.next();
                    d[f].add(h);
                    g++
                }
            }
            return d
        },
        query: function() {
            if (1 === arguments.length) return ba.prototype.query.call(this, arguments[0]);
            2 === arguments.length ? ba.prototype.query.call(this, arguments[0], arguments[1]) : 3 === arguments.length && (u(arguments[2], Zb) && arguments[0] instanceof Object && arguments[1] instanceof za ? ba.prototype.query.call(this, arguments[0], arguments[1], arguments[2]) : u(arguments[2], ga) && arguments[0] instanceof Object && arguments[1] instanceof za && ba.prototype.query.call(this, arguments[0],
                arguments[1], arguments[2]))
        },
        getComparator: function() {
            return X.yComparator
        },
        createParentBoundablesFromVerticalSlice: function(a, b) {
            return ba.prototype.createParentBoundables.call(this, a, b)
        },
        remove: function() {
            return 2 === arguments.length ? ba.prototype.remove.call(this, arguments[0], arguments[1]) : ba.prototype.remove.apply(this, arguments)
        },
        depth: function() {
            return 0 === arguments.length ? ba.prototype.depth.call(this) : ba.prototype.depth.apply(this, arguments)
        },
        createParentBoundables: function(a, b) {
            t.isTrue(!a.isEmpty());
            var c = Math.trunc(Math.ceil(a.size() / this.getNodeCapacity())),
                d = new l(a);
            vb.sort(d, X.xComparator);
            c = this.verticalSlices(d, Math.trunc(Math.ceil(Math.sqrt(c))));
            return this.createParentBoundablesFromVerticalSlices(c, b)
        },
        nearestNeighbour: function() {
            if (1 === arguments.length) {
                if (u(arguments[0], pe)) {
                    var a = arguments[0],
                        a = new Da(this.getRoot(), this.getRoot(), a);
                    return this.nearestNeighbour(a)
                }
                if (arguments[0] instanceof Da) return this.nearestNeighbour(arguments[0], v.POSITIVE_INFINITY)
            } else if (2 === arguments.length) {
                if (arguments[0] instanceof X && u(arguments[1], pe)) {
                    var a = arguments[0],
                        b = arguments[1],
                        a = new Da(this.getRoot(), a.getRoot(), b);
                    return this.nearestNeighbour(a)
                }
                if (arguments[0] instanceof Da && "number" == typeof arguments[1]) {
                    var c = arguments[0],
                        a = arguments[1],
                        b = null,
                        d = new zf;
                    for (d.add(c); !d.isEmpty() && 0 < a;) {
                        var c = d.poll(),
                            e = c.getDistance();
                        if (e >= a) break;
                        c.isLeaves() ? (a = e, b = c) : c.expandToQueue(d, a)
                    }
                    return [b.getBoundable(0).getItem(), b.getBoundable(1).getItem()]
                }
            } else if (3 === arguments.length) return a = arguments[2], b = new Fb(arguments[0],
                arguments[1]), a = new Da(this.getRoot(), b, a), this.nearestNeighbour(a)[0]
        },
        interfaces_: function() {
            return [oe, Ba]
        },
        getClass: function() {
            return X
        }
    });
    X.centreX = function(a) {
        return X.avg(a.getMinX(), a.getMaxX())
    };
    X.avg = function(a, b) {
        return (a + b) / 2
    };
    X.centreY = function(a) {
        return X.avg(a.getMinY(), a.getMaxY())
    };
    x(pd, za);
    g(pd.prototype, {
        computeBounds: function() {
            for (var a = null, b = this.getChildBoundables().iterator(); b.hasNext();) {
                var c = b.next();
                null === a ? a = new y(c.getBounds()) : a.expandToInclude(c.getBounds())
            }
            return a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return pd
        }
    });
    X.STRtreeNode = pd;
    X.serialVersionUID = 0x39920f7d5f261e0;
    X.xComparator = {
        interfaces_: function() {
            return [Wb]
        },
        compare: function(a, b) {
            return ba.compareDoubles(X.centreX(a.getBounds()), X.centreX(b.getBounds()))
        }
    };
    X.yComparator = {
        interfaces_: function() {
            return [Wb]
        },
        compare: function(a, b) {
            return ba.compareDoubles(X.centreY(a.getBounds()), X.centreY(b.getBounds()))
        }
    };
    X.intersectsOp = {
        interfaces_: function() {
            return [IntersectsOp]
        },
        intersects: function(a,
            b) {
            return a.intersects(b)
        }
    };
    X.DEFAULT_NODE_CAPACITY = 10;
    g(Ea.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ea
        }
    });
    Ea.relativeSign = function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0
    };
    Ea.compare = function(a, b, c) {
        if (b.equals2D(c)) return 0;
        var d = Ea.relativeSign(b.x, c.x);
        b = Ea.relativeSign(b.y, c.y);
        switch (a) {
            case 0:
                return Ea.compareValue(d, b);
            case 1:
                return Ea.compareValue(b, d);
            case 2:
                return Ea.compareValue(b, -d);
            case 3:
                return Ea.compareValue(-d, b);
            case 4:
                return Ea.compareValue(-d, -b);
            case 5:
                return Ea.compareValue(-b, -d);
            case 6:
                return Ea.compareValue(-b, d);
            case 7:
                return Ea.compareValue(d, -b)
        }
        return t.shouldNeverReachHere("invalid octant value"), 0
    };
    Ea.compareValue = function(a, b) {
        return 0 > a ? -1 : 0 < a ? 1 : 0 > b ? -1 : 0 < b ? 1 : 0
    };
    g(Af.prototype, {
        getCoordinate: function() {
            return this.coord
        },
        print: function(a) {
            a.print(this.coord);
            a.print(" seg # \x3d " + this.segmentIndex)
        },
        compareTo: function(a) {
            return this.segmentIndex < a.segmentIndex ? -1 : this.segmentIndex > a.segmentIndex ? 1 : this.coord.equals2D(a.coord) ? 0 : Ea.compare(this.segmentOctant,
                this.coord, a.coord)
        },
        isEndPoint: function(a) {
            return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === a
        },
        isInterior: function() {
            return this._isInterior
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return Af
        }
    });
    g(Bf.prototype, {
        getSplitCoordinates: function() {
            var a = new Z;
            this.addEndpoints();
            for (var b = this.iterator(), c = b.next(); b.hasNext();) {
                var d = b.next();
                this.addEdgeCoordinates(c, d, a);
                c = d
            }
            return a.toCoordinateArray()
        },
        addCollapsedNodes: function() {
            var a = new l;
            this.findCollapsesFromInsertedNodes(a);
            this.findCollapsesFromExistingVertices(a);
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next().intValue();
                this.add(this.edge.getCoordinate(b), b)
            }
        },
        print: function(a) {
            a.println("Intersections:");
            for (var b = this.iterator(); b.hasNext();) b.next().print(a)
        },
        findCollapsesFromExistingVertices: function(a) {
            for (var b = 0; b < this.edge.size() - 2; b++) {
                var c = this.edge.getCoordinate(b),
                    d = (this.edge.getCoordinate(b + 1), this.edge.getCoordinate(b + 2));
                c.equals2D(d) && a.add(new db(b + 1))
            }
        },
        addEdgeCoordinates: function(a, b, c) {
            var d =
                b.segmentIndex - a.segmentIndex + 2,
                e = this.edge.getCoordinate(b.segmentIndex);
            (e = b.isInterior() || !b.coord.equals2D(e)) || d--;
            c.add(new k(a.coord), !1);
            for (a = a.segmentIndex + 1; a <= b.segmentIndex; a++) c.add(this.edge.getCoordinate(a));
            e && c.add(new k(b.coord))
        },
        iterator: function() {
            return this.nodeMap.values().iterator()
        },
        addSplitEdges: function(a) {
            this.addEndpoints();
            this.addCollapsedNodes();
            for (var b = this.iterator(), c = b.next(); b.hasNext();) {
                var d = b.next(),
                    c = this.createSplitEdge(c, d);
                a.add(c);
                c = d
            }
        },
        findCollapseIndex: function(a,
            b, c) {
            if (!a.coord.equals2D(b.coord)) return !1;
            var d = b.segmentIndex - a.segmentIndex;
            return b.isInterior() || d--, 1 === d && (c[0] = a.segmentIndex + 1, !0)
        },
        findCollapsesFromInsertedNodes: function(a) {
            for (var b = Array(1).fill(null), c = this.iterator(), d = c.next(); c.hasNext();) {
                var e = c.next();
                this.findCollapseIndex(d, e, b) && a.add(new db(b[0]));
                d = e
            }
        },
        getEdge: function() {
            return this.edge
        },
        addEndpoints: function() {
            var a = this.edge.size() - 1;
            this.add(this.edge.getCoordinate(0), 0);
            this.add(this.edge.getCoordinate(a), a)
        },
        createSplitEdge: function(a,
            b) {
            var c = b.segmentIndex - a.segmentIndex + 2,
                d = this.edge.getCoordinate(b.segmentIndex);
            (d = b.isInterior() || !b.coord.equals2D(d)) || c--;
            var c = Array(c).fill(null),
                e = 0;
            c[e++] = new k(a.coord);
            for (var f = a.segmentIndex + 1; f <= b.segmentIndex; f++) c[e++] = this.edge.getCoordinate(f);
            return d && (c[e] = new k(b.coord)), new nb(c, this.edge.getData())
        },
        add: function(a, b) {
            var c = new Af(this.edge, a, b, this.edge.getSegmentOctant(b)),
                d = this.nodeMap.get(c);
            return null !== d ? (t.isTrue(d.coord.equals2D(a), "Found equal nodes with different coordinates"),
                d) : (this.nodeMap.put(c, c), c)
        },
        checkSplitEdgesCorrectness: function(a) {
            var b = this.edge.getCoordinates(),
                c = a.get(0).getCoordinate(0);
            if (!c.equals2D(b[0])) throw new la("bad split edge start point at " + c);
            a = a.get(a.size() - 1).getCoordinates();
            a = a[a.length - 1];
            if (!a.equals2D(b[b.length - 1])) throw new la("bad split edge end point at " + a);
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Bf
        }
    });
    g(jg.prototype, {
        next: function() {
            return null === this.currNode ? (this.currNode = this.nextNode, this.currSegIndex =
                this.currNode.segmentIndex, this.readNextNode(), this.currNode) : null === this.nextNode ? null : this.nextNode.segmentIndex === this.currNode.segmentIndex ? (this.currNode = this.nextNode, this.currSegIndex = this.currNode.segmentIndex, this.readNextNode(), this.currNode) : (this.nextNode.segmentIndex, this.currNode.segmentIndex, null)
        },
        remove: function() {
            throw new UnsupportedOperationException(this.getClass().getName());
        },
        hasNext: function() {
            return null !== this.nextNode
        },
        readNextNode: function() {
            this.nodeIt.hasNext() ? this.nextNode =
                this.nodeIt.next() : this.nextNode = null
        },
        interfaces_: function() {
            return [hd]
        },
        getClass: function() {
            return jg
        }
    });
    g(Cf.prototype, {
        addIntersection: function(a, b) {},
        interfaces_: function() {
            return [od]
        },
        getClass: function() {
            return Cf
        }
    });
    g(nb.prototype, {
        getCoordinates: function() {
            return this.pts
        },
        size: function() {
            return this.pts.length
        },
        getCoordinate: function(a) {
            return this.pts[a]
        },
        isClosed: function() {
            return this.pts[0].equals(this.pts[this.pts.length - 1])
        },
        getSegmentOctant: function(a) {
            return a === this.pts.length - 1 ?
                -1 : this.safeOctant(this.getCoordinate(a), this.getCoordinate(a + 1))
        },
        setData: function(a) {
            this.data = a
        },
        safeOctant: function(a, b) {
            return a.equals2D(b) ? 0 : Mc.octant(a, b)
        },
        getData: function() {
            return this.data
        },
        addIntersection: function() {
            if (2 === arguments.length) this.addIntersectionNode(arguments[0], arguments[1]);
            else if (4 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = (arguments[2], arguments[3]),
                    a = new k(a.getIntersection(c));
                this.addIntersection(a, b)
            }
        },
        toString: function() {
            return ra.toLineString(new Za(this.pts))
        },
        getNodeList: function() {
            return this.nodeList
        },
        addIntersectionNode: function(a, b) {
            var c = b,
                d = c + 1;
            d < this.pts.length && a.equals2D(this.pts[d]) && (c = d);
            return this.nodeList.add(a, c)
        },
        addIntersections: function(a, b, c) {
            for (var d = 0; d < a.getIntersectionNum(); d++) this.addIntersection(a, b, c, d)
        },
        interfaces_: function() {
            return [Cf]
        },
        getClass: function() {
            return nb
        }
    });
    nb.getNodedSubstrings = function() {
        if (1 === arguments.length) {
            var a = arguments[0],
                b = new l;
            return nb.getNodedSubstrings(a, b), b
        }
        if (2 === arguments.length)
            for (a = arguments[1],
                b = arguments[0].iterator(); b.hasNext();) b.next().getNodeList().addSplitEdges(a)
    };
    g(qd.prototype, {
        overlap: function() {
            if (2 === arguments.length) arguments[0], arguments[1];
            else if (4 === arguments.length) {
                var a = arguments[2],
                    b = arguments[3];
                arguments[0].getLineSegment(arguments[1], this.overlapSeg1);
                a.getLineSegment(b, this.overlapSeg2);
                this.overlap(this.overlapSeg1, this.overlapSeg2)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return qd
        }
    });
    g(Df.prototype, {
        getLineSegment: function(a, b) {
            b.p0 = this.pts[a];
            b.p1 = this.pts[a + 1]
        },
        computeSelect: function(a, b, c, d) {
            if (d.tempEnv1.init(this.pts[b], this.pts[c]), 1 == c - b) return d.select(this, b), null;
            if (!a.intersects(d.tempEnv1)) return null;
            var e = Math.trunc((b + c) / 2);
            b < e && this.computeSelect(a, b, e, d);
            e < c && this.computeSelect(a, e, c, d)
        },
        getCoordinates: function() {
            for (var a = Array(this.end - this.start + 1).fill(null), b = 0, c = this.start; c <= this.end; c++) a[b++] = this.pts[c];
            return a
        },
        computeOverlaps: function(a, b) {
            this.computeOverlapsInternal(this.start, this.end, a, a.start, a.end, b)
        },
        setId: function(a) {
            this.id = a
        },
        select: function(a, b) {
            this.computeSelect(a, this.start, this.end, b)
        },
        getEnvelope: function() {
            null === this.env && (this.env = new y(this.pts[this.start], this.pts[this.end]));
            return this.env
        },
        getEndIndex: function() {
            return this.end
        },
        getStartIndex: function() {
            return this.start
        },
        getContext: function() {
            return this.context
        },
        getId: function() {
            return this.id
        },
        computeOverlapsInternal: function(a, b, c, d, e, f) {
            var g = this.pts[a],
                h = this.pts[b],
                k = c.pts[d],
                l = c.pts[e];
            if (1 == b - a && 1 == e - d) return f.overlap(this,
                a, c, d), null;
            if (f.tempEnv1.init(g, h), f.tempEnv2.init(k, l), !f.tempEnv1.intersects(f.tempEnv2)) return null;
            g = Math.trunc((a + b) / 2);
            h = Math.trunc((d + e) / 2);
            a < g && (d < h && this.computeOverlapsInternal(a, g, c, d, h, f), h < e && this.computeOverlapsInternal(a, g, c, h, e, f));
            g < b && (d < h && this.computeOverlapsInternal(g, b, c, d, h, f), h < e && this.computeOverlapsInternal(g, b, c, h, e, f))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Df
        }
    });
    g(H.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return H
        }
    });
    H.isNorthern =
        function(a) {
            return a === H.NE || a === H.NW
        };
    H.isOpposite = function(a, b) {
        return a !== b && 2 == (a - b + 4) % 4
    };
    H.commonHalfPlane = function(a, b) {
        if (a === b) return a;
        if (2 == (a - b + 4) % 4) return -1;
        var c = a < b ? a : b;
        return 0 === c && 3 === (a > b ? a : b) ? 3 : c
    };
    H.isInHalfPlane = function(a, b) {
        return b === H.SE ? a === H.SE || a === H.SW : a === b || a === b + 1
    };
    H.quadrant = function(a, b) {
        if ("number" == typeof a && "number" == typeof b) {
            if (0 === a && 0 === b) throw new K("Cannot compute the quadrant for point ( " + a + ", " + b + " )");
            return 0 <= a ? 0 <= b ? H.NE : H.SE : 0 <= b ? H.NW : H.SW
        }
        if (a instanceof k && b instanceof k) {
            if (b.x === a.x && b.y === a.y) throw new K("Cannot compute the quadrant for two identical points " + a);
            return b.x >= a.x ? b.y >= a.y ? H.NE : H.SE : b.y >= a.y ? H.NW : H.SW
        }
    };
    H.NE = 0;
    H.NW = 1;
    H.SW = 2;
    H.SE = 3;
    g(fb.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return fb
        }
    });
    fb.getChainStartIndices = function(a) {
        var b = 0,
            c = new l;
        c.add(new db(b));
        do b = fb.findChainEnd(a, b), c.add(new db(b)); while (b < a.length - 1);
        return fb.toIntArray(c)
    };
    fb.findChainEnd = function(a, b) {
        for (var c = b; c < a.length - 1 && a[c].equals2D(a[c +
                1]);) c++;
        if (c >= a.length - 1) return a.length - 1;
        for (var c = H.quadrant(a[c], a[c + 1]), d = b + 1; d < a.length && (a[d - 1].equals2D(a[d]) || H.quadrant(a[d - 1], a[d]) === c);) d++;
        return d - 1
    };
    fb.getChains = function() {
        if (1 === arguments.length) return fb.getChains(arguments[0], null);
        if (2 === arguments.length) {
            for (var a = arguments[0], b = arguments[1], c = new l, d = fb.getChainStartIndices(a), e = 0; e < d.length - 1; e++) {
                var f = new Df(a, d[e], d[e + 1], b);
                c.add(f)
            }
            return c
        }
    };
    fb.toIntArray = function(a) {
        for (var b = Array(a.size()).fill(null), c = 0; c < b.length; c++) b[c] =
            a.get(c).intValue();
        return b
    };
    g(rd.prototype, {
        computeNodes: function(a) {},
        getNodedSubstrings: function() {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return rd
        }
    });
    g(qe.prototype, {
        setSegmentIntersector: function(a) {
            this.segInt = a
        },
        interfaces_: function() {
            return [rd]
        },
        getClass: function() {
            return qe
        }
    });
    x($b, qe);
    g($b.prototype, {
        getMonotoneChains: function() {
            return this.monoChains
        },
        getNodedSubstrings: function() {
            return nb.getNodedSubstrings(this.nodedSegStrings)
        },
        getIndex: function() {
            return this.index
        },
        add: function(a) {
            for (a = fb.getChains(a.getCoordinates(), a).iterator(); a.hasNext();) {
                var b = a.next();
                b.setId(this.idCounter++);
                this.index.insert(b.getEnvelope(), b);
                this.monoChains.add(b)
            }
        },
        computeNodes: function(a) {
            this.nodedSegStrings = a;
            for (a = a.iterator(); a.hasNext();) this.add(a.next());
            this.intersectChains()
        },
        intersectChains: function() {
            for (var a = new sd(this.segInt), b = this.monoChains.iterator(); b.hasNext();)
                for (var c = b.next(), d = this.index.query(c.getEnvelope()).iterator(); d.hasNext();) {
                    var e = d.next();
                    if (e.getId() > c.getId() && (c.computeOverlaps(e, a), this.nOverlaps++), this.segInt.isDone()) return null
                }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return $b
        }
    });
    x(sd, qd);
    g(sd.prototype, {
        overlap: function() {
            if (4 !== arguments.length) return qd.prototype.overlap.apply(this, arguments);
            var a = arguments[1],
                b = arguments[2],
                c = arguments[3],
                d = arguments[0].getContext(),
                b = b.getContext();
            this.si.processIntersections(d, a, b, c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return sd
        }
    });
    $b.SegmentOverlapAction =
        sd;
    x(Ja, la);
    g(Ja.prototype, {
        getCoordinate: function() {
            return this.pt
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ja
        }
    });
    Ja.msgWithCoord = function(a, b) {
        return null !== b ? a + " [ " + b + " ]" : a
    };
    g(td.prototype, {
        processIntersections: function(a, b, c, d) {},
        isDone: function() {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return td
        }
    });
    g(Qb.prototype, {
        getInteriorIntersection: function() {
            return this.interiorIntersection
        },
        setCheckEndSegmentsOnly: function(a) {
            this.isCheckEndSegmentsOnly = a
        },
        getIntersectionSegments: function() {
            return this.intSegments
        },
        count: function() {
            return this.intersectionCount
        },
        getIntersections: function() {
            return this.intersections
        },
        setFindAllIntersections: function(a) {
            this.findAllIntersections = a
        },
        setKeepIntersections: function(a) {
            this.keepIntersections = a
        },
        processIntersections: function(a, b, c, d) {
            if (!this.findAllIntersections && this.hasIntersection() || a === c && b === d || this.isCheckEndSegmentsOnly && !this.isEndSegment(a, b) && !this.isEndSegment(c, d)) return null;
            var e = a.getCoordinates()[b];
            a = a.getCoordinates()[b + 1];
            b = c.getCoordinates()[d];
            c = c.getCoordinates()[d + 1];
            this.li.computeIntersection(e, a, b, c);
            this.li.hasIntersection() && this.li.isInteriorIntersection() && (this.intSegments = Array(4).fill(null), this.intSegments[0] = e, this.intSegments[1] = a, this.intSegments[2] = b, this.intSegments[3] = c, this.interiorIntersection = this.li.getIntersection(0), this.keepIntersections && this.intersections.add(this.interiorIntersection), this.intersectionCount++)
        },
        isEndSegment: function(a, b) {
            return 0 === b || b >= a.size() - 2
        },
        hasIntersection: function() {
            return null !==
                this.interiorIntersection
        },
        isDone: function() {
            return !this.findAllIntersections && null !== this.interiorIntersection
        },
        interfaces_: function() {
            return [td]
        },
        getClass: function() {
            return Qb
        }
    });
    Qb.createAllIntersectionsFinder = function(a) {
        a = new Qb(a);
        return a.setFindAllIntersections(!0), a
    };
    Qb.createAnyIntersectionFinder = function(a) {
        return new Qb(a)
    };
    Qb.createIntersectionCounter = function(a) {
        a = new Qb(a);
        return a.setFindAllIntersections(!0), a.setKeepIntersections(!1), a
    };
    g(ud.prototype, {
        execute: function() {
            if (null !==
                this.segInt) return null;
            this.checkInteriorIntersections()
        },
        getIntersections: function() {
            return this.segInt.getIntersections()
        },
        isValid: function() {
            return this.execute(), this._isValid
        },
        setFindAllIntersections: function(a) {
            this.findAllIntersections = a
        },
        checkInteriorIntersections: function() {
            this._isValid = !0;
            this.segInt = new Qb(this.li);
            this.segInt.setFindAllIntersections(this.findAllIntersections);
            var a = new $b;
            if (a.setSegmentIntersector(this.segInt), a.computeNodes(this.segStrings), this.segInt.hasIntersection()) return this._isValid = !1, null
        },
        checkValid: function() {
            if (this.execute(), !this._isValid) throw new Ja(this.getErrorMessage(), this.segInt.getInteriorIntersection());
        },
        getErrorMessage: function() {
            if (this._isValid) return "no intersections found";
            var a = this.segInt.getIntersectionSegments();
            return "found non-noded intersection between " + ra.toLineString(a[0], a[1]) + " and " + ra.toLineString(a[2], a[3])
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ud
        }
    });
    ud.computeIntersections = function(a) {
        a = new ud(a);
        return a.setFindAllIntersections(!0),
            a.isValid(), a.getIntersections()
    };
    g(vc.prototype, {
        checkValid: function() {
            this.nv.checkValid()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return vc
        }
    });
    vc.toSegmentStrings = function(a) {
        var b = new l;
        for (a = a.iterator(); a.hasNext();) {
            var c = a.next();
            b.add(new yf(c.getCoordinates(), c))
        }
        return b
    };
    vc.checkValid = function(a) {
        (new vc(a)).checkValid()
    };
    g(Nc.prototype, {
        map: function(a) {
            for (var b = new l, c = 0; c < a.getNumGeometries(); c++) {
                var d = this.mapOp.map(a.getGeometryN(c));
                d.isEmpty() || b.add(d)
            }
            return a.getFactory().createGeometryCollection(E.toGeometryArray(b))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Nc
        }
    });
    Nc.map = function(a, b) {
        return (new Nc(b)).map(a)
    };
    g(p.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return p
        }
    });
    p.opposite = function(a) {
        return a === p.LEFT ? p.RIGHT : a === p.RIGHT ? p.LEFT : a
    };
    p.ON = 0;
    p.LEFT = 1;
    p.RIGHT = 2;
    g(Ka.prototype, {
        setAllLocations: function(a) {
            for (var b = 0; b < this.location.length; b++) this.location[b] = a
        },
        isNull: function() {
            for (var a = 0; a < this.location.length; a++)
                if (this.location[a] !== h.NONE) return !1;
            return !0
        },
        setAllLocationsIfNull: function(a) {
            for (var b =
                    0; b < this.location.length; b++) this.location[b] === h.NONE && (this.location[b] = a)
        },
        isLine: function() {
            return 1 === this.location.length
        },
        merge: function(a) {
            if (a.location.length > this.location.length) {
                var b = Array(3).fill(null);
                b[p.ON] = this.location[p.ON];
                b[p.LEFT] = h.NONE;
                b[p.RIGHT] = h.NONE;
                this.location = b
            }
            for (b = 0; b < this.location.length; b++) this.location[b] === h.NONE && b < a.location.length && (this.location[b] = a.location[b])
        },
        getLocations: function() {
            return this.location
        },
        flip: function() {
            if (1 >= this.location.length) return null;
            var a = this.location[p.LEFT];
            this.location[p.LEFT] = this.location[p.RIGHT];
            this.location[p.RIGHT] = a
        },
        toString: function() {
            var a = new Ya;
            return 1 < this.location.length && a.append(h.toLocationSymbol(this.location[p.LEFT])), a.append(h.toLocationSymbol(this.location[p.ON])), 1 < this.location.length && a.append(h.toLocationSymbol(this.location[p.RIGHT])), a.toString()
        },
        setLocations: function(a, b, c) {
            this.location[p.ON] = a;
            this.location[p.LEFT] = b;
            this.location[p.RIGHT] = c
        },
        get: function(a) {
            return a < this.location.length ?
                this.location[a] : h.NONE
        },
        isArea: function() {
            return 1 < this.location.length
        },
        isAnyNull: function() {
            for (var a = 0; a < this.location.length; a++)
                if (this.location[a] === h.NONE) return !0;
            return !1
        },
        setLocation: function() {
            1 === arguments.length ? this.setLocation(p.ON, arguments[0]) : 2 === arguments.length && (this.location[arguments[0]] = arguments[1])
        },
        init: function(a) {
            this.location = Array(a).fill(null);
            this.setAllLocations(h.NONE)
        },
        isEqualOnSide: function(a, b) {
            return this.location[b] === a.location[b]
        },
        allPositionsEqual: function(a) {
            for (var b =
                    0; b < this.location.length; b++)
                if (this.location[b] !== a) return !1;
            return !0
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ka
        }
    });
    g(ca.prototype, {
        getGeometryCount: function() {
            var a = 0;
            return this.elt[0].isNull() || a++, this.elt[1].isNull() || a++, a
        },
        setAllLocations: function(a, b) {
            this.elt[a].setAllLocations(b)
        },
        isNull: function(a) {
            return this.elt[a].isNull()
        },
        setAllLocationsIfNull: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.setAllLocationsIfNull(0, a);
                this.setAllLocationsIfNull(1, a)
            } else 2 ===
                arguments.length && this.elt[arguments[0]].setAllLocationsIfNull(arguments[1])
        },
        isLine: function(a) {
            return this.elt[a].isLine()
        },
        merge: function(a) {
            for (var b = 0; 2 > b; b++) null === this.elt[b] && null !== a.elt[b] ? this.elt[b] = new Ka(a.elt[b]) : this.elt[b].merge(a.elt[b])
        },
        flip: function() {
            this.elt[0].flip();
            this.elt[1].flip()
        },
        getLocation: function() {
            if (1 === arguments.length) return this.elt[arguments[0]].get(p.ON);
            if (2 === arguments.length) return this.elt[arguments[0]].get(arguments[1])
        },
        toString: function() {
            var a = new Ya;
            return null !== this.elt[0] && (a.append("A:"), a.append(this.elt[0].toString())), null !== this.elt[1] && (a.append(" B:"), a.append(this.elt[1].toString())), a.toString()
        },
        isArea: function() {
            if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea();
            if (1 === arguments.length) return this.elt[arguments[0]].isArea()
        },
        isAnyNull: function(a) {
            return this.elt[a].isAnyNull()
        },
        setLocation: function() {
            2 === arguments.length ? this.elt[arguments[0]].setLocation(p.ON, arguments[1]) : 3 === arguments.length && this.elt[arguments[0]].setLocation(arguments[1],
                arguments[2])
        },
        isEqualOnSide: function(a, b) {
            return this.elt[0].isEqualOnSide(a.elt[0], b) && this.elt[1].isEqualOnSide(a.elt[1], b)
        },
        allPositionsEqual: function(a, b) {
            return this.elt[a].allPositionsEqual(b)
        },
        toLine: function(a) {
            this.elt[a].isArea() && (this.elt[a] = new Ka(this.elt[a].location[0]))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ca
        }
    });
    ca.toLineLabel = function(a) {
        for (var b = new ca(h.NONE), c = 0; 2 > c; c++) b.setLocation(c, a.getLocation(c));
        return b
    };
    g(Oc.prototype, {
        computeRing: function() {
            if (null !==
                this.ring) return null;
            for (var a = Array(this.pts.size()).fill(null), b = 0; b < this.pts.size(); b++) a[b] = this.pts.get(b);
            this.ring = this.geometryFactory.createLinearRing(a);
            this._isHole = q.isCCW(this.ring.getCoordinates())
        },
        isIsolated: function() {
            return 1 === this.label.getGeometryCount()
        },
        computePoints: function(a) {
            this.startDe = a;
            var b = !0;
            do {
                if (null === a) throw new Ja("Found null DirectedEdge");
                if (a.getEdgeRing() === this) throw new Ja("Directed Edge visited twice during ring-building at " + a.getCoordinate());
                this.edges.add(a);
                var c = a.getLabel();
                t.isTrue(c.isArea());
                this.mergeLabel(c);
                this.addPoints(a.getEdge(), a.isForward(), b);
                b = !1;
                this.setEdgeRing(a, this);
                a = this.getNext(a)
            } while (a !== this.startDe)
        },
        getLinearRing: function() {
            return this.ring
        },
        getCoordinate: function(a) {
            return this.pts.get(a)
        },
        computeMaxNodeDegree: function() {
            this.maxNodeDegree = 0;
            var a = this.startDe;
            do {
                var b = a.getNode().getEdges().getOutgoingDegree(this);
                b > this.maxNodeDegree && (this.maxNodeDegree = b);
                a = this.getNext(a)
            } while (a !== this.startDe);
            this.maxNodeDegree *=
                2
        },
        addPoints: function(a, b, c) {
            a = a.getCoordinates();
            if (b)
                for (b = 1, c && (b = 0), c = b; c < a.length; c++) this.pts.add(a[c]);
            else
                for (b = a.length - 2, c && (b = a.length - 1), c = b; 0 <= c; c--) this.pts.add(a[c])
        },
        isHole: function() {
            return this._isHole
        },
        setInResult: function() {
            var a = this.startDe;
            do a.getEdge().setInResult(!0), a = a.getNext(); while (a !== this.startDe)
        },
        containsPoint: function(a) {
            var b = this.getLinearRing();
            if (!b.getEnvelopeInternal().contains(a) || !q.isPointInRing(a, b.getCoordinates())) return !1;
            for (b = this.holes.iterator(); b.hasNext();)
                if (b.next().containsPoint(a)) return !1;
            return !0
        },
        addHole: function(a) {
            this.holes.add(a)
        },
        isShell: function() {
            return null === this.shell
        },
        getLabel: function() {
            return this.label
        },
        getEdges: function() {
            return this.edges
        },
        getMaxNodeDegree: function() {
            return 0 > this.maxNodeDegree && this.computeMaxNodeDegree(), this.maxNodeDegree
        },
        getShell: function() {
            return this.shell
        },
        mergeLabel: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.mergeLabel(a, 0);
                this.mergeLabel(a, 1)
            } else if (2 === arguments.length) {
                var a = arguments[1],
                    b = arguments[0].getLocation(a,
                        p.RIGHT);
                if (b === h.NONE) return null;
                if (this.label.getLocation(a) === h.NONE) return this.label.setLocation(a, b), null
            }
        },
        setShell: function(a) {
            this.shell = a;
            null !== a && a.addHole(this)
        },
        toPolygon: function(a) {
            for (var b = Array(this.holes.size()).fill(null), c = 0; c < this.holes.size(); c++) b[c] = this.holes.get(c).getLinearRing();
            return a.createPolygon(this.getLinearRing(), b)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Oc
        }
    });
    x(re, Oc);
    g(re.prototype, {
        setEdgeRing: function(a, b) {
            a.setMinEdgeRing(b)
        },
        getNext: function(a) {
            return a.getNextMin()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return re
        }
    });
    x(vd, Oc);
    g(vd.prototype, {
        buildMinimalRings: function() {
            var a = new l,
                b = this.startDe;
            do {
                if (null === b.getMinEdgeRing()) {
                    var c = new re(b, this.geometryFactory);
                    a.add(c)
                }
                b = b.getNext()
            } while (b !== this.startDe);
            return a
        },
        setEdgeRing: function(a, b) {
            a.setEdgeRing(b)
        },
        linkDirectedEdgesForMinimalEdgeRings: function() {
            var a = this.startDe;
            do a.getNode().getEdges().linkMinimalDirectedEdges(this), a = a.getNext(); while (a !== this.startDe)
        },
        getNext: function(a) {
            return a.getNext()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return vd
        }
    });
    g(ac.prototype, {
        setVisited: function(a) {
            this._isVisited = a
        },
        setInResult: function(a) {
            this._isInResult = a
        },
        isCovered: function() {
            return this._isCovered
        },
        isCoveredSet: function() {
            return this._isCoveredSet
        },
        setLabel: function(a) {
            this.label = a
        },
        getLabel: function() {
            return this.label
        },
        setCovered: function(a) {
            this._isCovered = a;
            this._isCoveredSet = !0
        },
        updateIM: function(a) {
            t.isTrue(2 <= this.label.getGeometryCount(), "found partial label");
            this.computeIM(a)
        },
        isInResult: function() {
            return this._isInResult
        },
        isVisited: function() {
            return this._isVisited
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ac
        }
    });
    x(Gb, ac);
    g(Gb.prototype, {
        isIncidentEdgeInResult: function() {
            for (var a = this.getEdges().getEdges().iterator(); a.hasNext();)
                if (a.next().getEdge().isInResult()) return !0;
            return !1
        },
        isIsolated: function() {
            return 1 === this.label.getGeometryCount()
        },
        getCoordinate: function() {
            return this.coord
        },
        print: function(a) {
            a.println("node " + this.coord + " lbl: " + this.label)
        },
        computeIM: function(a) {},
        computeMergedLocation: function(a, b) {
            var c = h.NONE;
            if (c = this.label.getLocation(b), !a.isNull(b)) {
                var d = a.getLocation(b);
                c !== h.BOUNDARY && (c = d)
            }
            return c
        },
        setLabel: function() {
            if (2 !== arguments.length) return ac.prototype.setLabel.apply(this, arguments);
            var a = arguments[0],
                b = arguments[1];
            null === this.label ? this.label = new ca(a, b) : this.label.setLocation(a, b)
        },
        getEdges: function() {
            return this.edges
        },
        mergeLabel: function(a) {
            if (a instanceof Gb) this.mergeLabel(a.label);
            else if (a instanceof ca)
                for (var b =
                        0; 2 > b; b++) {
                    var c = this.computeMergedLocation(a, b);
                    this.label.getLocation(b) === h.NONE && this.label.setLocation(b, c)
                }
        },
        add: function(a) {
            this.edges.insert(a);
            a.setNode(this)
        },
        setLabelBoundary: function(a) {
            if (null === this.label) return null;
            var b = h.NONE;
            null !== this.label && (b = this.label.getLocation(a));
            var c = null;
            switch (b) {
                case h.BOUNDARY:
                    c = h.INTERIOR;
                    break;
                default:
                    c = h.BOUNDARY
            }
            this.label.setLocation(a, c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Gb
        }
    });
    g(Pc.prototype, {
        find: function(a) {
            return this.nodeMap.get(a)
        },
        addNode: function(a) {
            if (a instanceof k) {
                var b = this.nodeMap.get(a);
                return null === b && (b = this.nodeFact.createNode(a), this.nodeMap.put(a, b)), b
            }
            if (a instanceof Gb) return b = this.nodeMap.get(a.getCoordinate()), null === b ? (this.nodeMap.put(a.getCoordinate(), a), a) : (b.mergeLabel(a), b)
        },
        print: function(a) {
            for (var b = this.iterator(); b.hasNext();) b.next().print(a)
        },
        iterator: function() {
            return this.nodeMap.values().iterator()
        },
        values: function() {
            return this.nodeMap.values()
        },
        getBoundaryNodes: function(a) {
            for (var b = new l,
                    c = this.iterator(); c.hasNext();) {
                var d = c.next();
                d.getLabel().getLocation(a) === h.BOUNDARY && b.add(d)
            }
            return b
        },
        add: function(a) {
            var b = a.getCoordinate();
            this.addNode(b).add(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Pc
        }
    });
    g(ob.prototype, {
        compareDirection: function(a) {
            return this.dx === a.dx && this.dy === a.dy ? 0 : this.quadrant > a.quadrant ? 1 : this.quadrant < a.quadrant ? -1 : q.computeOrientation(a.p0, a.p1, this.p1)
        },
        getDy: function() {
            return this.dy
        },
        getCoordinate: function() {
            return this.p0
        },
        setNode: function(a) {
            this.node =
                a
        },
        print: function(a) {
            var b = Math.atan2(this.dy, this.dx),
                c = this.getClass().getName(),
                d = c.lastIndexOf("."),
                c = c.substring(d + 1);
            a.print("  " + c + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + b + "   " + this.label)
        },
        compareTo: function(a) {
            return this.compareDirection(a)
        },
        getDirectedCoordinate: function() {
            return this.p1
        },
        getDx: function() {
            return this.dx
        },
        getLabel: function() {
            return this.label
        },
        getEdge: function() {
            return this.edge
        },
        getQuadrant: function() {
            return this.quadrant
        },
        getNode: function() {
            return this.node
        },
        toString: function() {
            var a = Math.atan2(this.dy, this.dx),
                b = this.getClass().getName(),
                c = b.lastIndexOf(".");
            return "  " + b.substring(c + 1) + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + a + "   " + this.label
        },
        computeLabel: function(a) {},
        init: function(a, b) {
            this.p0 = a;
            this.p1 = b;
            this.dx = b.x - a.x;
            this.dy = b.y - a.y;
            this.quadrant = H.quadrant(this.dx, this.dy);
            t.isTrue(!(0 === this.dx && 0 === this.dy), "EdgeEnd with identical endpoints found")
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return ob
        }
    });
    x(wc, ob);
    g(wc.prototype, {
        getNextMin: function() {
            return this.nextMin
        },
        getDepth: function(a) {
            return this.depth[a]
        },
        setVisited: function(a) {
            this._isVisited = a
        },
        computeDirectedLabel: function() {
            this.label = new ca(this.edge.getLabel());
            this._isForward || this.label.flip()
        },
        getNext: function() {
            return this.next
        },
        setDepth: function(a, b) {
            if (-999 !== this.depth[a] && this.depth[a] !== b) throw new Ja("assigned depths do not match", this.getCoordinate());
            this.depth[a] = b
        },
        isInteriorAreaEdge: function() {
            for (var a = !0, b = 0; 2 > b; b++) this.label.isArea(b) && this.label.getLocation(b,
                p.LEFT) === h.INTERIOR && this.label.getLocation(b, p.RIGHT) === h.INTERIOR || (a = !1);
            return a
        },
        setNextMin: function(a) {
            this.nextMin = a
        },
        print: function(a) {
            ob.prototype.print.call(this, a);
            a.print(" " + this.depth[p.LEFT] + "/" + this.depth[p.RIGHT]);
            a.print(" (" + this.getDepthDelta() + ")");
            this._isInResult && a.print(" inResult")
        },
        setMinEdgeRing: function(a) {
            this.minEdgeRing = a
        },
        isLineEdge: function() {
            var a = this.label.isLine(0) || this.label.isLine(1),
                b = !this.label.isArea(0) || this.label.allPositionsEqual(0, h.EXTERIOR),
                c = !this.label.isArea(1) ||
                this.label.allPositionsEqual(1, h.EXTERIOR);
            return a && b && c
        },
        setEdgeRing: function(a) {
            this.edgeRing = a
        },
        getMinEdgeRing: function() {
            return this.minEdgeRing
        },
        getDepthDelta: function() {
            var a = this.edge.getDepthDelta();
            return this._isForward || (a = -a), a
        },
        setInResult: function(a) {
            this._isInResult = a
        },
        getSym: function() {
            return this.sym
        },
        isForward: function() {
            return this._isForward
        },
        getEdge: function() {
            return this.edge
        },
        printEdge: function(a) {
            this.print(a);
            a.print(" ");
            this._isForward ? this.edge.print(a) : this.edge.printReverse(a)
        },
        setSym: function(a) {
            this.sym = a
        },
        setVisitedEdge: function(a) {
            this.setVisited(a);
            this.sym.setVisited(a)
        },
        setEdgeDepths: function(a, b) {
            var c = this.getEdge().getDepthDelta();
            this._isForward || (c = -c);
            var d = 1;
            a === p.LEFT && (d = -1);
            var e = p.opposite(a),
                c = b + c * d;
            this.setDepth(a, b);
            this.setDepth(e, c)
        },
        getEdgeRing: function() {
            return this.edgeRing
        },
        isInResult: function() {
            return this._isInResult
        },
        setNext: function(a) {
            this.next = a
        },
        isVisited: function() {
            return this._isVisited
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return wc
        }
    });
    wc.depthFactor = function(a, b) {
        return a === h.EXTERIOR && b === h.INTERIOR ? 1 : a === h.INTERIOR && b === h.EXTERIOR ? -1 : 0
    };
    g(xc.prototype, {
        createNode: function(a) {
            return new Gb(a, null)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return xc
        }
    });
    g(pb.prototype, {
        printEdges: function(a) {
            a.println("Edges:");
            for (var b = 0; b < this.edges.size(); b++) {
                a.println("edge " + b + ":");
                var c = this.edges.get(b);
                c.print(a);
                c.eiList.print(a)
            }
        },
        find: function(a) {
            return this.nodes.find(a)
        },
        addNode: function(a) {
            if (a instanceof Gb || a instanceof k) return this.nodes.addNode(a)
        },
        getNodeIterator: function() {
            return this.nodes.iterator()
        },
        linkResultDirectedEdges: function() {
            for (var a = this.nodes.iterator(); a.hasNext();) a.next().getEdges().linkResultDirectedEdges()
        },
        debugPrintln: function(a) {
            U.out.println(a)
        },
        isBoundaryNode: function(a, b) {
            var c = this.nodes.find(b);
            if (null === c) return !1;
            c = c.getLabel();
            return null !== c && c.getLocation(a) === h.BOUNDARY
        },
        linkAllDirectedEdges: function() {
            for (var a = this.nodes.iterator(); a.hasNext();) a.next().getEdges().linkAllDirectedEdges()
        },
        matchInSameDirection: function(a, b, c, d) {
            return !!a.equals(c) && q.computeOrientation(a, b, d) === q.COLLINEAR && H.quadrant(a, b) === H.quadrant(c, d)
        },
        getEdgeEnds: function() {
            return this.edgeEndList
        },
        debugPrint: function(a) {
            U.out.print(a)
        },
        getEdgeIterator: function() {
            return this.edges.iterator()
        },
        findEdgeInSameDirection: function(a, b) {
            for (var c = 0; c < this.edges.size(); c++) {
                var d = this.edges.get(c),
                    e = d.getCoordinates();
                if (this.matchInSameDirection(a, b, e[0], e[1]) || this.matchInSameDirection(a, b, e[e.length - 1], e[e.length -
                        2])) return d
            }
            return null
        },
        insertEdge: function(a) {
            this.edges.add(a)
        },
        findEdgeEnd: function(a) {
            for (var b = this.getEdgeEnds().iterator(); b.hasNext();) {
                var c = b.next();
                if (c.getEdge() === a) return c
            }
            return null
        },
        addEdges: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                this.edges.add(b);
                var c = new wc(b, !0),
                    b = new wc(b, !1);
                c.setSym(b);
                b.setSym(c);
                this.add(c);
                this.add(b)
            }
        },
        add: function(a) {
            this.nodes.add(a);
            this.edgeEndList.add(a)
        },
        getNodes: function() {
            return this.nodes.values()
        },
        findEdge: function(a, b) {
            for (var c =
                    0; c < this.edges.size(); c++) {
                var d = this.edges.get(c),
                    e = d.getCoordinates();
                if (a.equals(e[0]) && b.equals(e[1])) return d
            }
            return null
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return pb
        }
    });
    pb.linkResultDirectedEdges = function(a) {
        for (a = a.iterator(); a.hasNext();) a.next().getEdges().linkResultDirectedEdges()
    };
    g(se.prototype, {
        sortShellsAndHoles: function(a, b, c) {
            for (a = a.iterator(); a.hasNext();) {
                var d = a.next();
                d.isHole() ? c.add(d) : b.add(d)
            }
        },
        computePolygons: function(a) {
            var b = new l;
            for (a = a.iterator(); a.hasNext();) {
                var c =
                    a.next().toPolygon(this.geometryFactory);
                b.add(c)
            }
            return b
        },
        placeFreeHoles: function(a, b) {
            for (var c = b.iterator(); c.hasNext();) {
                var d = c.next();
                if (null === d.getShell()) {
                    var e = this.findEdgeRingContaining(d, a);
                    if (null === e) throw new Ja("unable to assign hole to a shell", d.getCoordinate(0));
                    d.setShell(e)
                }
            }
        },
        buildMinimalEdgeRings: function(a, b, c) {
            var d = new l;
            for (a = a.iterator(); a.hasNext();) {
                var e = a.next();
                if (2 < e.getMaxNodeDegree()) {
                    e.linkDirectedEdgesForMinimalEdgeRings();
                    var e = e.buildMinimalRings(),
                        f = this.findShell(e);
                    null !== f ? (this.placePolygonHoles(f, e), b.add(f)) : c.addAll(e)
                } else d.add(e)
            }
            return d
        },
        containsPoint: function(a) {
            for (var b = this.shellList.iterator(); b.hasNext();)
                if (b.next().containsPoint(a)) return !0;
            return !1
        },
        buildMaximalEdgeRings: function(a) {
            var b = new l;
            for (a = a.iterator(); a.hasNext();) {
                var c = a.next();
                c.isInResult() && c.getLabel().isArea() && null === c.getEdgeRing() && (c = new vd(c, this.geometryFactory), b.add(c), c.setInResult())
            }
            return b
        },
        placePolygonHoles: function(a, b) {
            for (var c = b.iterator(); c.hasNext();) {
                var d =
                    c.next();
                d.isHole() && d.setShell(a)
            }
        },
        getPolygons: function() {
            return this.computePolygons(this.shellList)
        },
        findEdgeRingContaining: function(a, b) {
            for (var c = a.getLinearRing(), d = c.getEnvelopeInternal(), c = c.getCoordinateN(0), e = null, f = null, g = b.iterator(); g.hasNext();) {
                var h = g.next(),
                    k = h.getLinearRing(),
                    l = k.getEnvelopeInternal();
                null !== e && (f = e.getLinearRing().getEnvelopeInternal());
                var m = !1;
                l.contains(d) && q.isPointInRing(c, k.getCoordinates()) && (m = !0);
                m && (null === e || f.contains(l)) && (e = h)
            }
            return e
        },
        findShell: function(a) {
            var b =
                0,
                c = null;
            for (a = a.iterator(); a.hasNext();) {
                var d = a.next();
                d.isHole() || (c = d, b++)
            }
            return t.isTrue(1 >= b, "found two shells in MinimalEdgeRing list"), c
        },
        add: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.add(a.getEdgeEnds(), a.getNodes())
            } else if (2 === arguments.length) {
                a = arguments[0];
                pb.linkResultDirectedEdges(arguments[1]);
                var b = this.buildMaximalEdgeRings(a),
                    a = new l,
                    b = this.buildMinimalEdgeRings(b, this.shellList, a);
                this.sortShellsAndHoles(b, this.shellList, a);
                this.placeFreeHoles(this.shellList,
                    a)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return se
        }
    });
    g(Ef.prototype, {
        collectLines: function(a) {
            for (var b = this.op.getGraph().getEdgeEnds().iterator(); b.hasNext();) {
                var c = b.next();
                this.collectLineEdge(c, a, this.lineEdgesList);
                this.collectBoundaryTouchEdge(c, a, this.lineEdgesList)
            }
        },
        labelIsolatedLine: function(a, b) {
            var c = this.ptLocator.locate(a.getCoordinate(), this.op.getArgGeometry(b));
            a.getLabel().setLocation(b, c)
        },
        build: function(a) {
            return this.findCoveredLineEdges(), this.collectLines(a),
                this.buildLines(a), this.resultLineList
        },
        collectLineEdge: function(a, b, c) {
            var d = a.getLabel(),
                e = a.getEdge();
            a.isLineEdge() && (a.isVisited() || !w.isResultOfOp(d, b) || e.isCovered() || (c.add(e), a.setVisitedEdge(!0)))
        },
        findCoveredLineEdges: function() {
            for (var a = this.op.getGraph().getNodes().iterator(); a.hasNext();) a.next().getEdges().findCoveredLineEdges();
            for (a = this.op.getGraph().getEdgeEnds().iterator(); a.hasNext();) {
                var b = a.next(),
                    c = b.getEdge();
                b.isLineEdge() && !c.isCoveredSet() && (b = this.op.isCoveredByA(b.getCoordinate()),
                    c.setCovered(b))
            }
        },
        labelIsolatedLines: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next(),
                    c = b.getLabel();
                b.isIsolated() && (c.isNull(0) ? this.labelIsolatedLine(b, 0) : this.labelIsolatedLine(b, 1))
            }
        },
        buildLines: function(a) {
            for (a = this.lineEdgesList.iterator(); a.hasNext();) {
                var b = a.next(),
                    c = (b.getLabel(), this.geometryFactory.createLineString(b.getCoordinates()));
                this.resultLineList.add(c);
                b.setInResult(!0)
            }
        },
        collectBoundaryTouchEdge: function(a, b, c) {
            var d = a.getLabel();
            return a.isLineEdge() ? null : a.isVisited() ?
                null : a.isInteriorAreaEdge() ? null : a.getEdge().isInResult() ? null : (t.isTrue(!(a.isInResult() || a.getSym().isInResult()) || !a.getEdge().isInResult()), void(w.isResultOfOp(d, b) && b === w.INTERSECTION && (c.add(a.getEdge()), a.setVisitedEdge(!0))))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ef
        }
    });
    g(Ff.prototype, {
        filterCoveredNodeToPoint: function(a) {
            a = a.getCoordinate();
            this.op.isCoveredByLA(a) || (a = this.geometryFactory.createPoint(a), this.resultPointList.add(a))
        },
        extractNonCoveredResultNodes: function(a) {
            for (var b =
                    this.op.getGraph().getNodes().iterator(); b.hasNext();) {
                var c = b.next();
                if (!(c.isInResult() || c.isIncidentEdgeInResult() || 0 !== c.getEdges().getDegree() && a !== w.INTERSECTION)) {
                    var d = c.getLabel();
                    w.isResultOfOp(d, a) && this.filterCoveredNodeToPoint(c)
                }
            }
        },
        build: function(a) {
            return this.extractNonCoveredResultNodes(a), this.resultPointList
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ff
        }
    });
    g(te.prototype, {
        locate: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return te
        }
    });
    g(Sa.prototype, {
        locate: function(a) {
            return Sa.locate(a, this.geom)
        },
        interfaces_: function() {
            return [te]
        },
        getClass: function() {
            return Sa
        }
    });
    Sa.isPointInRing = function(a, b) {
        return !!b.getEnvelopeInternal().intersects(a) && q.isPointInRing(a, b.getCoordinates())
    };
    Sa.containsPointInPolygon = function(a, b) {
        if (b.isEmpty()) return !1;
        var c = b.getExteriorRing();
        if (!Sa.isPointInRing(a, c)) return !1;
        for (c = 0; c < b.getNumInteriorRing(); c++) {
            var d = b.getInteriorRingN(c);
            if (Sa.isPointInRing(a, d)) return !1
        }
        return !0
    };
    Sa.containsPoint = function(a, b) {
        if (b instanceof O) return Sa.containsPointInPolygon(a, b);
        if (b instanceof F)
            for (var c = new tc(b); c.hasNext();) {
                var d = c.next();
                if (d !== b && Sa.containsPoint(a, d)) return !0
            }
        return !1
    };
    Sa.locate = function(a, b) {
        return b.isEmpty() ? h.EXTERIOR : Sa.containsPoint(a, b) ? h.INTERIOR : h.EXTERIOR
    };
    g(yc.prototype, {
        getNextCW: function(a) {
            this.getEdges();
            a = this.edgeList.indexOf(a);
            var b = a - 1;
            return 0 === a && (b = this.edgeList.size() - 1), this.edgeList.get(b)
        },
        propagateSideLabels: function(a) {
            for (var b = h.NONE, c = this.iterator(); c.hasNext();) {
                var d = c.next(),
                    e = d.getLabel();
                e.isArea(a) && e.getLocation(a, p.LEFT) !== h.NONE && (b = e.getLocation(a, p.LEFT))
            }
            if (b === h.NONE) return null;
            for (c = this.iterator(); c.hasNext();)
                if (d = c.next(), e = d.getLabel(), e.getLocation(a, p.ON) === h.NONE && e.setLocation(a, p.ON, b), e.isArea(a)) {
                    var f = e.getLocation(a, p.LEFT),
                        g = e.getLocation(a, p.RIGHT);
                    if (g !== h.NONE) {
                        if (g !== b) throw new Ja("side location conflict", d.getCoordinate());
                        f === h.NONE && t.shouldNeverReachHere("found single null side (at " + d.getCoordinate() + ")");
                        b = f
                    } else t.isTrue(e.getLocation(a,
                        p.LEFT) === h.NONE, "found single null side"), e.setLocation(a, p.RIGHT, b), e.setLocation(a, p.LEFT, b)
                }
        },
        getCoordinate: function() {
            var a = this.iterator();
            return a.hasNext() ? a.next().getCoordinate() : null
        },
        print: function(a) {
            U.out.println("EdgeEndStar:   " + this.getCoordinate());
            for (var b = this.iterator(); b.hasNext();) b.next().print(a)
        },
        isAreaLabelsConsistent: function(a) {
            return this.computeEdgeEndLabels(a.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0)
        },
        checkAreaLabelsConsistent: function(a) {
            var b = this.getEdges();
            if (0 >= b.size()) return !0;
            var c = b.size() - 1,
                b = b.get(c).getLabel().getLocation(a, p.LEFT);
            t.isTrue(b !== h.NONE, "Found unlabelled area edge");
            for (c = this.iterator(); c.hasNext();) {
                var d = c.next().getLabel();
                t.isTrue(d.isArea(a), "Found non-area edge");
                var e = d.getLocation(a, p.LEFT),
                    d = d.getLocation(a, p.RIGHT);
                if (e === d || d !== b) return !1;
                b = e
            }
            return !0
        },
        findIndex: function(a) {
            this.iterator();
            for (var b = 0; b < this.edgeList.size(); b++)
                if (this.edgeList.get(b) === a) return b;
            return -1
        },
        iterator: function() {
            return this.getEdges().iterator()
        },
        getEdges: function() {
            return null === this.edgeList && (this.edgeList = new l(this.edgeMap.values())), this.edgeList
        },
        getLocation: function(a, b, c) {
            return this.ptInAreaLocation[a] === h.NONE && (this.ptInAreaLocation[a] = Sa.locate(b, c[a].getGeometry())), this.ptInAreaLocation[a]
        },
        toString: function() {
            var a = new Ya;
            a.append("EdgeEndStar:   " + this.getCoordinate());
            a.append("\n");
            for (var b = this.iterator(); b.hasNext();) {
                var c = b.next();
                a.append(c);
                a.append("\n")
            }
            return a.toString()
        },
        computeEdgeEndLabels: function(a) {
            for (var b =
                    this.iterator(); b.hasNext();) b.next().computeLabel(a)
        },
        computeLabelling: function(a) {
            this.computeEdgeEndLabels(a[0].getBoundaryNodeRule());
            this.propagateSideLabels(0);
            this.propagateSideLabels(1);
            for (var b = [!1, !1], c = this.iterator(); c.hasNext();)
                for (var d = c.next(), e = d.getLabel(), f = 0; 2 > f; f++) e.isLine(f) && e.getLocation(f) === h.BOUNDARY && (b[f] = !0);
            for (c = this.iterator(); c.hasNext();)
                for (d = c.next(), e = d.getLabel(), f = 0; 2 > f; f++)
                    if (e.isAnyNull(f)) {
                        var g = h.NONE;
                        b[f] ? g = h.EXTERIOR : (g = d.getCoordinate(), g = this.getLocation(f,
                            g, a));
                        e.setAllLocationsIfNull(f, g)
                    }
        },
        getDegree: function() {
            return this.edgeMap.size()
        },
        insertEdgeEnd: function(a, b) {
            this.edgeMap.put(a, b);
            this.edgeList = null
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return yc
        }
    });
    x(ue, yc);
    g(ue.prototype, {
        linkResultDirectedEdges: function() {
            this.getResultAreaEdges();
            for (var a = null, b = null, c = this.SCANNING_FOR_INCOMING, d = 0; d < this.resultAreaEdgeList.size(); d++) {
                var e = this.resultAreaEdgeList.get(d),
                    f = e.getSym();
                if (e.getLabel().isArea()) switch (null === a && e.isInResult() &&
                    (a = e), c) {
                    case this.SCANNING_FOR_INCOMING:
                        if (!f.isInResult()) continue;
                        b = f;
                        c = this.LINKING_TO_OUTGOING;
                        break;
                    case this.LINKING_TO_OUTGOING:
                        e.isInResult() && (b.setNext(e), c = this.SCANNING_FOR_INCOMING)
                }
            }
            if (c === this.LINKING_TO_OUTGOING) {
                if (null === a) throw new Ja("no outgoing dirEdge found", this.getCoordinate());
                t.isTrue(a.isInResult(), "unable to link last incoming dirEdge");
                b.setNext(a)
            }
        },
        insert: function(a) {
            this.insertEdgeEnd(a, a)
        },
        getRightmostEdge: function() {
            var a = this.getEdges(),
                b = a.size();
            if (1 > b) return null;
            var c = a.get(0);
            if (1 === b) return c;
            var a = a.get(b - 1),
                b = c.getQuadrant(),
                d = a.getQuadrant();
            return H.isNorthern(b) && H.isNorthern(d) ? c : H.isNorthern(b) || H.isNorthern(d) ? 0 !== c.getDy() ? c : 0 !== a.getDy() ? a : (t.shouldNeverReachHere("found two horizontal edges incident on node"), null) : a
        },
        print: function(a) {
            U.out.println("DirectedEdgeStar: " + this.getCoordinate());
            for (var b = this.iterator(); b.hasNext();) {
                var c = b.next();
                a.print("out ");
                c.print(a);
                a.println();
                a.print("in ");
                c.getSym().print(a);
                a.println()
            }
        },
        getResultAreaEdges: function() {
            if (null !==
                this.resultAreaEdgeList) return this.resultAreaEdgeList;
            this.resultAreaEdgeList = new l;
            for (var a = this.iterator(); a.hasNext();) {
                var b = a.next();
                (b.isInResult() || b.getSym().isInResult()) && this.resultAreaEdgeList.add(b)
            }
            return this.resultAreaEdgeList
        },
        updateLabelling: function(a) {
            for (var b = this.iterator(); b.hasNext();) {
                var c = b.next().getLabel();
                c.setAllLocationsIfNull(0, a.getLocation(0));
                c.setAllLocationsIfNull(1, a.getLocation(1))
            }
        },
        linkAllDirectedEdges: function() {
            this.getEdges();
            for (var a = null, b = null, c =
                    this.edgeList.size() - 1; 0 <= c; c--) {
                var d = this.edgeList.get(c),
                    e = d.getSym();
                null === b && (b = e);
                null !== a && e.setNext(a);
                a = d
            }
            b.setNext(a)
        },
        computeDepths: function() {
            if (1 === arguments.length) {
                var a = arguments[0],
                    b = this.findIndex(a),
                    c = (a.getLabel(), a.getDepth(p.LEFT)),
                    d = a.getDepth(p.RIGHT),
                    c = this.computeDepths(b + 1, this.edgeList.size(), c);
                if (this.computeDepths(0, b, c) !== d) throw new Ja("depth mismatch at " + a.getCoordinate());
            } else if (3 === arguments.length) {
                a = arguments[1];
                b = arguments[2];
                for (d = arguments[0]; d < a; d++) c =
                    this.edgeList.get(d), c.getLabel(), c.setEdgeDepths(p.RIGHT, b), b = c.getDepth(p.LEFT);
                return b
            }
        },
        mergeSymLabels: function() {
            for (var a = this.iterator(); a.hasNext();) {
                var b = a.next();
                b.getLabel().merge(b.getSym().getLabel())
            }
        },
        linkMinimalDirectedEdges: function(a) {
            for (var b = null, c = null, d = this.SCANNING_FOR_INCOMING, e = this.resultAreaEdgeList.size() - 1; 0 <= e; e--) {
                var f = this.resultAreaEdgeList.get(e),
                    g = f.getSym();
                switch (null === b && f.getEdgeRing() === a && (b = f), d) {
                    case this.SCANNING_FOR_INCOMING:
                        if (g.getEdgeRing() !==
                            a) continue;
                        c = g;
                        d = this.LINKING_TO_OUTGOING;
                        break;
                    case this.LINKING_TO_OUTGOING:
                        f.getEdgeRing() === a && (c.setNextMin(f), d = this.SCANNING_FOR_INCOMING)
                }
            }
            d === this.LINKING_TO_OUTGOING && (t.isTrue(null !== b, "found null for first outgoing dirEdge"), t.isTrue(b.getEdgeRing() === a, "unable to link last incoming dirEdge"), c.setNextMin(b))
        },
        getOutgoingDegree: function() {
            if (0 === arguments.length) {
                for (var a = 0, b = this.iterator(); b.hasNext();) {
                    var c = b.next();
                    c.isInResult() && a++
                }
                return a
            }
            if (1 === arguments.length) {
                for (var d =
                        arguments[0], a = 0, b = this.iterator(); b.hasNext();) c = b.next(), c.getEdgeRing() === d && a++;
                return a
            }
        },
        getLabel: function() {
            return this.label
        },
        findCoveredLineEdges: function() {
            for (var a = h.NONE, b = this.iterator(); b.hasNext();) {
                var c = b.next(),
                    d = c.getSym();
                if (!c.isLineEdge()) {
                    if (c.isInResult()) {
                        a = h.INTERIOR;
                        break
                    }
                    if (d.isInResult()) {
                        a = h.EXTERIOR;
                        break
                    }
                }
            }
            if (a === h.NONE) return null;
            for (b = this.iterator(); b.hasNext();) c = b.next(), d = c.getSym(), c.isLineEdge() ? c.getEdge().setCovered(a === h.INTERIOR) : (c.isInResult() && (a = h.EXTERIOR),
                d.isInResult() && (a = h.INTERIOR))
        },
        computeLabelling: function(a) {
            yc.prototype.computeLabelling.call(this, a);
            this.label = new ca(h.NONE);
            for (a = this.iterator(); a.hasNext();)
                for (var b = a.next().getEdge().getLabel(), c = 0; 2 > c; c++) {
                    var d = b.getLocation(c);
                    d !== h.INTERIOR && d !== h.BOUNDARY || this.label.setLocation(c, h.INTERIOR)
                }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ue
        }
    });
    x(Qc, xc);
    g(Qc.prototype, {
        createNode: function(a) {
            return new Gb(a, new ue)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Qc
        }
    });
    g(Gf.prototype, {
        computeIntersections: function(a, b) {
            this.mce.computeIntersectsForChain(this.chainIndex, a.mce, a.chainIndex, b)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Gf
        }
    });
    g(Hb.prototype, {
        isDelete: function() {
            return this.eventType === Hb.DELETE
        },
        setDeleteEventIndex: function(a) {
            this.deleteEventIndex = a
        },
        getObject: function() {
            return this.obj
        },
        compareTo: function(a) {
            return this.xValue < a.xValue ? -1 : this.xValue > a.xValue ? 1 : this.eventType < a.eventType ? -1 : this.eventType > a.eventType ? 1 : 0
        },
        getInsertEvent: function() {
            return this.insertEvent
        },
        isInsert: function() {
            return this.eventType === Hb.INSERT
        },
        isSameLabel: function(a) {
            return null !== this.label && this.label === a.label
        },
        getDeleteEventIndex: function() {
            return this.deleteEventIndex
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return Hb
        }
    });
    Hb.INSERT = 1;
    Hb.DELETE = 2;
    g(ve.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ve
        }
    });
    g(bc.prototype, {
        isTrivialIntersection: function(a, b, c, d) {
            return a === c && 1 === this.li.getIntersectionNum() && (bc.isAdjacentSegments(b, d) || a.isClosed() &&
                (a = a.getNumPoints() - 1, 0 === b && d === a || 0 === d && b === a)) ? !0 : !1
        },
        getProperIntersectionPoint: function() {
            return this.properIntersectionPoint
        },
        setIsDoneIfProperInt: function(a) {
            this.isDoneWhenProperInt = a
        },
        hasProperInteriorIntersection: function() {
            return this.hasProperInterior
        },
        isBoundaryPointInternal: function(a, b) {
            for (var c = b.iterator(); c.hasNext();) {
                var d = c.next().getCoordinate();
                if (a.isIntersection(d)) return !0
            }
            return !1
        },
        hasProperIntersection: function() {
            return this.hasProper
        },
        hasIntersection: function() {
            return this._hasIntersection
        },
        isDone: function() {
            return this._isDone
        },
        isBoundaryPoint: function(a, b) {
            return null !== b && (!!this.isBoundaryPointInternal(a, b[0]) || !!this.isBoundaryPointInternal(a, b[1]))
        },
        setBoundaryNodes: function(a, b) {
            this.bdyNodes = Array(2).fill(null);
            this.bdyNodes[0] = a;
            this.bdyNodes[1] = b
        },
        addIntersections: function(a, b, c, d) {
            if (a === c && b === d) return null;
            this.numTests++;
            var e = a.getCoordinates()[b],
                f = a.getCoordinates()[b + 1],
                g = c.getCoordinates()[d],
                h = c.getCoordinates()[d + 1];
            this.li.computeIntersection(e, f, g, h);
            this.li.hasIntersection() &&
                (this.recordIsolated && (a.setIsolated(!1), c.setIsolated(!1)), this.numIntersections++, this.isTrivialIntersection(a, b, c, d) || (this._hasIntersection = !0, !this.includeProper && this.li.isProper() || (a.addIntersections(this.li, b, 0), c.addIntersections(this.li, d, 1)), this.li.isProper() && (this.properIntersectionPoint = this.li.getIntersection(0).copy(), this.hasProper = !0, this.isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this.li, this.bdyNodes) || (this.hasProperInterior = !0))))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return bc
        }
    });
    bc.isAdjacentSegments = function(a, b) {
        return 1 === Math.abs(a - b)
    };
    x(we, ve);
    g(we.prototype, {
        prepareEvents: function() {
            vb.sort(this.events);
            for (var a = 0; a < this.events.size(); a++) {
                var b = this.events.get(a);
                b.isDelete() && b.getInsertEvent().setDeleteEventIndex(a)
            }
        },
        computeIntersections: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.nOverlaps = 0;
                this.prepareEvents();
                for (var b = 0; b < this.events.size(); b++) {
                    var c = this.events.get(b);
                    if (c.isInsert() && this.processOverlaps(b,
                            c.getDeleteEventIndex(), c, a), a.isDone()) break
                }
            } else 3 === arguments.length && (arguments[2] instanceof bc && u(arguments[0], ga) && u(arguments[1], ga) ? (a = arguments[0], b = arguments[1], c = arguments[2], this.addEdges(a, a), this.addEdges(b, b), this.computeIntersections(c)) : "boolean" == typeof arguments[2] && u(arguments[0], ga) && arguments[1] instanceof bc && (a = arguments[0], b = arguments[1], arguments[2] ? this.addEdges(a, null) : this.addEdges(a), this.computeIntersections(b)))
        },
        addEdge: function(a, b) {
            for (var c = a.getMonotoneChainEdge(),
                    d = c.getStartIndexes(), e = 0; e < d.length - 1; e++) {
                var f = new Gf(c, e),
                    f = new Hb(b, c.getMinX(e), f);
                this.events.add(f);
                this.events.add(new Hb(c.getMaxX(e), f))
            }
        },
        processOverlaps: function(a, b, c, d) {
            for (var e = c.getObject(); a < b; a++) {
                var f = this.events.get(a);
                if (f.isInsert()) {
                    var g = f.getObject();
                    c.isSameLabel(f) || (e.computeIntersections(g, d), this.nOverlaps++)
                }
            }
        },
        addEdges: function() {
            if (1 === arguments.length)
                for (var a = arguments[0].iterator(); a.hasNext();) {
                    var b = a.next();
                    this.addEdge(b, b)
                } else if (2 === arguments.length)
                    for (var c =
                            arguments[1], a = arguments[0].iterator(); a.hasNext();) b = a.next(), this.addEdge(b, c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return we
        }
    });
    g(zc.prototype, {
        getMin: function() {
            return this.min
        },
        intersects: function(a, b) {
            return !(this.min > b || this.max < a)
        },
        getMax: function() {
            return this.max
        },
        toString: function() {
            return ra.toLineString(new k(this.min, 0), new k(this.max, 0))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return zc
        }
    });
    g(Hf.prototype, {
        compare: function(a, b) {
            var c = (a.min + a.max) / 2,
                d =
                (b.min + b.max) / 2;
            return c < d ? -1 : c > d ? 1 : 0
        },
        interfaces_: function() {
            return [Wb]
        },
        getClass: function() {
            return Hf
        }
    });
    zc.NodeComparator = Hf;
    x(xe, zc);
    g(xe.prototype, {
        query: function(a, b, c) {
            if (!this.intersects(a, b)) return null;
            c.visitItem(this.item)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return xe
        }
    });
    x(ye, zc);
    g(ye.prototype, {
        buildExtent: function(a, b) {
            this.min = Math.min(a.min, b.min);
            this.max = Math.max(a.max, b.max)
        },
        query: function(a, b, c) {
            if (!this.intersects(a, b)) return null;
            null !== this.node1 && this.node1.query(a,
                b, c);
            null !== this.node2 && this.node2.query(a, b, c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ye
        }
    });
    g(If.prototype, {
        buildTree: function() {
            vb.sort(this.leaves, new IntervalRTreeNode.NodeComparator);
            for (var a = this.leaves, b = null, c = new l;;) {
                if (this.buildLevel(a, c), 1 === c.size()) return c.get(0);
                b = a;
                a = c;
                c = b
            }
        },
        insert: function(a, b, c) {
            if (null !== this.root) throw new IllegalStateException("Index cannot be added to once it has been queried");
            this.leaves.add(new xe(a, b, c))
        },
        query: function(a, b, c) {
            this.init();
            this.root.query(a, b, c)
        },
        buildRoot: function() {
            if (null !== this.root) return null;
            this.root = this.buildTree()
        },
        printNode: function(a) {
            U.out.println(ra.toLineString(new k(a.min, this.level), new k(a.max, this.level)))
        },
        init: function() {
            if (null !== this.root) return null;
            this.buildRoot()
        },
        buildLevel: function(a, b) {
            this.level++;
            b.clear();
            for (var c = 0; c < a.size(); c += 2) {
                var d = a.get(c);
                null !== (c + 1 < a.size() ? a.get(c) : null) && (d = new ye(a.get(c), a.get(c + 1)));
                b.add(d)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return If
        }
    });
    g(sa.prototype, {
        filter: function(a) {
            if (this.isForcedToLineString && a instanceof aa) return a = a.getFactory().createLineString(a.getCoordinateSequence()), this.lines.add(a), null;
            a instanceof C && this.lines.add(a)
        },
        setForceToLineString: function(a) {
            this.isForcedToLineString = a
        },
        interfaces_: function() {
            return [eb]
        },
        getClass: function() {
            return sa
        }
    });
    sa.getGeometry = function() {
        if (1 === arguments.length) {
            var a = arguments[0];
            return a.getFactory().buildGeometry(sa.getLines(a))
        }
        if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            return a.getFactory().buildGeometry(sa.getLines(a, b))
        }
    };
    sa.getLines = function() {
        if (1 === arguments.length) return sa.getLines(arguments[0], !1);
        if (2 === arguments.length) {
            if (u(arguments[0], T) && u(arguments[1], T)) {
                for (var a = arguments[1], b = arguments[0].iterator(); b.hasNext();) {
                    var c = b.next();
                    sa.getLines(c, a)
                }
                return a
            }
            if (arguments[0] instanceof r && "boolean" == typeof arguments[1]) return b = arguments[0], c = arguments[1], a = new l, b.apply(new sa(a, c)), a;
            if (arguments[0] instanceof r && u(arguments[1], T)) return b =
                arguments[0], c = arguments[1], b instanceof C ? c.add(b) : b.apply(new sa(c)), c
        } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && u(arguments[0], T) && u(arguments[1], T)) {
                for (var a = arguments[1], d = arguments[2], b = arguments[0].iterator(); b.hasNext();) c = b.next(), sa.getLines(c, a, d);
                return a
            }
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof r && u(arguments[1], T)) return b = arguments[1], arguments[0].apply(new sa(b, arguments[2])), b
        }
    };
    g(ze.prototype, {
        visitItem: function(a) {
            this.items.add(a)
        },
        getItems: function() {
            return this.items
        },
        interfaces_: function() {
            return [Zb]
        },
        getClass: function() {
            return ze
        }
    });
    g(wd.prototype, {
        locate: function(a) {
            var b = new sc(a),
                c = new Be(b);
            return this.index.query(a.y, a.y, c), b.getLocation()
        },
        interfaces_: function() {
            return [te]
        },
        getClass: function() {
            return wd
        }
    });
    g(Be.prototype, {
        visitItem: function(a) {
            this.counter.countSegment(a.getCoordinate(0), a.getCoordinate(1))
        },
        interfaces_: function() {
            return [Zb]
        },
        getClass: function() {
            return Be
        }
    });
    g(Ae.prototype, {
        init: function(a) {
            for (a = sa.getLines(a).iterator(); a.hasNext();) {
                var b =
                    a.next().getCoordinates();
                this.addLine(b)
            }
        },
        addLine: function(a) {
            for (var b = 1; b < a.length; b++) {
                var c = new A(a[b - 1], a[b]);
                this.index.insert(Math.min(c.p0.y, c.p1.y), Math.max(c.p0.y, c.p1.y), c)
            }
        },
        query: function() {
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = new ze;
                return this.index.query(a, b, c), c.getItems()
            }
            3 === arguments.length && this.index.query(arguments[0], arguments[1], arguments[2])
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ae
        }
    });
    wd.SegmentVisitor = Be;
    wd.IntervalIndexedGeometry =
        Ae;
    g(Jf.prototype, {
        getSegmentIndex: function() {
            return this.segmentIndex
        },
        getCoordinate: function() {
            return this.coord
        },
        print: function(a) {
            a.print(this.coord);
            a.print(" seg # \x3d " + this.segmentIndex);
            a.println(" dist \x3d " + this.dist)
        },
        compareTo: function(a) {
            return this.compare(a.segmentIndex, a.dist)
        },
        isEndPoint: function(a) {
            return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === a
        },
        toString: function() {
            return this.coord + " seg # \x3d " + this.segmentIndex + " dist \x3d " + this.dist
        },
        getDistance: function() {
            return this.dist
        },
        compare: function(a, b) {
            return this.segmentIndex < a ? -1 : this.segmentIndex > a ? 1 : this.dist < b ? -1 : this.dist > b ? 1 : 0
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return Jf
        }
    });
    g(Kf.prototype, {
        print: function(a) {
            a.println("Intersections:");
            for (var b = this.iterator(); b.hasNext();) b.next().print(a)
        },
        iterator: function() {
            return this.nodeMap.values().iterator()
        },
        addSplitEdges: function(a) {
            this.addEndpoints();
            for (var b = this.iterator(), c = b.next(); b.hasNext();) {
                var d = b.next(),
                    c = this.createSplitEdge(c, d);
                a.add(c);
                c = d
            }
        },
        addEndpoints: function() {
            var a = this.edge.pts.length - 1;
            this.add(this.edge.pts[0], 0, 0);
            this.add(this.edge.pts[a], a, 0)
        },
        createSplitEdge: function(a, b) {
            var c = b.segmentIndex - a.segmentIndex + 2,
                d = this.edge.pts[b.segmentIndex];
            (d = 0 < b.dist || !b.coord.equals2D(d)) || c--;
            var c = Array(c).fill(null),
                e = 0;
            c[e++] = new k(a.coord);
            for (var f = a.segmentIndex + 1; f <= b.segmentIndex; f++) c[e++] = this.edge.pts[f];
            return d && (c[e] = b.coord), new $a(c, new ca(this.edge.label))
        },
        add: function(a, b, c) {
            a = new Jf(a, b, c);
            b = this.nodeMap.get(a);
            return null !== b ? b : (this.nodeMap.put(a, a), a)
        },
        isIntersection: function(a) {
            for (var b = this.iterator(); b.hasNext();)
                if (b.next().coord.equals(a)) return !0;
            return !1
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Kf
        }
    });
    g(xd.prototype, {
        getChainStartIndices: function(a) {
            var b = 0,
                c = new l;
            c.add(new db(b));
            do b = this.findChainEnd(a, b), c.add(new db(b)); while (b < a.length - 1);
            return xd.toIntArray(c)
        },
        findChainEnd: function(a, b) {
            for (var c = H.quadrant(a[b], a[b + 1]), d = b + 1; d < a.length && H.quadrant(a[d - 1], a[d]) ===
                c;) d++;
            return d - 1
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return xd
        }
    });
    xd.toIntArray = function(a) {
        for (var b = Array(a.size()).fill(null), c = 0; c < b.length; c++) b[c] = a.get(c).intValue();
        return b
    };
    g(Lf.prototype, {
        getCoordinates: function() {
            return this.pts
        },
        getMaxX: function(a) {
            var b = this.pts[this.startIndex[a]].x;
            a = this.pts[this.startIndex[a + 1]].x;
            return b > a ? b : a
        },
        getMinX: function(a) {
            var b = this.pts[this.startIndex[a]].x;
            a = this.pts[this.startIndex[a + 1]].x;
            return b < a ? b : a
        },
        computeIntersectsForChain: function() {
            if (4 ===
                arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = arguments[2];
                this.computeIntersectsForChain(this.startIndex[a], this.startIndex[a + 1], b, b.startIndex[c], b.startIndex[c + 1], arguments[3])
            } else if (6 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = arguments[2],
                    d = arguments[3],
                    e = arguments[4],
                    f = arguments[5],
                    g = this.pts[a],
                    h = this.pts[b],
                    k = c.pts[d],
                    l = c.pts[e];
                if (1 == b - a && 1 == e - d) return f.addIntersections(this.e, a, c.e, d), null;
                if (this.env1.init(g, h), this.env2.init(k, l), !this.env1.intersects(this.env2)) return null;
                g = Math.trunc((a + b) / 2);
                h = Math.trunc((d + e) / 2);
                a < g && (d < h && this.computeIntersectsForChain(a, g, c, d, h, f), h < e && this.computeIntersectsForChain(a, g, c, h, e, f));
                g < b && (d < h && this.computeIntersectsForChain(g, b, c, d, h, f), h < e && this.computeIntersectsForChain(g, b, c, h, e, f))
            }
        },
        getStartIndexes: function() {
            return this.startIndex
        },
        computeIntersects: function(a, b) {
            for (var c = 0; c < this.startIndex.length - 1; c++)
                for (var d = 0; d < a.startIndex.length - 1; d++) this.computeIntersectsForChain(c, a, d, b)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Lf
        }
    });
    g(gb.prototype, {
        getDepth: function(a, b) {
            return this.depth[a][b]
        },
        setDepth: function(a, b, c) {
            this.depth[a][b] = c
        },
        isNull: function() {
            if (0 === arguments.length) {
                for (var a = 0; 2 > a; a++)
                    for (var b = 0; 3 > b; b++)
                        if (this.depth[a][b] !== gb.NULL_VALUE) return !1;
                return !0
            }
            if (1 === arguments.length) return this.depth[arguments[0]][1] === gb.NULL_VALUE;
            if (2 === arguments.length) return this.depth[arguments[0]][arguments[1]] === gb.NULL_VALUE
        },
        normalize: function() {
            for (var a = 0; 2 > a; a++)
                if (!this.isNull(a)) {
                    var b = this.depth[a][1];
                    this.depth[a][2] <
                        b && (b = this.depth[a][2]);
                    0 > b && (b = 0);
                    for (var c = 1; 3 > c; c++) {
                        var d = 0;
                        this.depth[a][c] > b && (d = 1);
                        this.depth[a][c] = d
                    }
                }
        },
        getDelta: function(a) {
            return this.depth[a][p.RIGHT] - this.depth[a][p.LEFT]
        },
        getLocation: function(a, b) {
            return 0 >= this.depth[a][b] ? h.EXTERIOR : h.INTERIOR
        },
        toString: function() {
            return "A: " + this.depth[0][1] + "," + this.depth[0][2] + " B: " + this.depth[1][1] + "," + this.depth[1][2]
        },
        add: function() {
            if (1 === arguments.length)
                for (var a = arguments[0], b = 0; 2 > b; b++)
                    for (var c = 1; 3 > c; c++) {
                        var d = a.getLocation(b, c);
                        d !==
                            h.EXTERIOR && d !== h.INTERIOR || (this.isNull(b, c) ? this.depth[b][c] = gb.depthAtLocation(d) : this.depth[b][c] += gb.depthAtLocation(d))
                    } else 3 === arguments.length && (a = arguments[0], b = arguments[1], arguments[2] === h.INTERIOR && this.depth[a][b]++)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return gb
        }
    });
    gb.depthAtLocation = function(a) {
        return a === h.EXTERIOR ? 0 : a === h.INTERIOR ? 1 : gb.NULL_VALUE
    };
    gb.NULL_VALUE = -1;
    x($a, ac);
    g($a.prototype, {
        getDepth: function() {
            return this.depth
        },
        getCollapsedEdge: function() {
            var a = Array(2).fill(null);
            return a[0] = this.pts[0], a[1] = this.pts[1], new $a(a, ca.toLineLabel(this.label))
        },
        isIsolated: function() {
            return this._isIsolated
        },
        getCoordinates: function() {
            return this.pts
        },
        setIsolated: function(a) {
            this._isIsolated = a
        },
        setName: function(a) {
            this.name = a
        },
        equals: function(a) {
            if (!(a instanceof $a) || this.pts.length !== a.pts.length) return !1;
            for (var b = !0, c = !0, d = this.pts.length, e = 0; e < this.pts.length; e++)
                if (this.pts[e].equals2D(a.pts[e]) || (b = !1), this.pts[e].equals2D(a.pts[--d]) || (c = !1), !b && !c) return !1;
            return !0
        },
        getCoordinate: function() {
            if (0 ===
                arguments.length) return 0 < this.pts.length ? this.pts[0] : null;
            if (1 === arguments.length) return this.pts[arguments[0]]
        },
        print: function(a) {
            a.print("edge " + this.name + ": ");
            a.print("LINESTRING (");
            for (var b = 0; b < this.pts.length; b++) 0 < b && a.print(","), a.print(this.pts[b].x + " " + this.pts[b].y);
            a.print(")  " + this.label + " " + this.depthDelta)
        },
        computeIM: function(a) {
            $a.updateIM(this.label, a)
        },
        isCollapsed: function() {
            return !!this.label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2])
        },
        isClosed: function() {
            return this.pts[0].equals(this.pts[this.pts.length -
                1])
        },
        getMaximumSegmentIndex: function() {
            return this.pts.length - 1
        },
        getDepthDelta: function() {
            return this.depthDelta
        },
        getNumPoints: function() {
            return this.pts.length
        },
        printReverse: function(a) {
            a.print("edge " + this.name + ": ");
            for (var b = this.pts.length - 1; 0 <= b; b--) a.print(this.pts[b] + " ");
            a.println("")
        },
        getMonotoneChainEdge: function() {
            return null === this.mce && (this.mce = new Lf(this)), this.mce
        },
        getEnvelope: function() {
            if (null === this.env) {
                this.env = new y;
                for (var a = 0; a < this.pts.length; a++) this.env.expandToInclude(this.pts[a])
            }
            return this.env
        },
        addIntersection: function(a, b, c, d) {
            var e = new k(a.getIntersection(d));
            a = a.getEdgeDistance(c, d);
            c = b + 1;
            c < this.pts.length && e.equals2D(this.pts[c]) && (b = c, a = 0);
            this.eiList.add(e, b, a)
        },
        toString: function() {
            var a = new Ya;
            a.append("edge " + this.name + ": ");
            a.append("LINESTRING (");
            for (var b = 0; b < this.pts.length; b++) 0 < b && a.append(","), a.append(this.pts[b].x + " " + this.pts[b].y);
            return a.append(")  " + this.label + " " + this.depthDelta), a.toString()
        },
        isPointwiseEqual: function(a) {
            if (this.pts.length !== a.pts.length) return !1;
            for (var b = 0; b < this.pts.length; b++)
                if (!this.pts[b].equals2D(a.pts[b])) return !1;
            return !0
        },
        setDepthDelta: function(a) {
            this.depthDelta = a
        },
        getEdgeIntersectionList: function() {
            return this.eiList
        },
        addIntersections: function(a, b, c) {
            for (var d = 0; d < a.getIntersectionNum(); d++) this.addIntersection(a, b, c, d)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return $a
        }
    });
    $a.updateIM = function() {
        if (2 !== arguments.length) return ac.prototype.updateIM.apply(this, arguments);
        var a = arguments[0],
            b = arguments[1];
        b.setAtLeastIfValid(a.getLocation(0,
            p.ON), a.getLocation(1, p.ON), 1);
        a.isArea() && (b.setAtLeastIfValid(a.getLocation(0, p.LEFT), a.getLocation(1, p.LEFT), 2), b.setAtLeastIfValid(a.getLocation(0, p.RIGHT), a.getLocation(1, p.RIGHT), 2))
    };
    x(Fa, pb);
    g(Fa.prototype, {
        insertBoundaryPoint: function(a, b) {
            var c = this.nodes.addNode(b).getLabel(),
                d = 1;
            c.getLocation(a, p.ON) === h.BOUNDARY && d++;
            d = Fa.determineBoundary(this.boundaryNodeRule, d);
            c.setLocation(a, d)
        },
        computeSelfNodes: function() {
            if (2 === arguments.length) return this.computeSelfNodes(arguments[0], arguments[1], !1);
            if (3 === arguments.length) {
                var a = arguments[1],
                    b = arguments[2],
                    c = new bc(arguments[0], !0, !1);
                c.setIsDoneIfProperInt(b);
                var b = this.createEdgeSetIntersector(),
                    d = this.parentGeom instanceof aa || this.parentGeom instanceof O || this.parentGeom instanceof na;
                return b.computeIntersections(this.edges, c, a || !d), this.addSelfIntersectionNodes(this.argIndex), c
            }
        },
        computeSplitEdges: function(a) {
            for (var b = this.edges.iterator(); b.hasNext();) b.next().eiList.addSplitEdges(a)
        },
        computeEdgeIntersections: function(a, b, c) {
            b = new bc(b,
                c, !0);
            return b.setBoundaryNodes(this.getBoundaryNodes(), a.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this.edges, a.edges, b), b
        },
        getGeometry: function() {
            return this.parentGeom
        },
        getBoundaryNodeRule: function() {
            return this.boundaryNodeRule
        },
        hasTooFewPoints: function() {
            return this._hasTooFewPoints
        },
        addPoint: function(a) {
            a instanceof W ? (a = a.getCoordinate(), this.insertPoint(this.argIndex, a, h.INTERIOR)) : a instanceof k && this.insertPoint(this.argIndex, a, h.INTERIOR)
        },
        addPolygon: function(a) {
            this.addPolygonRing(a.getExteriorRing(),
                h.EXTERIOR, h.INTERIOR);
            for (var b = 0; b < a.getNumInteriorRing(); b++) {
                var c = a.getInteriorRingN(b);
                this.addPolygonRing(c, h.INTERIOR, h.EXTERIOR)
            }
        },
        addEdge: function(a) {
            this.insertEdge(a);
            a = a.getCoordinates();
            this.insertPoint(this.argIndex, a[0], h.BOUNDARY);
            this.insertPoint(this.argIndex, a[a.length - 1], h.BOUNDARY)
        },
        addLineString: function(a) {
            var b = z.removeRepeatedPoints(a.getCoordinates());
            if (2 > b.length) return this._hasTooFewPoints = !0, this.invalidPoint = b[0], null;
            var c = new $a(b, new ca(this.argIndex, h.INTERIOR));
            this.lineEdgeMap.put(a, c);
            this.insertEdge(c);
            t.isTrue(2 <= b.length, "found LineString with single point");
            this.insertBoundaryPoint(this.argIndex, b[0]);
            this.insertBoundaryPoint(this.argIndex, b[b.length - 1])
        },
        getInvalidPoint: function() {
            return this.invalidPoint
        },
        getBoundaryPoints: function() {
            for (var a = this.getBoundaryNodes(), b = Array(a.size()).fill(null), c = 0, a = a.iterator(); a.hasNext();) {
                var d = a.next();
                b[c++] = d.getCoordinate().copy()
            }
            return b
        },
        getBoundaryNodes: function() {
            return null === this.boundaryNodes &&
                (this.boundaryNodes = this.nodes.getBoundaryNodes(this.argIndex)), this.boundaryNodes
        },
        addSelfIntersectionNode: function(a, b, c) {
            if (this.isBoundaryNode(a, b)) return null;
            c === h.BOUNDARY && this.useBoundaryDeterminationRule ? this.insertBoundaryPoint(a, b) : this.insertPoint(a, b, c)
        },
        addPolygonRing: function(a, b, c) {
            if (a.isEmpty()) return null;
            var d = z.removeRepeatedPoints(a.getCoordinates());
            if (4 > d.length) return this._hasTooFewPoints = !0, this.invalidPoint = d[0], null;
            var e = b,
                f = c;
            q.isCCW(d) && (e = c, f = b);
            b = new $a(d, new ca(this.argIndex,
                h.BOUNDARY, e, f));
            this.lineEdgeMap.put(a, b);
            this.insertEdge(b);
            this.insertPoint(this.argIndex, d[0], h.BOUNDARY)
        },
        insertPoint: function(a, b, c) {
            b = this.nodes.addNode(b);
            var d = b.getLabel();
            null === d ? b.label = new ca(a, c) : d.setLocation(a, c)
        },
        createEdgeSetIntersector: function() {
            return new we
        },
        addSelfIntersectionNodes: function(a) {
            for (var b = this.edges.iterator(); b.hasNext();)
                for (var c = b.next(), d = c.getLabel().getLocation(a), c = c.eiList.iterator(); c.hasNext();) {
                    var e = c.next();
                    this.addSelfIntersectionNode(a, e.coord,
                        d)
                }
        },
        add: function() {
            if (1 !== arguments.length) return pb.prototype.add.apply(this, arguments);
            var a = arguments[0];
            if (a.isEmpty()) return null;
            if (a instanceof na && (this.useBoundaryDeterminationRule = !1), a instanceof O) this.addPolygon(a);
            else if (a instanceof C) this.addLineString(a);
            else if (a instanceof W) this.addPoint(a);
            else {
                if (!(a instanceof Ia || a instanceof wa || a instanceof na || a instanceof F)) throw new UnsupportedOperationException(a.getClass().getName());
                this.addCollection(a)
            }
        },
        addCollection: function(a) {
            for (var b =
                    0; b < a.getNumGeometries(); b++) {
                var c = a.getGeometryN(b);
                this.add(c)
            }
        },
        locate: function(a) {
            return u(this.parentGeom, Bb) && 50 < this.parentGeom.getNumGeometries() ? (null === this.areaPtLocator && (this.areaPtLocator = new wd(this.parentGeom)), this.areaPtLocator.locate(a)) : this.ptLocator.locate(a, this.parentGeom)
        },
        findEdge: function() {
            return 1 === arguments.length ? this.lineEdgeMap.get(arguments[0]) : pb.prototype.findEdge.apply(this, arguments)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Fa
        }
    });
    Fa.determineBoundary =
        function(a, b) {
            return a.isInBoundary(b) ? h.BOUNDARY : h.INTERIOR
        };
    g(cc.prototype, {
        getArgGeometry: function(a) {
            return this.arg[a].getGeometry()
        },
        setComputationPrecision: function(a) {
            this.resultPrecisionModel = a;
            this.li.setPrecisionModel(this.resultPrecisionModel)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return cc
        }
    });
    g(dc.prototype, {
        compareTo: function(a) {
            return dc.compareOriented(this.pts, this._orientation, a.pts, a._orientation)
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return dc
        }
    });
    dc.orientation = function(a) {
        return 1 === z.increasingDirection(a)
    };
    dc.compareOriented = function(a, b, c, d) {
        var e = b ? 1 : -1,
            f = d ? 1 : -1,
            g = b ? a.length : -1,
            h = d ? c.length : -1;
        b = b ? 0 : a.length - 1;
        for (d = d ? 0 : c.length - 1;;) {
            var k = a[b].compareTo(c[d]);
            if (0 !== k) return k;
            b += e;
            d += f;
            var k = b === g,
                l = d === h;
            if (k && !l) return -1;
            if (!k && l) return 1;
            if (k && l) return 0
        }
    };
    g(Ce.prototype, {
        print: function(a) {
            a.print("MULTILINESTRING ( ");
            for (var b = 0; b < this.edges.size(); b++) {
                var c = this.edges.get(b);
                0 < b && a.print(",");
                a.print("(");
                for (var c = c.getCoordinates(),
                        d = 0; d < c.length; d++) 0 < d && a.print(","), a.print(c[d].x + " " + c[d].y);
                a.println(")")
            }
            a.print(")  ")
        },
        addAll: function(a) {
            for (a = a.iterator(); a.hasNext();) this.add(a.next())
        },
        findEdgeIndex: function(a) {
            for (var b = 0; b < this.edges.size(); b++)
                if (this.edges.get(b).equals(a)) return b;
            return -1
        },
        iterator: function() {
            return this.edges.iterator()
        },
        getEdges: function() {
            return this.edges
        },
        get: function(a) {
            return this.edges.get(a)
        },
        findEqualEdge: function(a) {
            a = new dc(a.getCoordinates());
            return this.ocaMap.get(a)
        },
        add: function(a) {
            this.edges.add(a);
            var b = new dc(a.getCoordinates());
            this.ocaMap.put(b, a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ce
        }
    });
    x(w, cc);
    g(w.prototype, {
        insertUniqueEdge: function(a) {
            var b = this.edgeList.findEqualEdge(a);
            if (null !== b) {
                var c = b.getLabel(),
                    d = a.getLabel();
                b.isPointwiseEqual(a) || (d = new ca(a.getLabel()), d.flip());
                a = b.getDepth();
                a.isNull() && a.add(c);
                a.add(d);
                c.merge(d)
            } else this.edgeList.add(a)
        },
        getGraph: function() {
            return this.graph
        },
        cancelDuplicateResultEdges: function() {
            for (var a = this.graph.getEdgeEnds().iterator(); a.hasNext();) {
                var b =
                    a.next(),
                    c = b.getSym();
                b.isInResult() && c.isInResult() && (b.setInResult(!1), c.setInResult(!1))
            }
        },
        isCoveredByLA: function(a) {
            return !!this.isCovered(a, this.resultLineList) || !!this.isCovered(a, this.resultPolyList)
        },
        computeGeometry: function(a, b, c, d) {
            var e = new l;
            return e.addAll(a), e.addAll(b), e.addAll(c), e.isEmpty() ? w.createEmptyResult(d, this.arg[0].getGeometry(), this.arg[1].getGeometry(), this.geomFact) : this.geomFact.buildGeometry(e)
        },
        mergeSymLabels: function() {
            for (var a = this.graph.getNodes().iterator(); a.hasNext();) a.next().getEdges().mergeSymLabels()
        },
        isCovered: function(a, b) {
            for (var c = b.iterator(); c.hasNext();) {
                var d = c.next();
                if (this.ptLocator.locate(a, d) !== h.EXTERIOR) return !0
            }
            return !1
        },
        replaceCollapsedEdges: function() {
            for (var a = new l, b = this.edgeList.iterator(); b.hasNext();) {
                var c = b.next();
                c.isCollapsed() && (b.remove(), a.add(c.getCollapsedEdge()))
            }
            this.edgeList.addAll(a)
        },
        updateNodeLabelling: function() {
            for (var a = this.graph.getNodes().iterator(); a.hasNext();) {
                var b = a.next(),
                    c = b.getEdges().getLabel();
                b.getLabel().merge(c)
            }
        },
        getResultGeometry: function(a) {
            return this.computeOverlay(a),
                this.resultGeom
        },
        insertUniqueEdges: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                this.insertUniqueEdge(b)
            }
        },
        computeOverlay: function(a) {
            this.copyPoints(0);
            this.copyPoints(1);
            this.arg[0].computeSelfNodes(this.li, !1);
            this.arg[1].computeSelfNodes(this.li, !1);
            this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !0);
            var b = new l;
            this.arg[0].computeSplitEdges(b);
            this.arg[1].computeSplitEdges(b);
            this.insertUniqueEdges(b);
            this.computeLabelsFromDepths();
            this.replaceCollapsedEdges();
            vc.checkValid(this.edgeList.getEdges());
            this.graph.addEdges(this.edgeList.getEdges());
            this.computeLabelling();
            this.labelIncompleteNodes();
            this.findResultAreaEdges(a);
            this.cancelDuplicateResultEdges();
            b = new se(this.geomFact);
            b.add(this.graph);
            this.resultPolyList = b.getPolygons();
            this.resultLineList = (new Ef(this, this.geomFact, this.ptLocator)).build(a);
            this.resultPointList = (new Ff(this, this.geomFact, this.ptLocator)).build(a);
            this.resultGeom = this.computeGeometry(this.resultPointList, this.resultLineList, this.resultPolyList, a)
        },
        labelIncompleteNode: function(a,
            b) {
            var c = this.ptLocator.locate(a.getCoordinate(), this.arg[b].getGeometry());
            a.getLabel().setLocation(b, c)
        },
        copyPoints: function(a) {
            for (var b = this.arg[a].getNodeIterator(); b.hasNext();) {
                var c = b.next();
                this.graph.addNode(c.getCoordinate()).setLabel(a, c.getLabel().getLocation(a))
            }
        },
        findResultAreaEdges: function(a) {
            for (var b = this.graph.getEdgeEnds().iterator(); b.hasNext();) {
                var c = b.next(),
                    d = c.getLabel();
                d.isArea() && !c.isInteriorAreaEdge() && w.isResultOfOp(d.getLocation(0, p.RIGHT), d.getLocation(1, p.RIGHT),
                    a) && c.setInResult(!0)
            }
        },
        computeLabelsFromDepths: function() {
            for (var a = this.edgeList.iterator(); a.hasNext();) {
                var b = a.next(),
                    c = b.getLabel(),
                    b = b.getDepth();
                if (!b.isNull()) {
                    b.normalize();
                    for (var d = 0; 2 > d; d++) c.isNull(d) || !c.isArea() || b.isNull(d) || (0 === b.getDelta(d) ? c.toLine(d) : (t.isTrue(!b.isNull(d, p.LEFT), "depth of LEFT side has not been initialized"), c.setLocation(d, p.LEFT, b.getLocation(d, p.LEFT)), t.isTrue(!b.isNull(d, p.RIGHT), "depth of RIGHT side has not been initialized"), c.setLocation(d, p.RIGHT, b.getLocation(d,
                        p.RIGHT))))
                }
            }
        },
        computeLabelling: function() {
            for (var a = this.graph.getNodes().iterator(); a.hasNext();) a.next().getEdges().computeLabelling(this.arg);
            this.mergeSymLabels();
            this.updateNodeLabelling()
        },
        labelIncompleteNodes: function() {
            for (var a = 0, b = this.graph.getNodes().iterator(); b.hasNext();) {
                var c = b.next(),
                    d = c.getLabel();
                c.isIsolated() && (a++, d.isNull(0) ? this.labelIncompleteNode(c, 0) : this.labelIncompleteNode(c, 1));
                c.getEdges().updateLabelling(d)
            }
        },
        isCoveredByA: function(a) {
            return !!this.isCovered(a, this.resultPolyList)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return w
        }
    });
    w.overlayOp = function(a, b, c) {
        return (new w(a, b)).getResultGeometry(c)
    };
    w.intersection = function(a, b) {
        return a.isEmpty() || b.isEmpty() ? w.createEmptyResult(w.INTERSECTION, a, b, a.getFactory()) : a.isGeometryCollection() ? Nc.map(a, {
            interfaces_: function() {
                return [MapOp]
            },
            map: function(a) {
                return a.intersection(b)
            }
        }) : (a.checkNotGeometryCollection(a), a.checkNotGeometryCollection(b), ja.overlayOp(a, b, w.INTERSECTION))
    };
    w.symDifference = function(a, b) {
        if (a.isEmpty() ||
            b.isEmpty()) {
            if (a.isEmpty() && b.isEmpty()) return w.createEmptyResult(w.SYMDIFFERENCE, a, b, a.getFactory());
            if (a.isEmpty()) return b.copy();
            if (b.isEmpty()) return a.copy()
        }
        return a.checkNotGeometryCollection(a), a.checkNotGeometryCollection(b), ja.overlayOp(a, b, w.SYMDIFFERENCE)
    };
    w.resultDimension = function(a, b, c) {
        b = b.getDimension();
        c = c.getDimension();
        var d = -1;
        switch (a) {
            case w.INTERSECTION:
                d = Math.min(b, c);
                break;
            case w.UNION:
                d = Math.max(b, c);
                break;
            case w.DIFFERENCE:
                d = b;
                break;
            case w.SYMDIFFERENCE:
                d = Math.max(b,
                    c)
        }
        return d
    };
    w.createEmptyResult = function(a, b, c, d) {
        var e = null;
        switch (w.resultDimension(a, b, c)) {
            case -1:
                e = d.createGeometryCollection([].fill(null));
                break;
            case 0:
                e = d.createPoint();
                break;
            case 1:
                e = d.createLineString();
                break;
            case 2:
                e = d.createPolygon()
        }
        return e
    };
    w.difference = function(a, b) {
        return a.isEmpty() ? w.createEmptyResult(w.DIFFERENCE, a, b, a.getFactory()) : b.isEmpty() ? a.copy() : (a.checkNotGeometryCollection(a), a.checkNotGeometryCollection(b), ja.overlayOp(a, b, w.DIFFERENCE))
    };
    w.isResultOfOp = function() {
        if (2 ===
            arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = a.getLocation(0),
                a = a.getLocation(1);
            return w.isResultOfOp(c, a, b)
        }
        if (3 === arguments.length) {
            b = arguments[0];
            c = arguments[1];
            a = arguments[2];
            switch (b === h.BOUNDARY && (b = h.INTERIOR), c === h.BOUNDARY && (c = h.INTERIOR), a) {
                case w.INTERSECTION:
                    return b === h.INTERIOR && c === h.INTERIOR;
                case w.UNION:
                    return b === h.INTERIOR || c === h.INTERIOR;
                case w.DIFFERENCE:
                    return b === h.INTERIOR && c !== h.INTERIOR;
                case w.SYMDIFFERENCE:
                    return b === h.INTERIOR && c !== h.INTERIOR || b !== h.INTERIOR &&
                        c === h.INTERIOR
            }
            return !1
        }
    };
    w.INTERSECTION = 1;
    w.UNION = 2;
    w.DIFFERENCE = 3;
    w.SYMDIFFERENCE = 4;
    g(ab.prototype, {
        selfSnap: function(a) {
            return (new ya(a)).snapTo(a, this.snapTolerance)
        },
        removeCommonBits: function(a) {
            this.cbr = new md;
            this.cbr.add(a[0]);
            this.cbr.add(a[1]);
            var b = Array(2).fill(null);
            return b[0] = this.cbr.removeCommonBits(a[0].copy()), b[1] = this.cbr.removeCommonBits(a[1].copy()), b
        },
        prepareResult: function(a) {
            return this.cbr.addCommonBits(a), a
        },
        getResultGeometry: function(a) {
            var b = this.snap(this.geom);
            a = w.overlayOp(b[0],
                b[1], a);
            return this.prepareResult(a)
        },
        checkValid: function(a) {
            a.isValid() || U.out.println("Snapped geometry is invalid")
        },
        computeSnapTolerance: function() {
            this.snapTolerance = ya.computeOverlaySnapTolerance(this.geom[0], this.geom[1])
        },
        snap: function(a) {
            a = this.removeCommonBits(a);
            return ya.snap(a[0], a[1], this.snapTolerance)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ab
        }
    });
    ab.overlayOp = function(a, b, c) {
        return (new ab(a, b)).getResultGeometry(c)
    };
    ab.union = function(a, b) {
        return ab.overlayOp(a,
            b, w.UNION)
    };
    ab.intersection = function(a, b) {
        return ab.overlayOp(a, b, w.INTERSECTION)
    };
    ab.symDifference = function(a, b) {
        return ab.overlayOp(a, b, w.SYMDIFFERENCE)
    };
    ab.difference = function(a, b) {
        return ab.overlayOp(a, b, w.DIFFERENCE)
    };
    g(ja.prototype, {
        getResultGeometry: function(a) {
            var b = null,
                c = !1,
                d = null;
            try {
                b = w.overlayOp(this.geom[0], this.geom[1], a), c = !0
            } catch (e) {
                if (!(e instanceof la)) throw e;
                d = e
            }
            if (!c) try {
                b = ab.overlayOp(this.geom[0], this.geom[1], a)
            } catch (e) {
                throw e instanceof la ? d : e;
            }
            return b
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ja
        }
    });
    ja.overlayOp = function(a, b, c) {
        return (new ja(a, b)).getResultGeometry(c)
    };
    ja.union = function(a, b) {
        return ja.overlayOp(a, b, w.UNION)
    };
    ja.intersection = function(a, b) {
        return ja.overlayOp(a, b, w.INTERSECTION)
    };
    ja.symDifference = function(a, b) {
        return ja.overlayOp(a, b, w.SYMDIFFERENCE)
    };
    ja.difference = function(a, b) {
        return ja.overlayOp(a, b, w.DIFFERENCE)
    };
    g(hb.prototype, {
        addPolygon: function(a) {
            if (a.isEmpty()) return null;
            var b = null,
                c = 0,
                b = this.horizontalBisector(a);
            0 === b.getLength() ? (c =
                0, b = b.getCoordinate()) : (c = ja.overlayOp(b, a, w.INTERSECTION), a = this.widestGeometry(c), c = a.getEnvelopeInternal().getWidth(), b = hb.centre(a.getEnvelopeInternal()));
            (null === this.interiorPoint || c > this.maxWidth) && (this.interiorPoint = b, this.maxWidth = c)
        },
        getInteriorPoint: function() {
            return this.interiorPoint
        },
        widestGeometry: function(a) {
            if (a instanceof F) {
                if (a.isEmpty()) return a;
                for (var b = a.getGeometryN(0), c = 1; c < a.getNumGeometries(); c++) a.getGeometryN(c).getEnvelopeInternal().getWidth() > b.getEnvelopeInternal().getWidth() &&
                    (b = a.getGeometryN(c));
                return b
            }
            if (a instanceof r) return a instanceof F ? this.widestGeometry(a) : a
        },
        horizontalBisector: function(a) {
            var b = a.getEnvelopeInternal();
            a = Rc.getBisectorY(a);
            return this.factory.createLineString([new k(b.getMinX(), a), new k(b.getMaxX(), a)])
        },
        add: function(a) {
            if (a instanceof O) this.addPolygon(a);
            else if (a instanceof F)
                for (var b = 0; b < a.getNumGeometries(); b++) this.add(a.getGeometryN(b))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return hb
        }
    });
    hb.centre = function(a) {
        return new k(hb.avg(a.getMinX(),
            a.getMaxX()), hb.avg(a.getMinY(), a.getMaxY()))
    };
    hb.avg = function(a, b) {
        return (a + b) / 2
    };
    g(Rc.prototype, {
        updateInterval: function(a) {
            a <= this.centreY ? a > this.loY && (this.loY = a) : a > this.centreY && a < this.hiY && (this.hiY = a)
        },
        getBisectorY: function() {
            this.process(this.poly.getExteriorRing());
            for (var a = 0; a < this.poly.getNumInteriorRing(); a++) this.process(this.poly.getInteriorRingN(a));
            return hb.avg(this.hiY, this.loY)
        },
        process: function(a) {
            a = a.getCoordinateSequence();
            for (var b = 0; b < a.size(); b++) {
                var c = a.getY(b);
                this.updateInterval(c)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Rc
        }
    });
    Rc.getBisectorY = function(a) {
        return (new Rc(a)).getBisectorY()
    };
    hb.SafeBisectorFinder = Rc;
    g(De.prototype, {
        addEndpoints: function(a) {
            if (a instanceof r)
                if (a instanceof C) this.addEndpoints(a.getCoordinates());
                else {
                    if (a instanceof F)
                        for (var b = 0; b < a.getNumGeometries(); b++) this.addEndpoints(a.getGeometryN(b))
                }
            else a instanceof Array && (this.add(a[0]), this.add(a[a.length - 1]))
        },
        getInteriorPoint: function() {
            return this.interiorPoint
        },
        addInterior: function(a) {
            if (a instanceof r)
                if (a instanceof C) this.addInterior(a.getCoordinates());
                else {
                    if (a instanceof F)
                        for (var b = 0; b < a.getNumGeometries(); b++) this.addInterior(a.getGeometryN(b))
                }
            else if (a instanceof Array)
                for (b = 1; b < a.length - 1; b++) this.add(a[b])
        },
        add: function(a) {
            var b = a.distance(this.centroid);
            b < this.minDistance && (this.interiorPoint = new k(a), this.minDistance = b)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return De
        }
    });
    g(Ee.prototype, {
        getInteriorPoint: function() {
            return this.interiorPoint
        },
        add: function(a) {
            if (a instanceof r)
                if (a instanceof W) this.add(a.getCoordinate());
                else {
                    if (a instanceof F)
                        for (var b = 0; b < a.getNumGeometries(); b++) this.add(a.getGeometryN(b))
                }
            else a instanceof k && (b = a.distance(this.centroid), b < this.minDistance && (this.interiorPoint = new k(a), this.minDistance = b))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ee
        }
    });
    g(ec.prototype, {
        select: function() {
            1 === arguments.length ? arguments[0] : 2 === arguments.length && (arguments[0].getLineSegment(arguments[1], this.selectedSegment), this.select(this.selectedSegment))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ec
        }
    });
    g(qb.prototype, {
        hasChildren: function() {
            for (var a = 0; 2 > a; a++)
                if (null !== this.subnode[a]) return !0;
            return !1
        },
        isPrunable: function() {
            return !(this.hasChildren() || this.hasItems())
        },
        addAllItems: function(a) {
            a.addAll(this.items);
            for (var b = 0; 2 > b; b++) null !== this.subnode[b] && this.subnode[b].addAllItems(a);
            return a
        },
        size: function() {
            for (var a = 0, b = 0; 2 > b; b++) null !== this.subnode[b] && (a += this.subnode[b].size());
            return a + this.items.size()
        },
        addAllItemsFromOverlapping: function(a,
            b) {
            if (null !== a && !this.isSearchMatch(a)) return null;
            b.addAll(this.items);
            null !== this.subnode[0] && this.subnode[0].addAllItemsFromOverlapping(a, b);
            null !== this.subnode[1] && this.subnode[1].addAllItemsFromOverlapping(a, b)
        },
        hasItems: function() {
            return !this.items.isEmpty()
        },
        remove: function(a, b) {
            if (!this.isSearchMatch(a)) return !1;
            for (var c = !1, d = 0; 2 > d; d++)
                if (null !== this.subnode[d] && (c = this.subnode[d].remove(a, b))) {
                    this.subnode[d].isPrunable() && (this.subnode[d] = null);
                    break
                }
            return c || this.items.remove(b)
        },
        getItems: function() {
            return this.items
        },
        depth: function() {
            for (var a = 0, b = 0; 2 > b; b++)
                if (null !== this.subnode[b]) {
                    var c = this.subnode[b].depth();
                    c > a && (a = c)
                }
            return a + 1
        },
        nodeSize: function() {
            for (var a = 0, b = 0; 2 > b; b++) null !== this.subnode[b] && (a += this.subnode[b].nodeSize());
            return a + 1
        },
        add: function(a) {
            this.items.add(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return qb
        }
    });
    qb.getSubnodeIndex = function(a, b) {
        var c = -1;
        return a.min >= b && (c = 1), a.max <= b && (c = 0), c
    };
    g(Ib.prototype, {
        expandToInclude: function(a) {
            a.max > this.max && (this.max = a.max);
            a.min <
                this.min && (this.min = a.min)
        },
        getWidth: function() {
            return this.max - this.min
        },
        overlaps: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                return this.overlaps(a.min, a.max)
            }
            if (2 === arguments.length) return a = arguments[0], !(this.min > arguments[1] || this.max < a)
        },
        getMin: function() {
            return this.min
        },
        toString: function() {
            return "[" + this.min + ", " + this.max + "]"
        },
        contains: function() {
            if (1 === arguments.length) {
                if (arguments[0] instanceof Ib) {
                    var a = arguments[0];
                    return this.contains(a.min, a.max)
                }
                if ("number" == typeof arguments[0]) return a =
                    arguments[0], a >= this.min && a <= this.max
            } else if (2 === arguments.length) return a = arguments[1], arguments[0] >= this.min && a <= this.max
        },
        init: function(a, b) {
            this.min = a;
            this.max = b;
            a > b && (this.min = b, this.max = a)
        },
        getMax: function() {
            return this.max
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ib
        }
    });
    Ac.exponent = function(a) {
        var b, c, d, e = {
                32: {
                    d: 127,
                    c: 128,
                    b: 0,
                    a: 0
                },
                64: {
                    d: 32752,
                    c: 0,
                    b: 0,
                    a: 0
                }
            },
            f = {
                32: 8,
                64: 11
            }[64];
        if (d || (b = 0 > a || 0 > 1 / a, isFinite(a) || (d = e[64], b && (d.d += 32768), c = Math.pow(2, f) - 1)), !d) {
            c = {
                32: 127,
                64: 1023
            }[64];
            for (a = Math.abs(a); 2 <= a;) c++, a /= 2;
            for (; 1 > a && 0 < c;) c--, a *= 2
        }
        return c - 1023
    };
    Ac.powerOf2 = function(a) {
        return Math.pow(2, a)
    };
    g(yd.prototype, {
        getInterval: function() {
            return this.interval
        },
        getLevel: function() {
            return this.level
        },
        computeKey: function(a) {
            this.level = yd.computeLevel(a);
            this.interval = new Ib;
            for (this.computeInterval(this.level, a); !this.interval.contains(a);) this.level += 1, this.computeInterval(this.level, a)
        },
        computeInterval: function(a, b) {
            var c = Ac.powerOf2(a);
            this.pt = Math.floor(b.getMin() / c) * c;
            this.interval.init(this.pt,
                this.pt + c)
        },
        getPoint: function() {
            return this.pt
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return yd
        }
    });
    yd.computeLevel = function(a) {
        a = a.getWidth();
        return Ac.exponent(a) + 1
    };
    x(Rb, qb);
    g(Rb.prototype, {
        getInterval: function() {
            return this.interval
        },
        find: function(a) {
            var b = qb.getSubnodeIndex(a, this.centre);
            return -1 === b ? this : null !== this.subnode[b] ? this.subnode[b].find(a) : this
        },
        insert: function(a) {
            t.isTrue(null === this.interval || this.interval.contains(a.interval));
            var b = qb.getSubnodeIndex(a.interval,
                this.centre);
            if (a.level === this.level - 1) this.subnode[b] = a;
            else {
                var c = this.createSubnode(b);
                c.insert(a);
                this.subnode[b] = c
            }
        },
        isSearchMatch: function(a) {
            return a.overlaps(this.interval)
        },
        getSubnode: function(a) {
            return null === this.subnode[a] && (this.subnode[a] = this.createSubnode(a)), this.subnode[a]
        },
        getNode: function(a) {
            var b = qb.getSubnodeIndex(a, this.centre);
            return -1 !== b ? this.getSubnode(b).getNode(a) : this
        },
        createSubnode: function(a) {
            var b = 0,
                c = 0;
            switch (a) {
                case 0:
                    b = this.interval.getMin();
                    c = this.centre;
                    break;
                case 1:
                    b = this.centre, c = this.interval.getMax()
            }
            return new Rb(new Ib(b, c), this.level - 1)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Rb
        }
    });
    Rb.createNode = function(a) {
        a = new yd(a);
        return new Rb(a.getInterval(), a.getLevel())
    };
    Rb.createExpanded = function(a, b) {
        var c = new Ib(b);
        null !== a && c.expandToInclude(a.interval);
        c = Rb.createNode(c);
        return null !== a && c.insert(a), c
    };
    g(fc.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return fc
        }
    });
    fc.isZeroWidth = function(a, b) {
        var c = b - a;
        return 0 ===
            c ? !0 : Ac.exponent(c / Math.max(Math.abs(a), Math.abs(b))) <= fc.MIN_BINARY_EXPONENT
    };
    fc.MIN_BINARY_EXPONENT = -50;
    x(Sc, qb);
    g(Sc.prototype, {
        insert: function(a, b) {
            var c = qb.getSubnodeIndex(a, Sc.origin);
            if (-1 === c) return this.add(b), null;
            var d = this.subnode[c];
            null !== d && d.getInterval().contains(a) || (d = Rb.createExpanded(d, a), this.subnode[c] = d);
            this.insertContained(this.subnode[c], a, b)
        },
        isSearchMatch: function(a) {
            return !0
        },
        insertContained: function(a, b, c) {
            t.isTrue(a.getInterval().contains(b));
            var d = null,
                d = fc.isZeroWidth(b.getMin(),
                    b.getMax()) ? a.find(b) : a.getNode(b);
            d.add(c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Sc
        }
    });
    Sc.origin = 0;
    g(Tc.prototype, {
        size: function() {
            return null !== this.root ? this.root.size() : 0
        },
        insert: function(a, b) {
            this.collectStats(a);
            var c = Tc.ensureExtent(a, this.minExtent);
            this.root.insert(c, b)
        },
        query: function() {
            if (1 === arguments.length) {
                if ("number" == typeof arguments[0]) {
                    var a = arguments[0];
                    return this.query(new Ib(a, a))
                }
                if (arguments[0] instanceof Ib) {
                    var a = arguments[0],
                        b = new l;
                    return this.query(a,
                        b), b
                }
            } else 2 === arguments.length && this.root.addAllItemsFromOverlapping(arguments[0], arguments[1])
        },
        iterator: function() {
            var a = new l;
            return this.root.addAllItems(a), a.iterator()
        },
        remove: function(a, b) {
            var c = Tc.ensureExtent(a, this.minExtent);
            return this.root.remove(c, b)
        },
        collectStats: function(a) {
            a = a.getWidth();
            a < this.minExtent && 0 < a && (this.minExtent = a)
        },
        depth: function() {
            return null !== this.root ? this.root.depth() : 0
        },
        nodeSize: function() {
            return null !== this.root ? this.root.nodeSize() : 0
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Tc
        }
    });
    Tc.ensureExtent = function(a, b) {
        var c = a.getMin(),
            d = a.getMax();
        return c !== d ? a : (c === d && (c -= b / 2, d = c + b / 2), new Ib(c, d))
    };
    g(Mf.prototype, {
        isInside: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Mf
        }
    });
    g(zd.prototype, {
        testLineSegment: function(a, b) {
            var c = null,
                d = null,
                e = null,
                f = null,
                d = b.p0,
                f = b.p1,
                c = d.x - a.x,
                d = d.y - a.y,
                e = f.x - a.x,
                f = f.y - a.y;
            (0 < d && 0 >= f || 0 < f && 0 >= d) && 0 < rc.signOfDet2x2(c, d, e, f) / (f - d) && this.crossings++
        },
        buildIndex: function() {
            this.tree = new Tc;
            for (var a =
                    z.removeRepeatedPoints(this.ring.getCoordinates()), a = fb.getChains(a), b = 0; b < a.size(); b++) {
                var c = a.get(b),
                    d = c.getEnvelope();
                this.interval.min = d.getMinY();
                this.interval.max = d.getMaxY();
                this.tree.insert(this.interval, c)
            }
        },
        testMonotoneChain: function(a, b, c) {
            c.select(a, b)
        },
        isInside: function(a) {
            this.crossings = 0;
            var b = new y(v.NEGATIVE_INFINITY, v.POSITIVE_INFINITY, a.y, a.y);
            this.interval.min = a.y;
            this.interval.max = a.y;
            var c = this.tree.query(this.interval);
            a = new Ad(this, a);
            for (c = c.iterator(); c.hasNext();) {
                var d =
                    c.next();
                this.testMonotoneChain(b, a, d)
            }
            return 1 == this.crossings % 2
        },
        interfaces_: function() {
            return [Mf]
        },
        getClass: function() {
            return zd
        }
    });
    x(Ad, ec);
    g(Ad.prototype, {
        select: function() {
            if (1 !== arguments.length) return ec.prototype.select.apply(this, arguments);
            this.mcp.testLineSegment(this.p, arguments[0])
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ad
        }
    });
    zd.MCSelecter = Ad;
    g(B.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return B
        }
    });
    B.toDegrees = function(a) {
        return 180 * a / Math.PI
    };
    B.normalize = function(a) {
        for (; a > Math.PI;) a -= B.PI_TIMES_2;
        for (; a <= -Math.PI;) a += B.PI_TIMES_2;
        return a
    };
    B.angle = function() {
        if (1 === arguments.length) {
            var a = arguments[0];
            return Math.atan2(a.y, a.x)
        }
        if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            return Math.atan2(b.y - a.y, b.x - a.x)
        }
    };
    B.isAcute = function(a, b, c) {
        return 0 < (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y)
    };
    B.isObtuse = function(a, b, c) {
        return 0 > (a.x - b.x) * (c.x - b.x) + (a.y - b.y) * (c.y - b.y)
    };
    B.interiorAngle = function(a, b, c) {
        a = B.angle(b, a);
        b = B.angle(b, c);
        return Math.abs(b - a)
    };
    B.normalizePositive = function(a) {
        if (0 > a) {
            for (; 0 > a;) a += B.PI_TIMES_2;
            a >= B.PI_TIMES_2 && (a = 0)
        } else {
            for (; a >= B.PI_TIMES_2;) a -= B.PI_TIMES_2;
            0 > a && (a = 0)
        }
        return a
    };
    B.angleBetween = function(a, b, c) {
        a = B.angle(b, a);
        b = B.angle(b, c);
        return B.diff(a, b)
    };
    B.diff = function(a, b) {
        var c = null;
        return c = a < b ? b - a : a - b, c > Math.PI && (c = 2 * Math.PI - c), c
    };
    B.toRadians = function(a) {
        return a * Math.PI / 180
    };
    B.getTurn = function(a, b) {
        var c = Math.sin(b - a);
        return 0 < c ? B.COUNTERCLOCKWISE : 0 > c ? B.CLOCKWISE : B.NONE
    };
    B.angleBetweenOriented =
        function(a, b, c) {
            a = B.angle(b, a);
            b = B.angle(b, c) - a;
            return b <= -Math.PI ? b + B.PI_TIMES_2 : b > Math.PI ? b - B.PI_TIMES_2 : b
        };
    B.PI_TIMES_2 = 2 * Math.PI;
    B.PI_OVER_2 = Math.PI / 2;
    B.PI_OVER_4 = Math.PI / 4;
    B.COUNTERCLOCKWISE = q.COUNTERCLOCKWISE;
    B.CLOCKWISE = q.CLOCKWISE;
    B.NONE = q.COLLINEAR;
    g(S.prototype, {
        area: function() {
            return S.area(this.p0, this.p1, this.p2)
        },
        signedArea: function() {
            return S.signedArea(this.p0, this.p1, this.p2)
        },
        interpolateZ: function(a) {
            if (null === a) throw new K("Supplied point is null.");
            return S.interpolateZ(a, this.p0,
                this.p1, this.p2)
        },
        longestSideLength: function() {
            return S.longestSideLength(this.p0, this.p1, this.p2)
        },
        isAcute: function() {
            return S.isAcute(this.p0, this.p1, this.p2)
        },
        circumcentre: function() {
            return S.circumcentre(this.p0, this.p1, this.p2)
        },
        area3D: function() {
            return S.area3D(this.p0, this.p1, this.p2)
        },
        centroid: function() {
            return S.centroid(this.p0, this.p1, this.p2)
        },
        inCentre: function() {
            return S.inCentre(this.p0, this.p1, this.p2)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return S
        }
    });
    S.area = function(a,
        b, c) {
        return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)
    };
    S.signedArea = function(a, b, c) {
        return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2
    };
    S.det = function(a, b, c, d) {
        return a * d - b * c
    };
    S.interpolateZ = function(a, b, c, d) {
        var e = b.x,
            f = b.y,
            g = c.x - e,
            h = d.x - e,
            k = c.y - f,
            l = d.y - f,
            m = g * l - h * k,
            e = a.x - e;
        a = a.y - f;
        return b.z + (l * e - h * a) / m * (c.z - b.z) + (-k * e + g * a) / m * (d.z - b.z)
    };
    S.longestSideLength = function(a, b, c) {
        var d = a.distance(b);
        b = b.distance(c);
        a = c.distance(a);
        return b > d && (d = b), a > d && (d = a), d
    };
    S.isAcute = function(a, b, c) {
        return !!B.isAcute(a,
            b, c) && !!B.isAcute(b, c, a) && !!B.isAcute(c, a, b)
    };
    S.circumcentre = function(a, b, c) {
        var d = c.x;
        c = c.y;
        var e = a.x - d;
        a = a.y - c;
        var f = b.x - d;
        b = b.y - c;
        var g = 2 * S.det(e, a, f, b);
        return new k(d - S.det(a, e * e + a * a, b, f * f + b * b) / g, c + S.det(e, e * e + a * a, f, f * f + b * b) / g)
    };
    S.perpendicularBisector = function(a, b) {
        var c = b.x - a.x,
            d = b.y - a.y;
        return new Ha(new Ha(a.x + c / 2, a.y + d / 2, 1), new Ha(a.x - d + c / 2, a.y + c + d / 2, 1))
    };
    S.angleBisector = function(a, b, c) {
        var d = b.distance(a);
        b = b.distance(c);
        d /= d + b;
        return new k(a.x + d * (c.x - a.x), a.y + d * (c.y - a.y))
    };
    S.area3D = function(a,
        b, c) {
        var d = b.x - a.x,
            e = b.y - a.y,
            f = b.z - a.z;
        b = c.x - a.x;
        var g = c.y - a.y;
        c = c.z - a.z;
        a = e * c - f * g;
        f = f * b - d * c;
        d = d * g - e * b;
        return Math.sqrt(a * a + f * f + d * d) / 2
    };
    S.centroid = function(a, b, c) {
        return new k((a.x + b.x + c.x) / 3, (a.y + b.y + c.y) / 3)
    };
    S.inCentre = function(a, b, c) {
        var d = b.distance(c),
            e = a.distance(c),
            f = a.distance(b),
            g = d + e + f;
        return new k((d * a.x + e * b.x + f * c.x) / g, (d * a.y + e * b.y + f * c.y) / g)
    };
    g(Sb.prototype, {
        getRadius: function() {
            return this.compute(), this.radius
        },
        getDiameter: function() {
            switch (this.compute(), this.extremalPts.length) {
                case 0:
                    return this.input.getFactory().createLineString();
                case 1:
                    return this.input.getFactory().createPoint(this.centre)
            }
            var a = this.extremalPts[0],
                b = this.extremalPts[1];
            return this.input.getFactory().createLineString([a, b])
        },
        getExtremalPoints: function() {
            return this.compute(), this.extremalPts
        },
        computeCirclePoints: function() {
            if (this.input.isEmpty()) return this.extremalPts = [].fill(null), null;
            if (1 === this.input.getNumPoints()) {
                var a = this.input.getCoordinates();
                return this.extremalPts = [new k(a[0])], null
            }
            var b = this.input.convexHull().getCoordinates(),
                a = b;
            if (b[0].equals2D(b[b.length -
                    1]) && (a = Array(b.length - 1).fill(null), z.copyDeep(b, 0, a, 0, b.length - 1)), 2 >= a.length) return this.extremalPts = z.copyDeep(a), null;
            for (var b = Sb.lowestPoint(a), c = Sb.pointWitMinAngleWithX(a, b), d = 0; d < a.length; d++) {
                var e = Sb.pointWithMinAngleWithSegment(a, b, c);
                if (B.isObtuse(b, e, c)) return this.extremalPts = [new k(b), new k(c)], null;
                if (B.isObtuse(e, b, c)) b = e;
                else {
                    if (!B.isObtuse(e, c, b)) return this.extremalPts = [new k(b), new k(c), new k(e)], null;
                    c = e
                }
            }
            t.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")
        },
        compute: function() {
            if (null !== this.extremalPts) return null;
            this.computeCirclePoints();
            this.computeCentre();
            null !== this.centre && (this.radius = this.centre.distance(this.extremalPts[0]))
        },
        getFarthestPoints: function() {
            switch (this.compute(), this.extremalPts.length) {
                case 0:
                    return this.input.getFactory().createLineString();
                case 1:
                    return this.input.getFactory().createPoint(this.centre)
            }
            var a = this.extremalPts[0],
                b = this.extremalPts[this.extremalPts.length - 1];
            return this.input.getFactory().createLineString([a,
                b
            ])
        },
        getCircle: function() {
            if (this.compute(), null === this.centre) return this.input.getFactory().createPolygon();
            var a = this.input.getFactory().createPoint(this.centre);
            return 0 === this.radius ? a : a.buffer(this.radius)
        },
        getCentre: function() {
            return this.compute(), this.centre
        },
        computeCentre: function() {
            switch (this.extremalPts.length) {
                case 0:
                    this.centre = null;
                    break;
                case 1:
                    this.centre = this.extremalPts[0];
                    break;
                case 2:
                    this.centre = new k((this.extremalPts[0].x + this.extremalPts[1].x) / 2, (this.extremalPts[0].y + this.extremalPts[1].y) /
                        2);
                    break;
                case 3:
                    this.centre = S.circumcentre(this.extremalPts[0], this.extremalPts[1], this.extremalPts[2])
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Sb
        }
    });
    Sb.pointWitMinAngleWithX = function(a, b) {
        for (var c = v.MAX_VALUE, d = null, e = 0; e < a.length; e++) {
            var f = a[e];
            if (f !== b) {
                var g = f.x - b.x,
                    h = f.y - b.y;
                0 > h && (h = -h);
                g = h / Math.sqrt(g * g + h * h);
                g < c && (c = g, d = f)
            }
        }
        return d
    };
    Sb.lowestPoint = function(a) {
        for (var b = a[0], c = 1; c < a.length; c++) a[c].y < b.y && (b = a[c]);
        return b
    };
    Sb.pointWithMinAngleWithSegment = function(a,
        b, c) {
        for (var d = v.MAX_VALUE, e = null, f = 0; f < a.length; f++) {
            var g = a[f];
            if (g !== b && g !== c) {
                var h = B.angleBetween(b, g, c);
                h < d && (d = h, e = g)
            }
        }
        return e
    };
    g(ta.prototype, {
        getWidthCoordinate: function() {
            return this.computeMinimumDiameter(), this.minWidthPt
        },
        getSupportingSegment: function() {
            return this.computeMinimumDiameter(), this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0, this.minBaseSeg.p1])
        },
        getDiameter: function() {
            if (this.computeMinimumDiameter(), null === this.minWidthPt) return this.inputGeom.getFactory().createLineString(null);
            var a = this.minBaseSeg.project(this.minWidthPt);
            return this.inputGeom.getFactory().createLineString([a, this.minWidthPt])
        },
        computeWidthConvex: function(a) {
            this.convexHullPts = a instanceof O ? a.getExteriorRing().getCoordinates() : a.getCoordinates();
            0 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = null, this.minBaseSeg = null) : 1 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[0]) : 2 ===
                this.convexHullPts.length || 3 === this.convexHullPts.length ? (this.minWidth = 0, this.minWidthPt = this.convexHullPts[0], this.minBaseSeg.p0 = this.convexHullPts[0], this.minBaseSeg.p1 = this.convexHullPts[1]) : this.computeConvexRingMinDiameter(this.convexHullPts)
        },
        computeConvexRingMinDiameter: function(a) {
            this.minWidth = v.MAX_VALUE;
            for (var b = 1, c = new A, d = 0; d < a.length - 1; d++) c.p0 = a[d], c.p1 = a[d + 1], b = this.findMaxPerpDistance(a, c, b)
        },
        computeMinimumDiameter: function() {
            if (null !== this.minWidthPt) return null;
            if (this.isConvex) this.computeWidthConvex(this.inputGeom);
            else {
                var a = (new Eb(this.inputGeom)).getConvexHull();
                this.computeWidthConvex(a)
            }
        },
        getLength: function() {
            return this.computeMinimumDiameter(), this.minWidth
        },
        findMaxPerpDistance: function(a, b, c) {
            for (var d = b.distancePerpendicular(a[c]), e = d, f = c; e >= d;) d = e, c = f, f = ta.nextIndex(a, c), e = b.distancePerpendicular(a[f]);
            return d < this.minWidth && (this.minPtIndex = c, this.minWidth = d, this.minWidthPt = a[this.minPtIndex], this.minBaseSeg = new A(b)), c
        },
        getMinimumRectangle: function() {
            if (this.computeMinimumDiameter(), 0 === this.minWidth) return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1) ?
                this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0) : this.minBaseSeg.toGeometry(this.inputGeom.getFactory());
            for (var a = this.minBaseSeg.p1.x - this.minBaseSeg.p0.x, b = this.minBaseSeg.p1.y - this.minBaseSeg.p0.y, c = v.MAX_VALUE, d = -v.MAX_VALUE, e = v.MAX_VALUE, f = -v.MAX_VALUE, g = 0; g < this.convexHullPts.length; g++) {
                var h = ta.computeC(a, b, this.convexHullPts[g]);
                h > d && (d = h);
                h < c && (c = h);
                h = ta.computeC(-b, a, this.convexHullPts[g]);
                h > f && (f = h);
                h < e && (e = h)
            }
            f = ta.computeSegmentForLine(-a, -b, f);
            e = ta.computeSegmentForLine(-a, -b, e);
            d = ta.computeSegmentForLine(-b, a, d);
            c = ta.computeSegmentForLine(-b, a, c);
            a = d.lineIntersection(f);
            b = c.lineIntersection(f);
            c = c.lineIntersection(e);
            d = d.lineIntersection(e);
            a = this.inputGeom.getFactory().createLinearRing([a, b, c, d, a]);
            return this.inputGeom.getFactory().createPolygon(a, null)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ta
        }
    });
    ta.nextIndex = function(a, b) {
        return b++, b >= a.length && (b = 0), b
    };
    ta.computeC = function(a, b, c) {
        return a * c.y - b * c.x
    };
    ta.getMinimumDiameter = function(a) {
        return (new ta(a)).getDiameter()
    };
    ta.getMinimumRectangle = function(a) {
        return (new ta(a)).getMinimumRectangle()
    };
    ta.computeSegmentForLine = function(a, b, c) {
        var d = null,
            e = null;
        return Math.abs(b) > Math.abs(a) ? (d = new k(0, c / b), e = new k(1, c / b - a / b)) : (d = new k(c / a, 0), e = new k(c / a - b / a, 1)), new A(d, e)
    };
    var Eg = Object.freeze({
        Centroid: Db,
        CGAlgorithms: q,
        ConvexHull: Eb,
        InteriorPointArea: hb,
        InteriorPointLine: De,
        InteriorPointPoint: Ee,
        RobustLineIntersector: ia,
        MCPointInRing: zd,
        MinimumBoundingCircle: Sb,
        MinimumDiameter: ta
    });
    g(gc.prototype, {
        getResultGeometry: function() {
            return (new Bd(this.distanceTolerance)).transform(this.inputGeom)
        },
        setDistanceTolerance: function(a) {
            if (0 >= a) throw new K("Tolerance must be positive");
            this.distanceTolerance = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return gc
        }
    });
    gc.densifyPoints = function(a, b, c) {
        for (var d = new A, e = new Z, f = 0; f < a.length - 1; f++) {
            d.p0 = a[f];
            d.p1 = a[f + 1];
            e.add(d.p0, !1);
            var g = d.getLength(),
                h = Math.trunc(g / b) + 1;
            if (1 < h)
                for (var k = g / h, l = 1; l < h; l++) {
                    var m = d.pointAlong(l * k / g);
                    c.makePrecise(m);
                    e.add(m, !1)
                }
        }
        return e.add(a[a.length - 1], !1), e.toCoordinateArray()
    };
    gc.densify = function(a, b) {
        var c =
            new gc(a);
        return c.setDistanceTolerance(b), c.getResultGeometry()
    };
    x(Bd, Ca);
    g(Bd.prototype, {
        transformMultiPolygon: function(a, b) {
            var c = Ca.prototype.transformMultiPolygon.call(this, a, b);
            return this.createValidArea(c)
        },
        transformPolygon: function(a, b) {
            var c = Ca.prototype.transformPolygon.call(this, a, b);
            return b instanceof na ? c : this.createValidArea(c)
        },
        transformCoordinates: function(a, b) {
            var c = a.toCoordinateArray(),
                c = gc.densifyPoints(c, this.distanceTolerance, b.getPrecisionModel());
            return b instanceof C && 1 ===
                c.length && (c = [].fill(null)), this.factory.getCoordinateSequenceFactory().create(c)
        },
        createValidArea: function(a) {
            return a.buffer(0)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Bd
        }
    });
    gc.DensifyTransformer = Bd;
    var Fg = Object.freeze({
        Densifier: gc
    });
    g(Jb.prototype, {
        find: function(a) {
            var b = this;
            do {
                if (null === b) break;
                if (b.dest().equals2D(a)) return b;
                b = b.oNext()
            } while (b !== this);
            return null
        },
        dest: function() {
            return this._sym._orig
        },
        oNext: function() {
            return this._sym._next
        },
        insert: function(a) {
            if (this.oNext() ===
                this) return this.insertAfter(a), null;
            var b = this.compareTo(a),
                c = this;
            do {
                var d = c.oNext();
                if (d.compareTo(a) !== b || d === this) return c.insertAfter(a), null;
                c = d
            } while (c !== this);
            t.shouldNeverReachHere()
        },
        insertAfter: function(a) {
            t.equals(this._orig, a.orig());
            var b = this.oNext();
            this._sym.setNext(a);
            a.sym().setNext(b)
        },
        degree: function() {
            var a = 0,
                b = this;
            do a++, b = b.oNext(); while (b !== this);
            return a
        },
        equals: function() {
            if (2 === arguments.length) {
                var a = arguments[1];
                return this._orig.equals2D(arguments[0]) && this._sym._orig.equals(a)
            }
        },
        deltaY: function() {
            return this._sym._orig.y - this._orig.y
        },
        sym: function() {
            return this._sym
        },
        prev: function() {
            return this._sym.next()._sym
        },
        compareAngularDirection: function(a) {
            var b = this.deltaX(),
                c = this.deltaY(),
                d = a.deltaX(),
                e = a.deltaY();
            if (b === d && c === e) return 0;
            b = H.quadrant(b, c);
            d = H.quadrant(d, e);
            return b > d ? 1 : b < d ? -1 : q.computeOrientation(a._orig, a.dest(), this.dest())
        },
        prevNode: function() {
            for (var a = this; 2 === a.degree();)
                if ((a = a.prev()) === this) return null;
            return a
        },
        compareTo: function(a) {
            return this.compareAngularDirection(a)
        },
        next: function() {
            return this._next
        },
        setSym: function(a) {
            this._sym = a
        },
        orig: function() {
            return this._orig
        },
        toString: function() {
            return "HE(" + this._orig.x + " " + this._orig.y + ", " + this._sym._orig.x + " " + this._sym._orig.y + ")"
        },
        setNext: function(a) {
            this._next = a
        },
        init: function(a) {
            this.setSym(a);
            a.setSym(this);
            this.setNext(a);
            a.setNext(this)
        },
        deltaX: function() {
            return this._sym._orig.x - this._orig.x
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Jb
        }
    });
    Jb.init = function(a, b) {
        if (null !== a._sym || null !== b._sym ||
            null !== a._next || null !== b._next) throw new IllegalStateException("Edges are already initialized");
        return a.init(b), a
    };
    Jb.create = function(a, b) {
        var c = new Jb(a),
            d = new Jb(b);
        return c.init(d), c
    };
    x(La, Jb);
    g(La.prototype, {
        mark: function() {
            this._isMarked = !0
        },
        setMark: function(a) {
            this._isMarked = a
        },
        isMarked: function() {
            return this._isMarked
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return La
        }
    });
    La.setMarkBoth = function(a, b) {
        a.setMark(b);
        a.sym().setMark(b)
    };
    La.isMarked = function(a) {
        return a.isMarked()
    };
    La.setMark = function(a, b) {
        a.setMark(b)
    };
    La.markBoth = function(a) {
        a.mark();
        a.sym().mark()
    };
    La.mark = function(a) {
        a.mark()
    };
    g(Uc.prototype, {
        insert: function(a, b, c) {
            var d = this.create(a, b);
            null !== c ? c.insert(d) : this.vertexMap.put(a, d);
            a = this.vertexMap.get(b);
            return null !== a ? a.insert(d.sym()) : this.vertexMap.put(b, d.sym()), d
        },
        create: function(a, b) {
            var c = this.createEdge(a),
                d = this.createEdge(b);
            return Jb.init(c, d), c
        },
        createEdge: function(a) {
            return new Jb(a)
        },
        addEdge: function(a, b) {
            if (!Uc.isValidEdge(a, b)) return null;
            var c = this.vertexMap.get(a),
                d = null;
            return null !== c && (d = c.find(b)), null !== d ? d : this.insert(a, b, c)
        },
        getVertexEdges: function() {
            return this.vertexMap.values()
        },
        findEdge: function(a, b) {
            var c = this.vertexMap.get(a);
            return null === c ? null : c.find(b)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Uc
        }
    });
    Uc.isValidEdge = function(a, b) {
        return 0 !== b.compareTo(a)
    };
    x(Fe, La);
    g(Fe.prototype, {
        setStart: function() {
            this._isStart = !0
        },
        isStart: function() {
            return this._isStart
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Fe
        }
    });
    x(Ge, Uc);
    g(Ge.prototype, {
        createEdge: function(a) {
            return new Fe(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ge
        }
    });
    g(Cd.prototype, {
        addLine: function(a) {
            this.lines.add(this.factory.createLineString(a.toCoordinateArray()))
        },
        updateRingStartEdge: function(a) {
            return a.isStart() || (a = a.sym(), a.isStart()) ? null === this.ringStartEdge ? (this.ringStartEdge = a, null) : void(0 > a.orig().compareTo(this.ringStartEdge.orig()) && (this.ringStartEdge = a)) : null
        },
        getResult: function() {
            return null === this.result && this.computeResult(),
                this.result
        },
        process: function(a) {
            var b = a.prevNode();
            null === b && (b = a);
            this.stackEdges(b);
            this.buildLines()
        },
        buildRing: function(a) {
            var b = new Z,
                c = a;
            for (b.add(c.orig().copy(), !1); 2 === c.sym().degree();) {
                var d = c.next();
                if (d === a) break;
                b.add(d.orig().copy(), !1);
                c = d
            }
            b.add(c.dest().copy(), !1);
            this.addLine(b)
        },
        buildLine: function(a) {
            var b = new Z,
                c = a;
            this.ringStartEdge = null;
            La.markBoth(c);
            for (b.add(c.orig().copy(), !1); 2 === c.sym().degree();) {
                this.updateRingStartEdge(c);
                c = c.next();
                if (c === a) return this.buildRing(this.ringStartEdge),
                    null;
                b.add(c.orig().copy(), !1);
                La.markBoth(c)
            }
            b.add(c.dest().copy(), !1);
            this.stackEdges(c.sym());
            this.addLine(b)
        },
        stackEdges: function(a) {
            var b = a;
            do La.isMarked(b) || this.nodeEdgeStack.add(b), b = b.oNext(); while (b !== a)
        },
        computeResult: function() {
            for (var a = this.graph.getVertexEdges().iterator(); a.hasNext();) {
                var b = a.next();
                La.isMarked(b) || this.process(b)
            }
            this.result = this.factory.buildGeometry(this.lines)
        },
        buildLines: function() {
            for (; !this.nodeEdgeStack.empty();) {
                var a = this.nodeEdgeStack.pop();
                La.isMarked(a) ||
                    this.buildLine(a)
            }
        },
        add: function(a) {
            if (a instanceof r) a.apply({
                interfaces_: function() {
                    return [eb]
                },
                filter: function(a) {
                    a instanceof C && this.add(a)
                }
            });
            else if (u(a, T))
                for (a = a.iterator(); a.hasNext();) {
                    var b = a.next();
                    this.add(b)
                } else if (a instanceof C) {
                    null === this.factory && (this.factory = a.getFactory());
                    var b = a.getCoordinateSequence(),
                        c = !1;
                    for (a = 1; a < b.size(); a++) {
                        var d = this.graph.addEdge(b.getCoordinate(a - 1), b.getCoordinate(a));
                        null !== d && (c || (d.setStart(), c = !0))
                    }
                }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Cd
        }
    });
    Cd.dissolve = function(a) {
        var b = new Cd;
        return b.add(a), b.getResult()
    };
    var Gg = Object.freeze({
            LineDissolver: Cd
        }),
        Hg = Object.freeze({
            GeometryGraph: Fa
        });
    g(rb.prototype, {
        hasChildren: function() {
            for (var a = 0; 4 > a; a++)
                if (null !== this.subnode[a]) return !0;
            return !1
        },
        isPrunable: function() {
            return !(this.hasChildren() || this.hasItems())
        },
        addAllItems: function(a) {
            a.addAll(this.items);
            for (var b = 0; 4 > b; b++) null !== this.subnode[b] && this.subnode[b].addAllItems(a);
            return a
        },
        getNodeCount: function() {
            for (var a = 0, b = 0; 4 > b; b++) null !==
                this.subnode[b] && (a += this.subnode[b].size());
            return a + 1
        },
        size: function() {
            for (var a = 0, b = 0; 4 > b; b++) null !== this.subnode[b] && (a += this.subnode[b].size());
            return a + this.items.size()
        },
        addAllItemsFromOverlapping: function(a, b) {
            if (!this.isSearchMatch(a)) return null;
            b.addAll(this.items);
            for (var c = 0; 4 > c; c++) null !== this.subnode[c] && this.subnode[c].addAllItemsFromOverlapping(a, b)
        },
        visitItems: function(a, b) {
            for (var c = this.items.iterator(); c.hasNext();) b.visitItem(c.next())
        },
        hasItems: function() {
            return !this.items.isEmpty()
        },
        remove: function(a, b) {
            if (!this.isSearchMatch(a)) return !1;
            for (var c = !1, d = 0; 4 > d; d++)
                if (null !== this.subnode[d] && (c = this.subnode[d].remove(a, b))) {
                    this.subnode[d].isPrunable() && (this.subnode[d] = null);
                    break
                }
            return c || this.items.remove(b)
        },
        visit: function(a, b) {
            if (!this.isSearchMatch(a)) return null;
            this.visitItems(a, b);
            for (var c = 0; 4 > c; c++) null !== this.subnode[c] && this.subnode[c].visit(a, b)
        },
        getItems: function() {
            return this.items
        },
        depth: function() {
            for (var a = 0, b = 0; 4 > b; b++)
                if (null !== this.subnode[b]) {
                    var c = this.subnode[b].depth();
                    c > a && (a = c)
                }
            return a + 1
        },
        isEmpty: function() {
            var a = !0;
            this.items.isEmpty() || (a = !1);
            for (var b = 0; 4 > b; b++) null !== this.subnode[b] && (this.subnode[b].isEmpty() || (a = !1));
            return a
        },
        add: function(a) {
            this.items.add(a)
        },
        interfaces_: function() {
            return [Ba]
        },
        getClass: function() {
            return rb
        }
    });
    rb.getSubnodeIndex = function(a, b, c) {
        var d = -1;
        return a.getMinX() >= b && (a.getMinY() >= c && (d = 3), a.getMaxY() <= c && (d = 1)), a.getMaxX() <= b && (a.getMinY() >= c && (d = 2), a.getMaxY() <= c && (d = 0)), d
    };
    g(Dd.prototype, {
        getLevel: function() {
            return this.level
        },
        computeKey: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                this.level = Dd.computeQuadLevel(a);
                this.env = new y;
                for (this.computeKey(this.level, a); !this.env.contains(a);) this.level += 1, this.computeKey(this.level, a)
            } else if (2 === arguments.length) {
                var a = arguments[1],
                    b = Ac.powerOf2(arguments[0]);
                this.pt.x = Math.floor(a.getMinX() / b) * b;
                this.pt.y = Math.floor(a.getMinY() / b) * b;
                this.env.init(this.pt.x, this.pt.x + b, this.pt.y, this.pt.y + b)
            }
        },
        getEnvelope: function() {
            return this.env
        },
        getCentre: function() {
            return new k((this.env.getMinX() +
                this.env.getMaxX()) / 2, (this.env.getMinY() + this.env.getMaxY()) / 2)
        },
        getPoint: function() {
            return this.pt
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Dd
        }
    });
    Dd.computeQuadLevel = function(a) {
        var b = a.getWidth();
        a = a.getHeight();
        return Ac.exponent(b > a ? b : a) + 1
    };
    x(Tb, rb);
    g(Tb.prototype, {
        find: function(a) {
            var b = rb.getSubnodeIndex(a, this.centrex, this.centrey);
            return -1 === b ? this : null !== this.subnode[b] ? this.subnode[b].find(a) : this
        },
        isSearchMatch: function(a) {
            return this.env.intersects(a)
        },
        getSubnode: function(a) {
            return null ===
                this.subnode[a] && (this.subnode[a] = this.createSubnode(a)), this.subnode[a]
        },
        getEnvelope: function() {
            return this.env
        },
        getNode: function(a) {
            var b = rb.getSubnodeIndex(a, this.centrex, this.centrey);
            return -1 !== b ? this.getSubnode(b).getNode(a) : this
        },
        createSubnode: function(a) {
            var b = 0,
                c = 0,
                d = 0,
                e = 0;
            switch (a) {
                case 0:
                    b = this.env.getMinX();
                    c = this.centrex;
                    d = this.env.getMinY();
                    e = this.centrey;
                    break;
                case 1:
                    b = this.centrex;
                    c = this.env.getMaxX();
                    d = this.env.getMinY();
                    e = this.centrey;
                    break;
                case 2:
                    b = this.env.getMinX();
                    c = this.centrex;
                    d = this.centrey;
                    e = this.env.getMaxY();
                    break;
                case 3:
                    b = this.centrex, c = this.env.getMaxX(), d = this.centrey, e = this.env.getMaxY()
            }
            return new Tb(new y(b, c, d, e), this.level - 1)
        },
        insertNode: function(a) {
            t.isTrue(null === this.env || this.env.contains(a.env));
            var b = rb.getSubnodeIndex(a.env, this.centrex, this.centrey);
            if (a.level === this.level - 1) this.subnode[b] = a;
            else {
                var c = this.createSubnode(b);
                c.insertNode(a);
                this.subnode[b] = c
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Tb
        }
    });
    Tb.createNode = function(a) {
        a =
            new Dd(a);
        return new Tb(a.getEnvelope(), a.getLevel())
    };
    Tb.createExpanded = function(a, b) {
        var c = new y(b);
        null !== a && c.expandToInclude(a.env);
        c = Tb.createNode(c);
        return null !== a && c.insertNode(a), c
    };
    x(Bc, rb);
    g(Bc.prototype, {
        insert: function(a, b) {
            var c = rb.getSubnodeIndex(a, Bc.origin.x, Bc.origin.y);
            if (-1 === c) return this.add(b), null;
            var d = this.subnode[c];
            null !== d && d.getEnvelope().contains(a) || (d = Tb.createExpanded(d, a), this.subnode[c] = d);
            this.insertContained(this.subnode[c], a, b)
        },
        isSearchMatch: function(a) {
            return !0
        },
        insertContained: function(a, b, c) {
            t.isTrue(a.getEnvelope().contains(b));
            var d = fc.isZeroWidth(b.getMinX(), b.getMaxX()),
                e = fc.isZeroWidth(b.getMinY(), b.getMaxY()),
                f = null,
                f = d || e ? a.find(b) : a.getNode(b);
            f.add(c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Bc
        }
    });
    Bc.origin = new k(0, 0);
    g(hc.prototype, {
        size: function() {
            return null !== this.root ? this.root.size() : 0
        },
        insert: function(a, b) {
            this.collectStats(a);
            var c = hc.ensureExtent(a, this.minExtent);
            this.root.insert(c, b)
        },
        query: function() {
            if (1 === arguments.length) {
                var a =
                    arguments[0],
                    b = new ze;
                return this.query(a, b), b.getItems()
            }
            2 === arguments.length && this.root.visit(arguments[0], arguments[1])
        },
        queryAll: function() {
            var a = new l;
            return this.root.addAllItems(a), a
        },
        remove: function(a, b) {
            var c = hc.ensureExtent(a, this.minExtent);
            return this.root.remove(c, b)
        },
        collectStats: function(a) {
            var b = a.getWidth();
            b < this.minExtent && 0 < b && (this.minExtent = b);
            a = a.getHeight();
            a < this.minExtent && 0 < a && (this.minExtent = a)
        },
        depth: function() {
            return null !== this.root ? this.root.depth() : 0
        },
        isEmpty: function() {
            return null ===
                this.root
        },
        interfaces_: function() {
            return [oe, Ba]
        },
        getClass: function() {
            return hc
        }
    });
    hc.ensureExtent = function(a, b) {
        var c = a.getMinX(),
            d = a.getMaxX(),
            e = a.getMinY(),
            f = a.getMaxY();
        return c !== d && e !== f ? a : (c === d && (c -= b / 2, d = c + b / 2), e === f && (e -= b / 2, f = e + b / 2), new y(c, d, e, f))
    };
    hc.serialVersionUID = -0x678b60c967a25400;
    var Ig = Object.freeze({
            Quadtree: hc
        }),
        Jg = Object.freeze({
            STRtree: X
        }),
        Kg = Object.freeze({
            quadtree: Ig,
            strtree: Jg
        }),
        Lg = "Point MultiPoint LineString MultiLineString Polygon MultiPolygon".split(" ");
    g(Nf.prototype, {
        read: function(a) {
            var b = void 0,
                b = "string" == typeof a ? JSON.parse(a) : a;
            a = b.type;
            if (!lb[a]) throw Error("Unknown GeoJSON type: " + b.type);
            return -1 !== Lg.indexOf(a) ? lb[a].apply(this, [b.coordinates]) : "GeometryCollection" === a ? lb[a].apply(this, [b.geometries]) : lb[a].apply(this, [b])
        },
        write: function(a) {
            var b = a.getGeometryType();
            if (!Nb[b]) throw Error("Geometry is not supported");
            return Nb[b].apply(this, [a])
        }
    });
    var lb = {
            Feature: function(a) {
                var b = {},
                    c;
                for (c in a) b[c] = a[c];
                if (a.geometry) {
                    if (!lb[a.geometry.type]) throw Error("Unknown GeoJSON type: " +
                        a.type);
                    b.geometry = this.read(a.geometry)
                }
                return a.bbox && (b.bbox = lb.bbox.apply(this, [a.bbox])), b
            },
            FeatureCollection: function(a) {
                var b = {};
                if (a.features) {
                    b.features = [];
                    for (var c = 0; c < a.features.length; ++c) b.features.push(this.read(a.features[c]))
                }
                return a.bbox && (b.bbox = this.parse.bbox.apply(this, [a.bbox])), b
            },
            coordinates: function(a) {
                for (var b = [], c = 0; c < a.length; ++c) {
                    var d = a[c];
                    b.push(new k(d[0], d[1]))
                }
                return b
            },
            bbox: function(a) {
                return this.geometryFactory.createLinearRing([new k(a[0], a[1]), new k(a[2],
                    a[1]), new k(a[2], a[3]), new k(a[0], a[3]), new k(a[0], a[1])])
            },
            Point: function(a) {
                a = new k(a[0], a[1]);
                return this.geometryFactory.createPoint(a)
            },
            MultiPoint: function(a) {
                for (var b = [], c = 0; c < a.length; ++c) b.push(lb.Point.apply(this, [a[c]]));
                return this.geometryFactory.createMultiPoint(b)
            },
            LineString: function(a) {
                a = lb.coordinates.apply(this, [a]);
                return this.geometryFactory.createLineString(a)
            },
            MultiLineString: function(a) {
                for (var b = [], c = 0; c < a.length; ++c) b.push(lb.LineString.apply(this, [a[c]]));
                return this.geometryFactory.createMultiLineString(b)
            },
            Polygon: function(a) {
                for (var b = lb.coordinates.apply(this, [a[0]]), b = this.geometryFactory.createLinearRing(b), c = [], d = 1; d < a.length; ++d) {
                    var e = lb.coordinates.apply(this, [a[d]]),
                        e = this.geometryFactory.createLinearRing(e);
                    c.push(e)
                }
                return this.geometryFactory.createPolygon(b, c)
            },
            MultiPolygon: function(a) {
                for (var b = [], c = 0; c < a.length; ++c) b.push(lb.Polygon.apply(this, [a[c]]));
                return this.geometryFactory.createMultiPolygon(b)
            },
            GeometryCollection: function(a) {
                for (var b = [], c = 0; c < a.length; ++c) b.push(this.read(a[c]));
                return this.geometryFactory.createGeometryCollection(b)
            }
        },
        Nb = {
            coordinate: function(a) {
                return [a.x, a.y]
            },
            Point: function(a) {
                return {
                    type: "Point",
                    coordinates: Nb.coordinate.apply(this, [a.getCoordinate()])
                }
            },
            MultiPoint: function(a) {
                for (var b = [], c = 0; c < a.geometries.length; ++c) {
                    var d = Nb.Point.apply(this, [a.geometries[c]]);
                    b.push(d.coordinates)
                }
                return {
                    type: "MultiPoint",
                    coordinates: b
                }
            },
            LineString: function(a) {
                var b = [];
                a = a.getCoordinates();
                for (var c = 0; c < a.length; ++c) b.push(Nb.coordinate.apply(this, [a[c]]));
                return {
                    type: "LineString",
                    coordinates: b
                }
            },
            MultiLineString: function(a) {
                for (var b = [], c = 0; c < a.geometries.length; ++c) {
                    var d = Nb.LineString.apply(this, [a.geometries[c]]);
                    b.push(d.coordinates)
                }
                return {
                    type: "MultiLineString",
                    coordinates: b
                }
            },
            Polygon: function(a) {
                var b = [],
                    c = Nb.LineString.apply(this, [a.shell]);
                b.push(c.coordinates);
                for (c = 0; c < a.holes.length; ++c) {
                    var d = Nb.LineString.apply(this, [a.holes[c]]);
                    b.push(d.coordinates)
                }
                return {
                    type: "Polygon",
                    coordinates: b
                }
            },
            MultiPolygon: function(a) {
                for (var b = [], c = 0; c < a.geometries.length; ++c) {
                    var d =
                        Nb.Polygon.apply(this, [a.geometries[c]]);
                    b.push(d.coordinates)
                }
                return {
                    type: "MultiPolygon",
                    coordinates: b
                }
            },
            GeometryCollection: function(a) {
                for (var b = [], c = 0; c < a.geometries.length; ++c) {
                    var d = a.geometries[c],
                        e = d.getGeometryType();
                    b.push(Nb[e].apply(this, [d]))
                }
                return {
                    type: "GeometryCollection",
                    geometries: b
                }
            }
        };
    g(kg.prototype, {
        read: function(a) {
            a = this.parser.read(a);
            return this.precisionModel.getType() === L.FIXED && this.reducePrecision(a), a
        },
        reducePrecision: function(a) {
            var b, c;
            if (a.coordinate) this.precisionModel.makePrecise(a.coordinate);
            else if (a.points)
                for (b = 0, c = a.points.length; b < c; b++) this.precisionModel.makePrecise(a.points[b]);
            else if (a.geometries)
                for (b = 0, c = a.geometries.length; b < c; b++) this.reducePrecision(a.geometries[b])
        }
    });
    g(lg.prototype, {
        write: function(a) {
            return this.parser.write(a)
        }
    });
    g(mg.prototype, {
        read: function(a) {
            a = this.parser.read(a);
            return this.precisionModel.getType() === L.FIXED && this.reducePrecision(a), a
        },
        reducePrecision: function(a) {
            if (a.coordinate) this.precisionModel.makePrecise(a.coordinate);
            else if (a.points)
                for (var b =
                        0, c = a.points.coordinates.length; b < c; b++) this.precisionModel.makePrecise(a.points.coordinates[b]);
            else if (a.geometries)
                for (b = 0, c = a.geometries.length; b < c; b++) this.reducePrecision(a.geometries[b])
        }
    });
    g(ng.prototype, {
        read: function(a) {
            var b = this.ol;
            return a instanceof b.geom.Point ? this.convertFromPoint(a) : a instanceof b.geom.LineString ? this.convertFromLineString(a) : a instanceof b.geom.LinearRing ? this.convertFromLinearRing(a) : a instanceof b.geom.Polygon ? this.convertFromPolygon(a) : a instanceof b.geom.MultiPoint ?
                this.convertFromMultiPoint(a) : a instanceof b.geom.MultiLineString ? this.convertFromMultiLineString(a) : a instanceof b.geom.MultiPolygon ? this.convertFromMultiPolygon(a) : a instanceof b.geom.GeometryCollection ? this.convertFromCollection(a) : void 0
        },
        convertFromPoint: function(a) {
            a = a.getCoordinates();
            return this.geometryFactory.createPoint(new k(a[0], a[1]))
        },
        convertFromLineString: function(a) {
            return this.geometryFactory.createLineString(a.getCoordinates().map(function(a) {
                return new k(a[0], a[1])
            }))
        },
        convertFromLinearRing: function(a) {
            return this.geometryFactory.createLinearRing(a.getCoordinates().map(function(a) {
                return new k(a[0],
                    a[1])
            }))
        },
        convertFromPolygon: function(a) {
            a = a.getLinearRings();
            for (var b = null, c = [], d = 0; d < a.length; d++) {
                var e = this.convertFromLinearRing(a[d]);
                0 === d ? b = e : c.push(e)
            }
            return this.geometryFactory.createPolygon(b, c)
        },
        convertFromMultiPoint: function(a) {
            a = a.getPoints().map(function(a) {
                return this.convertFromPoint(a)
            }, this);
            return this.geometryFactory.createMultiPoint(a)
        },
        convertFromMultiLineString: function(a) {
            a = a.getLineStrings().map(function(a) {
                return this.convertFromLineString(a)
            }, this);
            return this.geometryFactory.createMultiLineString(a)
        },
        convertFromMultiPolygon: function(a) {
            a = a.getPolygons().map(function(a) {
                return this.convertFromPolygon(a)
            }, this);
            return this.geometryFactory.createMultiPolygon(a)
        },
        convertFromCollection: function(a) {
            a = a.getGeometries().map(function(a) {
                return this.read(a)
            }, this);
            return this.geometryFactory.createGeometryCollection(a)
        },
        write: function(a) {
            return "Point" === a.getGeometryType() ? this.convertToPoint(a.getCoordinate()) : "LineString" === a.getGeometryType() ? this.convertToLineString(a) : "LinearRing" === a.getGeometryType() ?
                this.convertToLinearRing(a) : "Polygon" === a.getGeometryType() ? this.convertToPolygon(a) : "MultiPoint" === a.getGeometryType() ? this.convertToMultiPoint(a) : "MultiLineString" === a.getGeometryType() ? this.convertToMultiLineString(a) : "MultiPolygon" === a.getGeometryType() ? this.convertToMultiPolygon(a) : "GeometryCollection" === a.getGeometryType() ? this.convertToCollection(a) : void 0
        },
        convertToPoint: function(a) {
            return new this.ol.geom.Point([a.x, a.y])
        },
        convertToLineString: function(a) {
            a = a.points.coordinates.map(Ed);
            return new this.ol.geom.LineString(a)
        },
        convertToLinearRing: function(a) {
            a = a.points.coordinates.map(Ed);
            return new this.ol.geom.LinearRing(a)
        },
        convertToPolygon: function(a) {
            for (var b = [a.shell.points.coordinates.map(Ed)], c = 0; c < a.holes.length; c++) b.push(a.holes[c].points.coordinates.map(Ed));
            return new this.ol.geom.Polygon(b)
        },
        convertToMultiPoint: function(a) {
            return new this.ol.geom.MultiPoint(a.getCoordinates().map(Ed))
        },
        convertToMultiLineString: function(a) {
            for (var b = [], c = 0; c < a.geometries.length; c++) b.push(this.convertToLineString(a.geometries[c]).getCoordinates());
            return new this.ol.geom.MultiLineString(b)
        },
        convertToMultiPolygon: function(a) {
            for (var b = [], c = 0; c < a.geometries.length; c++) b.push(this.convertToPolygon(a.geometries[c]).getCoordinates());
            return new this.ol.geom.MultiPolygon(b)
        },
        convertToCollection: function(a) {
            for (var b = [], c = 0; c < a.geometries.length; c++) b.push(this.write(a.geometries[c]));
            return new this.ol.geom.GeometryCollection(b)
        }
    });
    var Mg = Object.freeze({
        GeoJSONReader: kg,
        GeoJSONWriter: lg,
        OL3Parser: ng,
        WKTReader: mg,
        WKTWriter: ra
    });
    g(Fd.prototype, {
        rescale: function(a) {
            if (u(a,
                    T))
                for (var b = a.iterator(); b.hasNext();) a = b.next(), this.rescale(a.getCoordinates());
            else if (a instanceof Array) {
                2 === a.length && (new k(a[0]), new k(a[1]));
                for (b = 0; b < a.length; b++) a[b].x = a[b].x / this.scaleFactor + this.offsetX, a[b].y = a[b].y / this.scaleFactor + this.offsetY;
                2 === a.length && a[0].equals2D(a[1]) && U.out.println(a)
            }
        },
        scale: function(a) {
            if (u(a, T)) {
                for (var b = new l, c = a.iterator(); c.hasNext();) a = c.next(), b.add(new nb(this.scale(a.getCoordinates()), a.getData()));
                return b
            }
            if (a instanceof Array) {
                b = Array(a.length).fill(null);
                for (c = 0; c < a.length; c++) b[c] = new k(Math.round((a[c].x - this.offsetX) * this.scaleFactor), Math.round((a[c].y - this.offsetY) * this.scaleFactor), a[c].z);
                return z.removeRepeatedPoints(b)
            }
        },
        isIntegerPrecision: function() {
            return 1 === this.scaleFactor
        },
        getNodedSubstrings: function() {
            var a = this.noder.getNodedSubstrings();
            return this.isScaled && this.rescale(a), a
        },
        computeNodes: function(a) {
            var b = a;
            this.isScaled && (b = this.scale(a));
            this.noder.computeNodes(b)
        },
        interfaces_: function() {
            return [rd]
        },
        getClass: function() {
            return Fd
        }
    });
    var Ng = Object.freeze({
        MCIndexNoder: $b,
        ScaledNoder: Fd,
        SegmentString: od
    });
    g(Gd.prototype, {
        isSimpleMultiPoint: function(a) {
            if (a.isEmpty()) return !0;
            for (var b = new va, c = 0; c < a.getNumGeometries(); c++) {
                var d = a.getGeometryN(c).getCoordinate();
                if (b.contains(d)) return this.nonSimpleLocation = d, !1;
                b.add(d)
            }
            return !0
        },
        isSimplePolygonal: function(a) {
            for (a = sa.getLines(a).iterator(); a.hasNext();) {
                var b = a.next();
                if (!this.isSimpleLinearGeometry(b)) return !1
            }
            return !0
        },
        hasClosedEndpointIntersection: function(a) {
            var b = new ea;
            for (a = a.getEdgeIterator(); a.hasNext();) {
                var c = a.next(),
                    d = (c.getMaximumSegmentIndex(), c.isClosed()),
                    e = c.getCoordinate(0);
                this.addEndpoint(b, e, d);
                c = c.getCoordinate(c.getNumPoints() - 1);
                this.addEndpoint(b, c, d)
            }
            for (a = b.values().iterator(); a.hasNext();)
                if (b = a.next(), b.isClosed && 2 !== b.degree) return this.nonSimpleLocation = b.getCoordinate(), !0;
            return !1
        },
        getNonSimpleLocation: function() {
            return this.nonSimpleLocation
        },
        isSimpleLinearGeometry: function(a) {
            if (a.isEmpty()) return !0;
            a = new Fa(0, a);
            var b = new ia,
                b = a.computeSelfNodes(b, !0);
            return !b.hasIntersection() || (b.hasProperIntersection() ? (this.nonSimpleLocation = b.getProperIntersectionPoint(), !1) : !this.hasNonEndpointIntersection(a) && (!this.isClosedEndpointsInInterior || !this.hasClosedEndpointIntersection(a)))
        },
        hasNonEndpointIntersection: function(a) {
            for (a = a.getEdgeIterator(); a.hasNext();)
                for (var b = a.next(), c = b.getMaximumSegmentIndex(), b = b.getEdgeIntersectionList().iterator(); b.hasNext();) {
                    var d = b.next();
                    if (!d.isEndPoint(c)) return this.nonSimpleLocation = d.getCoordinate(), !0
                }
            return !1
        },
        addEndpoint: function(a, b, c) {
            var d = a.get(b);
            null === d && (d = new He(b), a.put(b, d));
            d.addEndpoint(c)
        },
        computeSimple: function(a) {
            return this.nonSimpleLocation = null, !!a.isEmpty() || (a instanceof C ? this.isSimpleLinearGeometry(a) : a instanceof wa ? this.isSimpleLinearGeometry(a) : a instanceof Ia ? this.isSimpleMultiPoint(a) : u(a, Bb) ? this.isSimplePolygonal(a) : !(a instanceof F) || this.isSimpleGeometryCollection(a))
        },
        isSimple: function() {
            return this.nonSimpleLocation = null, this.computeSimple(this.inputGeom)
        },
        isSimpleGeometryCollection: function(a) {
            for (var b =
                    0; b < a.getNumGeometries(); b++) {
                var c = a.getGeometryN(b);
                if (!this.computeSimple(c)) return !1
            }
            return !0
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Gd
        }
    });
    g(He.prototype, {
        addEndpoint: function(a) {
            this.degree++;
            this.isClosed |= a
        },
        getCoordinate: function() {
            return this.pt
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return He
        }
    });
    Gd.EndpointInfo = He;
    g(I.prototype, {
        getEndCapStyle: function() {
            return this.endCapStyle
        },
        isSingleSided: function() {
            return this._isSingleSided
        },
        setQuadrantSegments: function(a) {
            this.quadrantSegments =
                a;
            0 === this.quadrantSegments && (this.joinStyle = I.JOIN_BEVEL);
            0 > this.quadrantSegments && (this.joinStyle = I.JOIN_MITRE, this.mitreLimit = Math.abs(this.quadrantSegments));
            0 >= a && (this.quadrantSegments = 1);
            this.joinStyle !== I.JOIN_ROUND && (this.quadrantSegments = I.DEFAULT_QUADRANT_SEGMENTS)
        },
        getJoinStyle: function() {
            return this.joinStyle
        },
        setJoinStyle: function(a) {
            this.joinStyle = a
        },
        setSimplifyFactor: function(a) {
            this.simplifyFactor = 0 > a ? 0 : a
        },
        getSimplifyFactor: function() {
            return this.simplifyFactor
        },
        getQuadrantSegments: function() {
            return this.quadrantSegments
        },
        setEndCapStyle: function(a) {
            this.endCapStyle = a
        },
        getMitreLimit: function() {
            return this.mitreLimit
        },
        setMitreLimit: function(a) {
            this.mitreLimit = a
        },
        setSingleSided: function(a) {
            this._isSingleSided = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return I
        }
    });
    I.bufferDistanceError = function(a) {
        return 1 - Math.cos(Math.PI / 2 / a / 2)
    };
    I.CAP_ROUND = 1;
    I.CAP_FLAT = 2;
    I.CAP_SQUARE = 3;
    I.JOIN_ROUND = 1;
    I.JOIN_MITRE = 2;
    I.JOIN_BEVEL = 3;
    I.DEFAULT_QUADRANT_SEGMENTS = 8;
    I.DEFAULT_MITRE_LIMIT = 5;
    I.DEFAULT_SIMPLIFY_FACTOR = .01;
    g(Of.prototype, {
        getCoordinate: function() {
            return this.minCoord
        },
        getRightmostSide: function(a, b) {
            var c = this.getRightmostSideOfSegment(a, b);
            return 0 > c && (c = this.getRightmostSideOfSegment(a, b - 1)), 0 > c && (this.minCoord = null, this.checkForRightmostCoordinate(a)), c
        },
        findRightmostEdgeAtVertex: function() {
            var a = this.minDe.getEdge().getCoordinates();
            t.isTrue(0 < this.minIndex && this.minIndex < a.length, "rightmost point expected to be interior vertex of edge");
            var b = a[this.minIndex - 1],
                a = a[this.minIndex + 1],
                c = q.computeOrientation(this.minCoord,
                    a, b),
                d = !1;
            b.y < this.minCoord.y && a.y < this.minCoord.y && c === q.COUNTERCLOCKWISE ? d = !0 : b.y > this.minCoord.y && a.y > this.minCoord.y && c === q.CLOCKWISE && (d = !0);
            d && --this.minIndex
        },
        getRightmostSideOfSegment: function(a, b) {
            var c = a.getEdge().getCoordinates();
            if (0 > b || b + 1 >= c.length || c[b].y === c[b + 1].y) return -1;
            var d = p.LEFT;
            return c[b].y < c[b + 1].y && (d = p.RIGHT), d
        },
        getEdge: function() {
            return this.orientedDe
        },
        checkForRightmostCoordinate: function(a) {
            for (var b = a.getEdge().getCoordinates(), c = 0; c < b.length - 1; c++)(null === this.minCoord ||
                b[c].x > this.minCoord.x) && (this.minDe = a, this.minIndex = c, this.minCoord = b[c])
        },
        findRightmostEdgeAtNode: function() {
            this.minDe = this.minDe.getNode().getEdges().getRightmostEdge();
            this.minDe.isForward() || (this.minDe = this.minDe.getSym(), this.minIndex = this.minDe.getEdge().getCoordinates().length - 1)
        },
        findEdge: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                b.isForward() && this.checkForRightmostCoordinate(b)
            }
            t.isTrue(0 !== this.minIndex || this.minCoord.equals(this.minDe.getCoordinate()), "inconsistency in rightmost processing");
            0 === this.minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex();
            this.orientedDe = this.minDe;
            this.getRightmostSide(this.minDe, this.minIndex) === p.LEFT && (this.orientedDe = this.minDe.getSym())
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Of
        }
    });
    Ie.prototype.addLast = function(a) {
        this.array_.push(a)
    };
    Ie.prototype.removeFirst = function() {
        return this.array_.shift()
    };
    Ie.prototype.isEmpty = function() {
        return 0 === this.array_.length
    };
    g(Pf.prototype, {
        clearVisitedEdges: function() {
            for (var a =
                    this.dirEdgeList.iterator(); a.hasNext();) a.next().setVisited(!1)
        },
        getRightmostCoordinate: function() {
            return this.rightMostCoord
        },
        computeNodeDepth: function(a) {
            for (var b = null, c = a.getEdges().iterator(); c.hasNext();) {
                var d = c.next();
                if (d.isVisited() || d.getSym().isVisited()) {
                    b = d;
                    break
                }
            }
            if (null === b) throw new Ja("unable to find edge to compute depths at " + a.getCoordinate());
            a.getEdges().computeDepths(b);
            for (c = a.getEdges().iterator(); c.hasNext();) d = c.next(), d.setVisited(!0), this.copySymDepths(d)
        },
        computeDepth: function(a) {
            this.clearVisitedEdges();
            var b = this.finder.getEdge();
            b.getNode();
            b.getLabel();
            b.setEdgeDepths(p.RIGHT, a);
            this.copySymDepths(b);
            this.computeDepths(b)
        },
        create: function(a) {
            this.addReachable(a);
            this.finder.findEdge(this.dirEdgeList);
            this.rightMostCoord = this.finder.getCoordinate()
        },
        findResultEdges: function() {
            for (var a = this.dirEdgeList.iterator(); a.hasNext();) {
                var b = a.next();
                1 <= b.getDepth(p.RIGHT) && 0 >= b.getDepth(p.LEFT) && !b.isInteriorAreaEdge() && b.setInResult(!0)
            }
        },
        computeDepths: function(a) {
            var b = new ma,
                c = new Ie,
                d = a.getNode();
            c.addLast(d);
            b.add(d);
            for (a.setVisited(!0); !c.isEmpty();)
                for (a = c.removeFirst(), b.add(a), this.computeNodeDepth(a), a = a.getEdges().iterator(); a.hasNext();) d = a.next().getSym(), d.isVisited() || (d = d.getNode(), b.contains(d) || (c.addLast(d), b.add(d)))
        },
        compareTo: function(a) {
            return this.rightMostCoord.x < a.rightMostCoord.x ? -1 : this.rightMostCoord.x > a.rightMostCoord.x ? 1 : 0
        },
        getEnvelope: function() {
            if (null === this.env) {
                for (var a = new y, b = this.dirEdgeList.iterator(); b.hasNext();)
                    for (var c = b.next().getEdge().getCoordinates(),
                            d = 0; d < c.length - 1; d++) a.expandToInclude(c[d]);
                this.env = a
            }
            return this.env
        },
        addReachable: function(a) {
            var b = new xa;
            for (b.add(a); !b.empty();) a = b.pop(), this.add(a, b)
        },
        copySymDepths: function(a) {
            var b = a.getSym();
            b.setDepth(p.LEFT, a.getDepth(p.RIGHT));
            b.setDepth(p.RIGHT, a.getDepth(p.LEFT))
        },
        add: function(a, b) {
            a.setVisited(!0);
            this.nodes.add(a);
            for (var c = a.getEdges().iterator(); c.hasNext();) {
                var d = c.next();
                this.dirEdgeList.add(d);
                d = d.getSym().getNode();
                d.isVisited() || b.push(d)
            }
        },
        getNodes: function() {
            return this.nodes
        },
        getDirectedEdges: function() {
            return this.dirEdgeList
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return Pf
        }
    });
    g(oa.prototype, {
        isDeletable: function(a, b, c, d) {
            var e = this.inputLine[a];
            b = this.inputLine[b];
            var f = this.inputLine[c];
            return !!this.isConcave(e, b, f) && !!this.isShallow(e, b, f, d) && this.isShallowSampled(e, b, a, c, d)
        },
        deleteShallowConcavities: function() {
            for (var a = 1, b = (this.inputLine.length, this.findNextNonDeletedIndex(a)), c = this.findNextNonDeletedIndex(b), d = !1; c < this.inputLine.length;) {
                var e = !1;
                this.isDeletable(a, b, c, this.distanceTol) && (this.isDeleted[b] = oa.DELETE, e = !0, d = !0);
                a = e ? c : b;
                b = this.findNextNonDeletedIndex(a);
                c = this.findNextNonDeletedIndex(b)
            }
            return d
        },
        isShallowConcavity: function(a, b, c, d) {
            return q.computeOrientation(a, b, c) === this.angleOrientation && q.distancePointLine(b, a, c) < d
        },
        isShallowSampled: function(a, b, c, d, e) {
            var f = Math.trunc((d - c) / oa.NUM_PTS_TO_CHECK);
            for (0 >= f && (f = 1); c < d; c += f)
                if (!this.isShallow(a, b, this.inputLine[c], e)) return !1;
            return !0
        },
        isConcave: function(a, b, c) {
            return q.computeOrientation(a,
                b, c) === this.angleOrientation
        },
        simplify: function(a) {
            this.distanceTol = Math.abs(a);
            0 > a && (this.angleOrientation = q.CLOCKWISE);
            this.isDeleted = Array(this.inputLine.length).fill(null);
            a = !1;
            do a = this.deleteShallowConcavities(); while (a);
            return this.collapseLine()
        },
        findNextNonDeletedIndex: function(a) {
            for (a += 1; a < this.inputLine.length && this.isDeleted[a] === oa.DELETE;) a++;
            return a
        },
        isShallow: function(a, b, c, d) {
            return q.distancePointLine(b, a, c) < d
        },
        collapseLine: function() {
            for (var a = new Z, b = 0; b < this.inputLine.length; b++) this.isDeleted[b] !==
                oa.DELETE && a.add(this.inputLine[b]);
            return a.toCoordinateArray()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return oa
        }
    });
    oa.simplify = function(a, b) {
        return (new oa(a)).simplify(b)
    };
    oa.INIT = 0;
    oa.DELETE = 1;
    oa.KEEP = 1;
    oa.NUM_PTS_TO_CHECK = 10;
    g(Hd.prototype, {
        getCoordinates: function() {
            return this.ptList.toArray(Hd.COORDINATE_ARRAY_TYPE)
        },
        setPrecisionModel: function(a) {
            this.precisionModel = a
        },
        addPt: function(a) {
            a = new k(a);
            if (this.precisionModel.makePrecise(a), this.isRedundant(a)) return null;
            this.ptList.add(a)
        },
        reverse: function() {},
        addPts: function(a, b) {
            if (b)
                for (var c = 0; c < a.length; c++) this.addPt(a[c]);
            else
                for (c = a.length - 1; 0 <= c; c--) this.addPt(a[c])
        },
        isRedundant: function(a) {
            if (1 > this.ptList.size()) return !1;
            var b = this.ptList.get(this.ptList.size() - 1);
            return a.distance(b) < this.minimimVertexDistance
        },
        toString: function() {
            return (new E).createLineString(this.getCoordinates()).toString()
        },
        closeRing: function() {
            if (1 > this.ptList.size()) return null;
            var a = new k(this.ptList.get(0)),
                b = this.ptList.get(this.ptList.size() -
                    1);
            if (2 <= this.ptList.size() && this.ptList.get(this.ptList.size() - 2), a.equals(b)) return null;
            this.ptList.add(a)
        },
        setMinimumVertexDistance: function(a) {
            this.minimimVertexDistance = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Hd
        }
    });
    Hd.COORDINATE_ARRAY_TYPE = [].fill(null);
    g(sb.prototype, {
        addNextSegment: function(a, b) {
            if (this.s0 = this.s1, this.s1 = this.s2, this.s2 = a, this.seg0.setCoordinates(this.s0, this.s1), this.computeOffsetSegment(this.seg0, this.side, this.distance, this.offset0), this.seg1.setCoordinates(this.s1,
                    this.s2), this.computeOffsetSegment(this.seg1, this.side, this.distance, this.offset1), this.s1.equals(this.s2)) return null;
            var c = q.computeOrientation(this.s0, this.s1, this.s2),
                d = c === q.CLOCKWISE && this.side === p.LEFT || c === q.COUNTERCLOCKWISE && this.side === p.RIGHT;
            0 === c ? this.addCollinear(b) : d ? this.addOutsideTurn(c, b) : this.addInsideTurn(c, b)
        },
        addLineEndCap: function(a, b) {
            var c = new A(a, b),
                d = new A;
            this.computeOffsetSegment(c, p.LEFT, this.distance, d);
            var e = new A;
            this.computeOffsetSegment(c, p.RIGHT, this.distance, e);
            var f = Math.atan2(b.y - a.y, b.x - a.x);
            switch (this.bufParams.getEndCapStyle()) {
                case I.CAP_ROUND:
                    this.segList.addPt(d.p1);
                    this.addFilletArc(b, f + Math.PI / 2, f - Math.PI / 2, q.CLOCKWISE, this.distance);
                    this.segList.addPt(e.p1);
                    break;
                case I.CAP_FLAT:
                    this.segList.addPt(d.p1);
                    this.segList.addPt(e.p1);
                    break;
                case I.CAP_SQUARE:
                    c = new k, c.x = Math.abs(this.distance) * Math.cos(f), c.y = Math.abs(this.distance) * Math.sin(f), d = new k(d.p1.x + c.x, d.p1.y + c.y), e = new k(e.p1.x + c.x, e.p1.y + c.y), this.segList.addPt(d), this.segList.addPt(e)
            }
        },
        getCoordinates: function() {
            return this.segList.getCoordinates()
        },
        addMitreJoin: function(a, b, c, d) {
            var e = !0,
                f = null;
            try {
                f = Ha.intersection(b.p0, b.p1, c.p0, c.p1), (0 >= d ? 1 : f.distance(a) / Math.abs(d)) > this.bufParams.getMitreLimit() && (e = !1)
            } catch (g) {
                if (!(g instanceof xb)) throw g;
                f = new k(0, 0);
                e = !1
            }
            e ? this.segList.addPt(f) : this.addLimitedMitreJoin(b, c, d, this.bufParams.getMitreLimit())
        },
        addFilletCorner: function(a, b, c, d, e) {
            var f = Math.atan2(b.y - a.y, b.x - a.x),
                g = Math.atan2(c.y - a.y, c.x - a.x);
            d === q.CLOCKWISE ? f <= g && (f += 2 *
                Math.PI) : f >= g && (f -= 2 * Math.PI);
            this.segList.addPt(b);
            this.addFilletArc(a, f, g, d, e);
            this.segList.addPt(c)
        },
        addOutsideTurn: function(a, b) {
            if (this.offset0.p1.distance(this.offset1.p0) < this.distance * sb.OFFSET_SEGMENT_SEPARATION_FACTOR) return this.segList.addPt(this.offset0.p1), null;
            this.bufParams.getJoinStyle() === I.JOIN_MITRE ? this.addMitreJoin(this.s1, this.offset0, this.offset1, this.distance) : this.bufParams.getJoinStyle() === I.JOIN_BEVEL ? this.addBevelJoin(this.offset0, this.offset1) : (b && this.segList.addPt(this.offset0.p1),
                this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, a, this.distance), this.segList.addPt(this.offset1.p0))
        },
        createSquare: function(a) {
            this.segList.addPt(new k(a.x + this.distance, a.y + this.distance));
            this.segList.addPt(new k(a.x + this.distance, a.y - this.distance));
            this.segList.addPt(new k(a.x - this.distance, a.y - this.distance));
            this.segList.addPt(new k(a.x - this.distance, a.y + this.distance));
            this.segList.closeRing()
        },
        addSegments: function(a, b) {
            this.segList.addPts(a, b)
        },
        addFirstSegment: function() {
            this.segList.addPt(this.offset1.p0)
        },
        addLastSegment: function() {
            this.segList.addPt(this.offset1.p1)
        },
        initSideSegments: function(a, b, c) {
            this.s1 = a;
            this.s2 = b;
            this.side = c;
            this.seg1.setCoordinates(a, b);
            this.computeOffsetSegment(this.seg1, c, this.distance, this.offset1)
        },
        addLimitedMitreJoin: function(a, b, c, d) {
            a = this.seg0.p1;
            var e = B.angle(a, this.seg0.p0);
            b = (B.angle(a, this.seg1.p1), B.angleBetweenOriented(this.seg0.p0, a, this.seg1.p1)) / 2;
            e = B.normalize(e + b);
            e = B.normalize(e + Math.PI);
            d *= c;
            c -= d * Math.abs(Math.sin(b));
            d = new k(a.x + d * Math.cos(e), a.y + d * Math.sin(e));
            d = new A(a, d);
            a = d.pointAlongOffset(1, c);
            c = d.pointAlongOffset(1, -c);
            this.side === p.LEFT ? (this.segList.addPt(a), this.segList.addPt(c)) : (this.segList.addPt(c), this.segList.addPt(a))
        },
        computeOffsetSegment: function(a, b, c, d) {
            b = b === p.LEFT ? 1 : -1;
            var e = a.p1.x - a.p0.x,
                f = a.p1.y - a.p0.y,
                g = Math.sqrt(e * e + f * f),
                e = b * c * e / g;
            c = b * c * f / g;
            d.p0.x = a.p0.x - c;
            d.p0.y = a.p0.y + e;
            d.p1.x = a.p1.x - c;
            d.p1.y = a.p1.y + e
        },
        addFilletArc: function(a, b, c, d, e) {
            d = d === q.CLOCKWISE ? -1 : 1;
            c = Math.abs(b - c);
            var f = Math.trunc(c / this.filletAngleQuantum + .5);
            if (1 >
                f) return null;
            for (var g = null, g = c / f, f = 0, h = new k; f < c;) {
                var l = b + d * f;
                h.x = a.x + e * Math.cos(l);
                h.y = a.y + e * Math.sin(l);
                this.segList.addPt(h);
                f += g
            }
        },
        addInsideTurn: function(a, b) {
            if (this.li.computeIntersection(this.offset0.p0, this.offset0.p1, this.offset1.p0, this.offset1.p1), this.li.hasIntersection()) this.segList.addPt(this.li.getIntersection(0));
            else if (this._hasNarrowConcaveAngle = !0, this.offset0.p1.distance(this.offset1.p0) < this.distance * sb.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this.segList.addPt(this.offset0.p1);
            else {
                if (this.segList.addPt(this.offset0.p1), 0 < this.closingSegLengthFactor) {
                    var c = new k((this.closingSegLengthFactor * this.offset0.p1.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset0.p1.y + this.s1.y) / (this.closingSegLengthFactor + 1));
                    this.segList.addPt(c);
                    c = new k((this.closingSegLengthFactor * this.offset1.p0.x + this.s1.x) / (this.closingSegLengthFactor + 1), (this.closingSegLengthFactor * this.offset1.p0.y + this.s1.y) / (this.closingSegLengthFactor + 1));
                    this.segList.addPt(c)
                } else this.segList.addPt(this.s1);
                this.segList.addPt(this.offset1.p0)
            }
        },
        createCircle: function(a) {
            var b = new k(a.x + this.distance, a.y);
            this.segList.addPt(b);
            this.addFilletArc(a, 0, 2 * Math.PI, -1, this.distance);
            this.segList.closeRing()
        },
        addBevelJoin: function(a, b) {
            this.segList.addPt(a.p1);
            this.segList.addPt(b.p0)
        },
        init: function(a) {
            this.distance = a;
            this.maxCurveSegmentError = a * (1 - Math.cos(this.filletAngleQuantum / 2));
            this.segList = new Hd;
            this.segList.setPrecisionModel(this.precisionModel);
            this.segList.setMinimumVertexDistance(a * sb.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)
        },
        addCollinear: function(a) {
            this.li.computeIntersection(this.s0, this.s1, this.s1, this.s2);
            2 <= this.li.getIntersectionNum() && (this.bufParams.getJoinStyle() === I.JOIN_BEVEL || this.bufParams.getJoinStyle() === I.JOIN_MITRE ? (a && this.segList.addPt(this.offset0.p1), this.segList.addPt(this.offset1.p0)) : this.addFilletCorner(this.s1, this.offset0.p1, this.offset1.p0, q.CLOCKWISE, this.distance))
        },
        closeRing: function() {
            this.segList.closeRing()
        },
        hasNarrowConcaveAngle: function() {
            return this._hasNarrowConcaveAngle
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return sb
        }
    });
    sb.OFFSET_SEGMENT_SEPARATION_FACTOR = .001;
    sb.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001;
    sb.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1E-6;
    sb.MAX_CLOSING_SEG_LEN_FACTOR = 80;
    g(Id.prototype, {
        getOffsetCurve: function(a, b) {
            if (this.distance = b, 0 === b) return null;
            var c = 0 > b,
                d = this.getSegGen(Math.abs(b));
            1 >= a.length ? this.computePointCurve(a[0], d) : this.computeOffsetCurve(a, c, d);
            d = d.getCoordinates();
            return c && z.reverse(d), d
        },
        computeSingleSidedBufferCurve: function(a, b, c) {
            var d = this.simplifyTolerance(this.distance);
            if (b)
                for (c.addSegments(a, !0), b = oa.simplify(a, -d), a = b.length - 1, c.initSideSegments(b[a], b[a - 1], p.LEFT), c.addFirstSegment(), a -= 2; 0 <= a; a--) c.addNextSegment(b[a], !0);
            else
                for (c.addSegments(a, !1), b = oa.simplify(a, d), d = b.length - 1, c.initSideSegments(b[0], b[1], p.LEFT), c.addFirstSegment(), a = 2; a <= d; a++) c.addNextSegment(b[a], !0);
            c.addLastSegment();
            c.closeRing()
        },
        computeRingBufferCurve: function(a, b, c) {
            var d = this.simplifyTolerance(this.distance);
            b === p.RIGHT && (d = -d);
            a = oa.simplify(a, d);
            d = a.length - 1;
            c.initSideSegments(a[d -
                1], a[0], b);
            for (b = 1; b <= d; b++) c.addNextSegment(a[b], 1 !== b);
            c.closeRing()
        },
        computeLineBufferCurve: function(a, b) {
            var c = this.simplifyTolerance(this.distance),
                d = oa.simplify(a, c),
                e = d.length - 1;
            b.initSideSegments(d[0], d[1], p.LEFT);
            for (var f = 2; f <= e; f++) b.addNextSegment(d[f], !0);
            b.addLastSegment();
            b.addLineEndCap(d[e - 1], d[e]);
            c = oa.simplify(a, -c);
            f = c.length - 1;
            b.initSideSegments(c[f], c[f - 1], p.LEFT);
            for (f -= 2; 0 <= f; f--) b.addNextSegment(c[f], !0);
            b.addLastSegment();
            b.addLineEndCap(c[1], c[0]);
            b.closeRing()
        },
        computePointCurve: function(a,
            b) {
            switch (this.bufParams.getEndCapStyle()) {
                case I.CAP_ROUND:
                    b.createCircle(a);
                    break;
                case I.CAP_SQUARE:
                    b.createSquare(a)
            }
        },
        getLineCurve: function(a, b) {
            if ((this.distance = b, 0 > b && !this.bufParams.isSingleSided()) || 0 === b) return null;
            var c = this.getSegGen(Math.abs(b));
            1 >= a.length ? this.computePointCurve(a[0], c) : this.bufParams.isSingleSided() ? this.computeSingleSidedBufferCurve(a, 0 > b, c) : this.computeLineBufferCurve(a, c);
            return c.getCoordinates()
        },
        getBufferParameters: function() {
            return this.bufParams
        },
        simplifyTolerance: function(a) {
            return a *
                this.bufParams.getSimplifyFactor()
        },
        getRingCurve: function(a, b, c) {
            if (this.distance = c, 2 >= a.length) return this.getLineCurve(a, c);
            if (0 === c) return Id.copyCoordinates(a);
            c = this.getSegGen(c);
            return this.computeRingBufferCurve(a, b, c), c.getCoordinates()
        },
        computeOffsetCurve: function(a, b, c) {
            var d = this.simplifyTolerance(this.distance);
            if (b)
                for (b = oa.simplify(a, -d), a = b.length - 1, c.initSideSegments(b[a], b[a - 1], p.LEFT), c.addFirstSegment(), a -= 2; 0 <= a; a--) c.addNextSegment(b[a], !0);
            else
                for (b = oa.simplify(a, d), d = b.length -
                    1, c.initSideSegments(b[0], b[1], p.LEFT), c.addFirstSegment(), a = 2; a <= d; a++) c.addNextSegment(b[a], !0);
            c.addLastSegment()
        },
        getSegGen: function(a) {
            return new sb(this.precisionModel, this.bufParams, a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Id
        }
    });
    Id.copyCoordinates = function(a) {
        for (var b = Array(a.length).fill(null), c = 0; c < b.length; c++) b[c] = new k(a[c]);
        return b
    };
    g(Je.prototype, {
        findStabbedSegments: function() {
            if (1 === arguments.length) {
                for (var a = arguments[0], b = new l, c = this.subgraphs.iterator(); c.hasNext();) {
                    var d =
                        c.next(),
                        e = d.getEnvelope();
                    a.y < e.getMinY() || a.y > e.getMaxY() || this.findStabbedSegments(a, d.getDirectedEdges(), b)
                }
                return b
            }
            if (3 === arguments.length)
                if (u(arguments[2], ga) && arguments[0] instanceof k && arguments[1] instanceof wc)
                    for (a = arguments[0], b = arguments[1], d = arguments[2], e = b.getEdge().getCoordinates(), c = 0; c < e.length - 1; c++) {
                        if (this.seg.p0 = e[c], this.seg.p1 = e[c + 1], this.seg.p0.y > this.seg.p1.y && this.seg.reverse(), !(Math.max(this.seg.p0.x, this.seg.p1.x) < a.x || this.seg.isHorizontal() || a.y < this.seg.p0.y || a.y >
                                this.seg.p1.y || q.computeOrientation(this.seg.p0, this.seg.p1, a) === q.RIGHT)) {
                            var f = b.getDepth(p.LEFT);
                            this.seg.p0.equals(e[c]) || (f = b.getDepth(p.RIGHT));
                            f = new Ke(this.seg, f);
                            d.add(f)
                        }
                    } else if (u(arguments[2], ga) && arguments[0] instanceof k && u(arguments[1], ga))
                        for (a = arguments[0], b = arguments[2], c = arguments[1].iterator(); c.hasNext();) d = c.next(), d.isForward() && this.findStabbedSegments(a, d, b)
        },
        getDepth: function(a) {
            a = this.findStabbedSegments(a);
            return 0 === a.size() ? 0 : vb.min(a).leftDepth
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Je
        }
    });
    g(Ke.prototype, {
        compareTo: function(a) {
            if (this.upwardSeg.minX() >= a.upwardSeg.maxX()) return 1;
            if (this.upwardSeg.maxX() <= a.upwardSeg.minX()) return -1;
            var b = this.upwardSeg.orientationIndex(a.upwardSeg);
            return 0 !== b ? b : (b = -1 * a.upwardSeg.orientationIndex(this.upwardSeg), 0 !== b ? b : this.upwardSeg.compareTo(a.upwardSeg))
        },
        compareX: function(a, b) {
            var c = a.p0.compareTo(b.p0);
            return 0 !== c ? c : a.p1.compareTo(b.p1)
        },
        toString: function() {
            return this.upwardSeg.toString()
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return Ke
        }
    });
    Je.DepthSegment = Ke;
    g(Qf.prototype, {
        addPoint: function(a) {
            if (0 >= this.distance) return null;
            a = a.getCoordinates();
            a = this.curveBuilder.getLineCurve(a, this.distance);
            this.addCurve(a, h.EXTERIOR, h.INTERIOR)
        },
        addPolygon: function(a) {
            var b = this.distance,
                c = p.LEFT;
            0 > this.distance && (b = -this.distance, c = p.RIGHT);
            var d = a.getExteriorRing(),
                e = z.removeRepeatedPoints(d.getCoordinates());
            if (0 > this.distance && this.isErodedCompletely(d, this.distance) || 0 >= this.distance && 3 > e.length) return null;
            this.addPolygonRing(e, b, c, h.EXTERIOR, h.INTERIOR);
            for (d = 0; d < a.getNumInteriorRing(); d++) {
                var e = a.getInteriorRingN(d),
                    f = z.removeRepeatedPoints(e.getCoordinates());
                0 < this.distance && this.isErodedCompletely(e, -this.distance) || this.addPolygonRing(f, b, p.opposite(c), h.INTERIOR, h.EXTERIOR)
            }
        },
        isTriangleErodedCompletely: function(a, b) {
            var c = new S(a[0], a[1], a[2]),
                d = c.inCentre();
            return q.distancePointLine(d, c.p0, c.p1) < Math.abs(b)
        },
        addLineString: function(a) {
            if (0 >= this.distance && !this.curveBuilder.getBufferParameters().isSingleSided()) return null;
            a = z.removeRepeatedPoints(a.getCoordinates());
            a = this.curveBuilder.getLineCurve(a, this.distance);
            this.addCurve(a, h.EXTERIOR, h.INTERIOR)
        },
        addCurve: function(a, b, c) {
            if (null === a || 2 > a.length) return null;
            a = new nb(a, new ca(0, h.BOUNDARY, b, c));
            this.curveList.add(a)
        },
        getCurves: function() {
            return this.add(this.inputGeom), this.curveList
        },
        addPolygonRing: function(a, b, c, d, e) {
            if (0 === b && a.length < aa.MINIMUM_VALID_SIZE) return null;
            var f = d,
                g = e;
            a.length >= aa.MINIMUM_VALID_SIZE && q.isCCW(a) && (f = e, g = d, c = p.opposite(c));
            a = this.curveBuilder.getRingCurve(a,
                c, b);
            this.addCurve(a, f, g)
        },
        add: function(a) {
            if (a.isEmpty()) return null;
            if (a instanceof O) this.addPolygon(a);
            else if (a instanceof C) this.addLineString(a);
            else if (a instanceof W) this.addPoint(a);
            else {
                if (!(a instanceof Ia || a instanceof wa || a instanceof na || a instanceof F)) throw new UnsupportedOperationException(a.getClass().getName());
                this.addCollection(a)
            }
        },
        isErodedCompletely: function(a, b) {
            var c = a.getCoordinates();
            if (4 > c.length) return 0 > b;
            if (4 === c.length) return this.isTriangleErodedCompletely(c, b);
            c =
                a.getEnvelopeInternal();
            c = Math.min(c.getHeight(), c.getWidth());
            return 0 > b && 2 * Math.abs(b) > c
        },
        addCollection: function(a) {
            for (var b = 0; b < a.getNumGeometries(); b++) {
                var c = a.getGeometryN(b);
                this.add(c)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Qf
        }
    });
    g(Jd.prototype, {
        isTrivialIntersection: function(a, b, c, d) {
            return a === c && 1 === this.li.getIntersectionNum() && (Jd.isAdjacentSegments(b, d) || a.isClosed() && (a = a.size() - 1, 0 === b && d === a || 0 === d && b === a)) ? !0 : !1
        },
        getProperIntersectionPoint: function() {
            return this.properIntersectionPoint
        },
        hasProperInteriorIntersection: function() {
            return this.hasProperInterior
        },
        getLineIntersector: function() {
            return this.li
        },
        hasProperIntersection: function() {
            return this.hasProper
        },
        processIntersections: function(a, b, c, d) {
            if (a === c && b === d) return null;
            this.numTests++;
            var e = a.getCoordinates()[b],
                f = a.getCoordinates()[b + 1],
                g = c.getCoordinates()[d],
                h = c.getCoordinates()[d + 1];
            this.li.computeIntersection(e, f, g, h);
            this.li.hasIntersection() && (this.numIntersections++, this.li.isInteriorIntersection() && (this.numInteriorIntersections++,
                this.hasInterior = !0), this.isTrivialIntersection(a, b, c, d) || (this._hasIntersection = !0, a.addIntersections(this.li, b, 0), c.addIntersections(this.li, d, 1), this.li.isProper() && (this.numProperIntersections++, this.hasProper = !0, this.hasProperInterior = !0)))
        },
        hasIntersection: function() {
            return this._hasIntersection
        },
        isDone: function() {
            return !1
        },
        hasInteriorIntersection: function() {
            return this.hasInterior
        },
        interfaces_: function() {
            return [td]
        },
        getClass: function() {
            return Jd
        }
    });
    Jd.isAdjacentSegments = function(a, b) {
        return 1 ===
            Math.abs(a - b)
    };
    g(ic.prototype, {
        setWorkingPrecisionModel: function(a) {
            this.workingPrecisionModel = a
        },
        insertUniqueEdge: function(a) {
            var b = this.edgeList.findEqualEdge(a);
            if (null !== b) {
                var c = b.getLabel(),
                    d = a.getLabel();
                b.isPointwiseEqual(a) || (d = new ca(a.getLabel()), d.flip());
                c.merge(d);
                a = ic.depthDelta(d);
                c = b.getDepthDelta();
                b.setDepthDelta(c + a)
            } else this.edgeList.add(a), a.setDepthDelta(ic.depthDelta(a.getLabel()))
        },
        buildSubgraphs: function(a, b) {
            for (var c = new l, d = a.iterator(); d.hasNext();) {
                var e = d.next(),
                    f =
                    e.getRightmostCoordinate(),
                    f = (new Je(c)).getDepth(f);
                e.computeDepth(f);
                e.findResultEdges();
                c.add(e);
                b.add(e.getDirectedEdges(), e.getNodes())
            }
        },
        createSubgraphs: function(a) {
            var b = new l;
            for (a = a.getNodes().iterator(); a.hasNext();) {
                var c = a.next();
                if (!c.isVisited()) {
                    var d = new Pf;
                    d.create(c);
                    b.add(d)
                }
            }
            return vb.sort(b, vb.reverseOrder()), b
        },
        createEmptyResultGeometry: function() {
            return this.geomFact.createPolygon()
        },
        getNoder: function(a) {
            if (null !== this.workingNoder) return this.workingNoder;
            var b = new $b,
                c = new ia;
            return c.setPrecisionModel(a), b.setSegmentIntersector(new Jd(c)), b
        },
        buffer: function(a, b) {
            var c = this.workingPrecisionModel;
            null === c && (c = a.getPrecisionModel());
            this.geomFact = a.getFactory();
            var d = new Id(c, this.bufParams),
                d = (new Qf(a, b, d)).getCurves();
            if (0 >= d.size()) return this.createEmptyResultGeometry();
            this.computeNodedEdges(d, c);
            this.graph = new pb(new Qc);
            this.graph.addEdges(this.edgeList.getEdges());
            c = this.createSubgraphs(this.graph);
            d = new se(this.geomFact);
            this.buildSubgraphs(c, d);
            c = d.getPolygons();
            return 0 >= c.size() ? this.createEmptyResultGeometry() : this.geomFact.buildGeometry(c)
        },
        computeNodedEdges: function(a, b) {
            var c = this.getNoder(b);
            c.computeNodes(a);
            for (c = c.getNodedSubstrings().iterator(); c.hasNext();) {
                var d = c.next(),
                    e = d.getCoordinates();
                2 === e.length && e[0].equals2D(e[1]) || (e = d.getData(), d = new $a(d.getCoordinates(), new ca(e)), this.insertUniqueEdge(d))
            }
        },
        setNoder: function(a) {
            this.workingNoder = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ic
        }
    });
    ic.depthDelta = function(a) {
        var b =
            a.getLocation(0, p.LEFT);
        a = a.getLocation(0, p.RIGHT);
        return b === h.INTERIOR && a === h.EXTERIOR ? 1 : b === h.EXTERIOR && a === h.INTERIOR ? -1 : 0
    };
    ic.convertSegStrings = function(a) {
        for (var b = new E, c = new l; a.hasNext();) {
            var d = a.next(),
                d = b.createLineString(d.getCoordinates());
            c.add(d)
        }
        return b.buildGeometry(c)
    };
    g(Kd.prototype, {
        checkEndPtVertexIntersections: function() {
            if (0 === arguments.length)
                for (var a = this.segStrings.iterator(); a.hasNext();) {
                    var b = a.next(),
                        b = b.getCoordinates();
                    this.checkEndPtVertexIntersections(b[0], this.segStrings);
                    this.checkEndPtVertexIntersections(b[b.length - 1], this.segStrings)
                } else if (2 === arguments.length)
                    for (var c = arguments[0], a = arguments[1].iterator(); a.hasNext();)
                        for (var b = a.next(), b = b.getCoordinates(), d = 1; d < b.length - 1; d++)
                            if (b[d].equals(c)) throw new la("found endpt/interior pt intersection at index " + d + " :pt " + c);
        },
        checkInteriorIntersections: function() {
            if (0 === arguments.length)
                for (var a = this.segStrings.iterator(); a.hasNext();)
                    for (var b = a.next(), c = this.segStrings.iterator(); c.hasNext();) {
                        var d = c.next();
                        this.checkInteriorIntersections(b, d)
                    } else if (2 === arguments.length)
                        for (var a = arguments[0], b = arguments[1], c = a.getCoordinates(), d = b.getCoordinates(), e = 0; e < c.length - 1; e++)
                            for (var f = 0; f < d.length - 1; f++) this.checkInteriorIntersections(a, e, b, f);
                    else if (4 === arguments.length) {
                d = arguments[0];
                e = arguments[1];
                b = arguments[2];
                c = arguments[3];
                if (d === b && e === c) return null;
                a = d.getCoordinates()[e];
                d = d.getCoordinates()[e + 1];
                e = b.getCoordinates()[c];
                b = b.getCoordinates()[c + 1];
                if (this.li.computeIntersection(a, d, e, b), this.li.hasIntersection() &&
                    (this.li.isProper() || this.hasInteriorIntersection(this.li, a, d) || this.hasInteriorIntersection(this.li, e, b))) throw new la("found non-noded intersection at " + a + "-" + d + " and " + e + "-" + b);
            }
        },
        checkValid: function() {
            this.checkEndPtVertexIntersections();
            this.checkInteriorIntersections();
            this.checkCollapses()
        },
        checkCollapses: function() {
            if (0 === arguments.length)
                for (var a = this.segStrings.iterator(); a.hasNext();) {
                    var b = a.next();
                    this.checkCollapses(b)
                } else if (1 === arguments.length)
                    for (b = arguments[0].getCoordinates(),
                        a = 0; a < b.length - 2; a++) this.checkCollapse(b[a], b[a + 1], b[a + 2])
        },
        hasInteriorIntersection: function(a, b, c) {
            for (var d = 0; d < a.getIntersectionNum(); d++) {
                var e = a.getIntersection(d);
                if (!e.equals(b) && !e.equals(c)) return !0
            }
            return !1
        },
        checkCollapse: function(a, b, c) {
            if (a.equals(c)) throw new la("found non-noded collapse at " + Kd.fact.createLineString([a, b, c]));
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Kd
        }
    });
    Kd.fact = new E;
    g(Vc.prototype, {
        intersectsScaled: function(a, b) {
            var c = Math.max(a.x, b.x),
                d = Math.min(a.y,
                    b.y),
                e = Math.max(a.y, b.y);
            if (c = this.maxx < Math.min(a.x, b.x) || this.minx > c || this.maxy < d || this.miny > e) return !1;
            d = this.intersectsToleranceSquare(a, b);
            return t.isTrue(!(c && d), "Found bad envelope test"), d
        },
        initCorners: function(a) {
            this.minx = a.x - .5;
            this.maxx = a.x + .5;
            this.miny = a.y - .5;
            this.maxy = a.y + .5;
            this.corner[0] = new k(this.maxx, this.maxy);
            this.corner[1] = new k(this.minx, this.maxy);
            this.corner[2] = new k(this.minx, this.miny);
            this.corner[3] = new k(this.maxx, this.miny)
        },
        intersects: function(a, b) {
            return 1 === this.scaleFactor ?
                this.intersectsScaled(a, b) : (this.copyScaled(a, this.p0Scaled), this.copyScaled(b, this.p1Scaled), this.intersectsScaled(this.p0Scaled, this.p1Scaled))
        },
        scale: function(a) {
            return Math.round(a * this.scaleFactor)
        },
        getCoordinate: function() {
            return this.originalPt
        },
        copyScaled: function(a, b) {
            b.x = this.scale(a.x);
            b.y = this.scale(a.y)
        },
        getSafeEnvelope: function() {
            if (null === this.safeEnv) {
                var a = Vc.SAFE_ENV_EXPANSION_FACTOR / this.scaleFactor;
                this.safeEnv = new y(this.originalPt.x - a, this.originalPt.x + a, this.originalPt.y - a,
                    this.originalPt.y + a)
            }
            return this.safeEnv
        },
        intersectsPixelClosure: function(a, b) {
            return this.li.computeIntersection(a, b, this.corner[0], this.corner[1]), !!this.li.hasIntersection() || (this.li.computeIntersection(a, b, this.corner[1], this.corner[2]), !!this.li.hasIntersection() || (this.li.computeIntersection(a, b, this.corner[2], this.corner[3]), !!this.li.hasIntersection() || (this.li.computeIntersection(a, b, this.corner[3], this.corner[0]), !!this.li.hasIntersection())))
        },
        intersectsToleranceSquare: function(a, b) {
            var c = !1,
                d = !1;
            return this.li.computeIntersection(a, b, this.corner[0], this.corner[1]), !!this.li.isProper() || (this.li.computeIntersection(a, b, this.corner[1], this.corner[2]), !!this.li.isProper() || (this.li.hasIntersection() && (c = !0), this.li.computeIntersection(a, b, this.corner[2], this.corner[3]), !!this.li.isProper() || (this.li.hasIntersection() && (d = !0), this.li.computeIntersection(a, b, this.corner[3], this.corner[0]), !!this.li.isProper() || !(!c || !d) || !!a.equals(this.pt) || !!b.equals(this.pt))))
        },
        addSnappedNode: function(a,
            b) {
            var c = a.getCoordinate(b),
                d = a.getCoordinate(b + 1);
            return !!this.intersects(c, d) && (a.addIntersection(this.getCoordinate(), b), !0)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Vc
        }
    });
    Vc.SAFE_ENV_EXPANSION_FACTOR = .75;
    g(Le.prototype, {
        snap: function() {
            if (1 === arguments.length) return this.snap(arguments[0], null, -1);
            if (3 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = arguments[2],
                    d = a.getSafeEnvelope(),
                    e = new Ld(a, b, c);
                return this.index.query(d, {
                    interfaces_: function() {
                        return [Zb]
                    },
                    visitItem: function(a) {
                        a.select(d,
                            e)
                    }
                }), e.isNodeAdded()
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Le
        }
    });
    x(Ld, ec);
    g(Ld.prototype, {
        isNodeAdded: function() {
            return this._isNodeAdded
        },
        select: function() {
            if (2 !== arguments.length) return ec.prototype.select.apply(this, arguments);
            var a = arguments[1],
                b = arguments[0].getContext();
            if (null !== this.parentEdge && b === this.parentEdge && a === this.hotPixelVertexIndex) return null;
            this._isNodeAdded = this.hotPixel.addSnappedNode(b, a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ld
        }
    });
    Le.HotPixelSnapAction = Ld;
    g(Rf.prototype, {
        processIntersections: function(a, b, c, d) {
            if (a === c && b === d) return null;
            var e = a.getCoordinates()[b],
                f = a.getCoordinates()[b + 1],
                g = c.getCoordinates()[d],
                h = c.getCoordinates()[d + 1];
            if (this.li.computeIntersection(e, f, g, h), this.li.hasIntersection() && this.li.isInteriorIntersection()) {
                for (e = 0; e < this.li.getIntersectionNum(); e++) this.interiorIntersections.add(this.li.getIntersection(e));
                a.addIntersections(this.li, b, 0);
                c.addIntersections(this.li, d, 1)
            }
        },
        isDone: function() {
            return !1
        },
        getInteriorIntersections: function() {
            return this.interiorIntersections
        },
        interfaces_: function() {
            return [td]
        },
        getClass: function() {
            return Rf
        }
    });
    g(Sf.prototype, {
        checkCorrectness: function(a) {
            a = nb.getNodedSubstrings(a);
            a = new Kd(a);
            try {
                a.checkValid()
            } catch (b) {
                if (!(b instanceof of )) throw b;
                b.printStackTrace()
            }
        },
        getNodedSubstrings: function() {
            return nb.getNodedSubstrings(this.nodedSegStrings)
        },
        snapRound: function(a, b) {
            var c = this.findInteriorIntersections(a, b);
            this.computeIntersectionSnaps(c);
            this.computeVertexSnaps(a)
        },
        findInteriorIntersections: function(a, b) {
            var c = new Rf(b);
            return this.noder.setSegmentIntersector(c), this.noder.computeNodes(a), c.getInteriorIntersections()
        },
        computeVertexSnaps: function(a) {
            if (u(a, T))
                for (a = a.iterator(); a.hasNext();) {
                    var b = a.next();
                    this.computeVertexSnaps(b)
                } else if (a instanceof nb)
                    for (var b = a.getCoordinates(), c = 0; c < b.length; c++) {
                        var d = new Vc(b[c], this.scaleFactor, this.li);
                        this.pointSnapper.snap(d, a, c) && a.addIntersection(b[c], c)
                    }
        },
        computeNodes: function(a) {
            this.nodedSegStrings = a;
            this.noder =
                new $b;
            this.pointSnapper = new Le(this.noder.getIndex());
            this.snapRound(a, this.li)
        },
        computeIntersectionSnaps: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next(),
                    b = new Vc(b, this.scaleFactor, this.li);
                this.pointSnapper.snap(b)
            }
        },
        interfaces_: function() {
            return [rd]
        },
        getClass: function() {
            return Sf
        }
    });
    g(pa.prototype, {
        bufferFixedPrecision: function(a) {
            var b = new Fd(new Sf(new L(1)), a.getScale()),
                c = new ic(this.bufParams);
            c.setWorkingPrecisionModel(a);
            c.setNoder(b);
            this.resultGeometry = c.buffer(this.argGeom,
                this.distance)
        },
        bufferReducedPrecision: function() {
            if (0 === arguments.length) {
                for (var a = pa.MAX_PRECISION_DIGITS; 0 <= a; a--) {
                    try {
                        this.bufferReducedPrecision(a)
                    } catch (b) {
                        if (!(b instanceof Ja)) throw b;
                        this.saveException = b
                    }
                    if (null !== this.resultGeometry) return null
                }
                throw this.saveException;
            }
            1 === arguments.length && (a = pa.precisionScaleFactor(this.argGeom, this.distance, arguments[0]), a = new L(a), this.bufferFixedPrecision(a))
        },
        computeGeometry: function() {
            if (this.bufferOriginalPrecision(), null !== this.resultGeometry) return null;
            var a = this.argGeom.getFactory().getPrecisionModel();
            a.getType() === L.FIXED ? this.bufferFixedPrecision(a) : this.bufferReducedPrecision()
        },
        setQuadrantSegments: function(a) {
            this.bufParams.setQuadrantSegments(a)
        },
        bufferOriginalPrecision: function() {
            try {
                this.resultGeometry = (new ic(this.bufParams)).buffer(this.argGeom, this.distance)
            } catch (a) {
                if (!(a instanceof la)) throw a;
                this.saveException = a
            }
        },
        getResultGeometry: function(a) {
            return this.distance = a, this.computeGeometry(), this.resultGeometry
        },
        setEndCapStyle: function(a) {
            this.bufParams.setEndCapStyle(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return pa
        }
    });
    pa.bufferOp = function() {
        if (2 === arguments.length) {
            var a = arguments[1];
            return a = (new pa(arguments[0])).getResultGeometry(a)
        }
        if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof r && "number" == typeof arguments[1]) {
                var b = arguments[1],
                    c = arguments[2],
                    a = new pa(arguments[0]);
                a.setQuadrantSegments(c);
                return a = a.getResultGeometry(b)
            }
            if (arguments[2] instanceof I && arguments[0] instanceof r && "number" == typeof arguments[1]) return b =
                arguments[1], a = new pa(arguments[0], arguments[2]), a = a.getResultGeometry(b)
        } else if (4 === arguments.length) {
            var b = arguments[1],
                c = arguments[2],
                d = arguments[3],
                a = new pa(arguments[0]);
            a.setQuadrantSegments(c);
            a.setEndCapStyle(d);
            return a = a.getResultGeometry(b)
        }
    };
    pa.precisionScaleFactor = function(a, b, c) {
        a = a.getEnvelopeInternal();
        b = Oa.max(Math.abs(a.getMaxX()), Math.abs(a.getMaxY()), Math.abs(a.getMinX()), Math.abs(a.getMinY())) + 2 * (0 < b ? b : 0);
        return Math.pow(10, c - Math.trunc(Math.log(b) / Math.log(10) + 1))
    };
    pa.CAP_ROUND =
        I.CAP_ROUND;
    pa.CAP_BUTT = I.CAP_FLAT;
    pa.CAP_FLAT = I.CAP_FLAT;
    pa.CAP_SQUARE = I.CAP_SQUARE;
    pa.MAX_PRECISION_DIGITS = 12;
    var Og = Object.freeze({
        BufferOp: pa,
        BufferParameters: I
    });
    g(Cc.prototype, {
        filter: function(a) {
            a instanceof O && this.comps.add(a)
        },
        interfaces_: function() {
            return [Ab]
        },
        getClass: function() {
            return Cc
        }
    });
    Cc.getPolygons = function() {
        if (1 === arguments.length) return Cc.getPolygons(arguments[0], new l);
        if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            return a instanceof O ? b.add(a) : a instanceof F &&
                a.apply(new Cc(b)), b
        }
    };
    g(Ma.prototype, {
        isInsideArea: function() {
            return this.segIndex === Ma.INSIDE_AREA
        },
        getCoordinate: function() {
            return this.pt
        },
        getGeometryComponent: function() {
            return this.component
        },
        getSegmentIndex: function() {
            return this.segIndex
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ma
        }
    });
    Ma.INSIDE_AREA = -1;
    g(Dc.prototype, {
        filter: function(a) {
            a instanceof W && this.pts.add(a)
        },
        interfaces_: function() {
            return [Ab]
        },
        getClass: function() {
            return Dc
        }
    });
    Dc.getPoints = function() {
        if (1 === arguments.length) {
            var a =
                arguments[0];
            return a instanceof W ? vb.singletonList(a) : Dc.getPoints(a, new l)
        }
        if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1];
            return a instanceof W ? b.add(a) : a instanceof F && a.apply(new Dc(b)), b
        }
    };
    g(Md.prototype, {
        filter: function(a) {
            (a instanceof W || a instanceof C || a instanceof O) && this.locations.add(new Ma(a, 0, a.getCoordinate()))
        },
        interfaces_: function() {
            return [Ab]
        },
        getClass: function() {
            return Md
        }
    });
    Md.getLocations = function(a) {
        var b = new l;
        return a.apply(new Md(b)), b
    };
    g(ib.prototype, {
        computeContainmentDistance: function() {
            if (0 ===
                arguments.length) {
                var a = Array(2).fill(null);
                if (this.computeContainmentDistance(0, a), this.minDistance <= this.terminateDistance) return null;
                this.computeContainmentDistance(1, a)
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = 1 - a,
                    d = Cc.getPolygons(this.geom[a]);
                if (0 < d.size()) {
                    var e = Md.getLocations(this.geom[c]);
                    if (this.computeContainmentDistance(e, d, b), this.minDistance <= this.terminateDistance) return this.minDistanceLocation[c] = b[0], this.minDistanceLocation[a] = b[1], null
                }
            } else if (3 === arguments.length)
                if (arguments[2] instanceof Array && u(arguments[0], ga) && u(arguments[1], ga))
                    for (a = arguments[0], b = arguments[1], c = arguments[2], d = 0; d < a.size(); d++)
                        for (var e = a.get(d), f = 0; f < b.size(); f++) {
                            if (this.computeContainmentDistance(e, b.get(f), c), this.minDistance <= this.terminateDistance) return null
                        } else if (arguments[2] instanceof Array && arguments[0] instanceof Ma && arguments[1] instanceof O && (a = arguments[0], b = arguments[1], c = arguments[2], d = a.getCoordinate(), h.EXTERIOR !== this.ptLocator.locate(d, b))) return this.minDistance = 0, c[0] = a, c[1] = new Ma(b, d),
                            null
        },
        computeMinDistanceLinesPoints: function(a, b, c) {
            for (var d = 0; d < a.size(); d++)
                for (var e = a.get(d), f = 0; f < b.size(); f++) {
                    var g = b.get(f);
                    if (this.computeMinDistance(e, g, c), this.minDistance <= this.terminateDistance) return null
                }
        },
        computeFacetDistance: function() {
            var a = Array(2).fill(null),
                b = sa.getLines(this.geom[0]),
                c = sa.getLines(this.geom[1]),
                d = Dc.getPoints(this.geom[0]),
                e = Dc.getPoints(this.geom[1]);
            return this.computeMinDistanceLines(b, c, a), this.updateMinDistance(a, !1), this.minDistance <= this.terminateDistance ?
                null : (a[0] = null, a[1] = null, this.computeMinDistanceLinesPoints(b, e, a), this.updateMinDistance(a, !1), this.minDistance <= this.terminateDistance ? null : (a[0] = null, a[1] = null, this.computeMinDistanceLinesPoints(c, d, a), this.updateMinDistance(a, !0), this.minDistance <= this.terminateDistance ? null : (a[0] = null, a[1] = null, this.computeMinDistancePoints(d, e, a), void this.updateMinDistance(a, !1))))
        },
        nearestLocations: function() {
            return this.computeMinDistance(), this.minDistanceLocation
        },
        updateMinDistance: function(a, b) {
            if (null ===
                a[0]) return null;
            b ? (this.minDistanceLocation[0] = a[1], this.minDistanceLocation[1] = a[0]) : (this.minDistanceLocation[0] = a[0], this.minDistanceLocation[1] = a[1])
        },
        nearestPoints: function() {
            return this.computeMinDistance(), [this.minDistanceLocation[0].getCoordinate(), this.minDistanceLocation[1].getCoordinate()]
        },
        computeMinDistance: function() {
            if (0 === arguments.length) {
                if (null !== this.minDistanceLocation || (this.minDistanceLocation = Array(2).fill(null), this.computeContainmentDistance(), this.minDistance <= this.terminateDistance)) return null;
                this.computeFacetDistance()
            } else if (3 === arguments.length)
                if (arguments[2] instanceof Array && arguments[0] instanceof C && arguments[1] instanceof W) {
                    var a = arguments[0],
                        b = arguments[1],
                        c = arguments[2];
                    if (a.getEnvelopeInternal().distance(b.getEnvelopeInternal()) > this.minDistance) return null;
                    for (var d = a.getCoordinates(), e = b.getCoordinate(), f = 0; f < d.length - 1; f++) {
                        var g = q.distancePointLine(e, d[f], d[f + 1]);
                        g < this.minDistance && (this.minDistance = g, g = (new A(d[f], d[f + 1])).closestPoint(e), c[0] = new Ma(a, f, g), c[1] = new Ma(b,
                            0, e));
                        if (this.minDistance <= this.terminateDistance) return null
                    }
                } else if (arguments[2] instanceof Array && arguments[0] instanceof C && arguments[1] instanceof C) {
                a = arguments[0];
                b = arguments[1];
                c = arguments[2];
                if (a.getEnvelopeInternal().distance(b.getEnvelopeInternal()) > this.minDistance) return null;
                d = a.getCoordinates();
                e = b.getCoordinates();
                for (f = 0; f < d.length - 1; f++)
                    for (var h = 0; h < e.length - 1; h++) {
                        g = q.distanceLineLine(d[f], d[f + 1], e[h], e[h + 1]);
                        if (g < this.minDistance) {
                            this.minDistance = g;
                            var g = new A(d[f], d[f + 1]),
                                k = new A(e[h],
                                    e[h + 1]),
                                g = g.closestPoints(k);
                            c[0] = new Ma(a, f, g[0]);
                            c[1] = new Ma(b, h, g[1])
                        }
                        if (this.minDistance <= this.terminateDistance) return null
                    }
            }
        },
        computeMinDistancePoints: function(a, b, c) {
            for (var d = 0; d < a.size(); d++)
                for (var e = a.get(d), f = 0; f < b.size(); f++) {
                    var g = b.get(f),
                        h = e.getCoordinate().distance(g.getCoordinate());
                    if (h < this.minDistance && (this.minDistance = h, c[0] = new Ma(e, 0, e.getCoordinate()), c[1] = new Ma(g, 0, g.getCoordinate())), this.minDistance <= this.terminateDistance) return null
                }
        },
        distance: function() {
            if (null ===
                this.geom[0] || null === this.geom[1]) throw new K("null geometries are not supported");
            return this.geom[0].isEmpty() || this.geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this.minDistance)
        },
        computeMinDistanceLines: function(a, b, c) {
            for (var d = 0; d < a.size(); d++)
                for (var e = a.get(d), f = 0; f < b.size(); f++) {
                    var g = b.get(f);
                    if (this.computeMinDistance(e, g, c), this.minDistance <= this.terminateDistance) return null
                }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ib
        }
    });
    ib.distance = function(a, b) {
        return (new ib(a,
            b)).distance()
    };
    ib.isWithinDistance = function(a, b, c) {
        return (new ib(a, b, c)).distance() <= c
    };
    ib.nearestPoints = function(a, b) {
        return (new ib(a, b)).nearestPoints()
    };
    var Pg = Object.freeze({
        DistanceOp: ib
    });
    g(Tf.prototype, {
        getCoordinates: function() {
            if (null === this.coordinates) {
                for (var a = 0, b = 0, c = new Z, d = this.directedEdges.iterator(); d.hasNext();) {
                    var e = d.next();
                    e.getEdgeDirection() ? a++ : b++;
                    c.add(e.getEdge().getLine().getCoordinates(), !1, e.getEdgeDirection())
                }
                this.coordinates = c.toCoordinateArray();
                b > a && z.reverse(this.coordinates)
            }
            return this.coordinates
        },
        toLineString: function() {
            return this.factory.createLineString(this.getCoordinates())
        },
        add: function(a) {
            this.directedEdges.add(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Tf
        }
    });
    g(bb.prototype, {
        setVisited: function(a) {
            this._isVisited = a
        },
        isMarked: function() {
            return this._isMarked
        },
        setData: function(a) {
            this.data = a
        },
        getData: function() {
            return this.data
        },
        setMarked: function(a) {
            this._isMarked = a
        },
        getContext: function() {
            return this.data
        },
        isVisited: function() {
            return this._isVisited
        },
        setContext: function(a) {
            this.data =
                a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return bb
        }
    });
    bb.getComponentWithVisitedState = function(a, b) {
        for (; a.hasNext();) {
            var c = a.next();
            if (c.isVisited() === b) return c
        }
        return null
    };
    bb.setVisited = function(a, b) {
        for (; a.hasNext();) a.next().setVisited(b)
    };
    bb.setMarked = function(a, b) {
        for (; a.hasNext();) a.next().setMarked(b)
    };
    x(Ta, bb);
    g(Ta.prototype, {
        isRemoved: function() {
            return null === this.parentEdge
        },
        compareDirection: function(a) {
            return this.quadrant > a.quadrant ? 1 : this.quadrant < a.quadrant ? -1 : q.computeOrientation(a.p0,
                a.p1, this.p1)
        },
        getCoordinate: function() {
            return this.from.getCoordinate()
        },
        print: function(a) {
            var b = this.getClass().getName(),
                c = b.lastIndexOf("."),
                b = b.substring(c + 1);
            a.print("  " + b + ": " + this.p0 + " - " + this.p1 + " " + this.quadrant + ":" + this.angle)
        },
        getDirectionPt: function() {
            return this.p1
        },
        getAngle: function() {
            return this.angle
        },
        compareTo: function(a) {
            return this.compareDirection(a)
        },
        getFromNode: function() {
            return this.from
        },
        getSym: function() {
            return this.sym
        },
        setEdge: function(a) {
            this.parentEdge = a
        },
        remove: function() {
            this.parentEdge =
                this.sym = null
        },
        getEdge: function() {
            return this.parentEdge
        },
        getQuadrant: function() {
            return this.quadrant
        },
        setSym: function(a) {
            this.sym = a
        },
        getToNode: function() {
            return this.to
        },
        getEdgeDirection: function() {
            return this.edgeDirection
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return Ta
        }
    });
    Ta.toEdges = function(a) {
        var b = new l;
        for (a = a.iterator(); a.hasNext();) b.add(a.next().parentEdge);
        return b
    };
    x(Nd, Ta);
    g(Nd.prototype, {
        getNext: function() {
            return 2 !== this.getToNode().getDegree() ? null : this.getToNode().getOutEdges().getEdges().get(0) ===
                this.getSym() ? this.getToNode().getOutEdges().getEdges().get(1) : (t.isTrue(this.getToNode().getOutEdges().getEdges().get(1) === this.getSym()), this.getToNode().getOutEdges().getEdges().get(0))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Nd
        }
    });
    x(tb, bb);
    g(tb.prototype, {
        isRemoved: function() {
            return null === this.dirEdge
        },
        setDirectedEdges: function(a, b) {
            this.dirEdge = [a, b];
            a.setEdge(this);
            b.setEdge(this);
            a.setSym(b);
            b.setSym(a);
            a.getFromNode().addOutEdge(a);
            b.getFromNode().addOutEdge(b)
        },
        getDirEdge: function(a) {
            if (Number.isInteger(a)) return this.dirEdge[a];
            if (a instanceof Kb) return this.dirEdge[0].getFromNode() === a ? this.dirEdge[0] : this.dirEdge[1].getFromNode() === a ? this.dirEdge[1] : null
        },
        remove: function() {
            this.dirEdge = null
        },
        getOppositeNode: function(a) {
            return this.dirEdge[0].getFromNode() === a ? this.dirEdge[0].getToNode() : this.dirEdge[1].getFromNode() === a ? this.dirEdge[1].getToNode() : null
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return tb
        }
    });
    g(Uf.prototype, {
        getNextEdge: function(a) {
            a = this.getIndex(a);
            return this.outEdges.get(this.getIndex(a + 1))
        },
        getCoordinate: function() {
            var a = this.iterator();
            return a.hasNext() ? a.next().getCoordinate() : null
        },
        iterator: function() {
            return this.sortEdges(), this.outEdges.iterator()
        },
        sortEdges: function() {
            this.sorted || (vb.sort(this.outEdges), this.sorted = !0)
        },
        remove: function(a) {
            this.outEdges.remove(a)
        },
        getEdges: function() {
            return this.sortEdges(), this.outEdges
        },
        getNextCWEdge: function(a) {
            a = this.getIndex(a);
            return this.outEdges.get(this.getIndex(a - 1))
        },
        getIndex: function(a) {
            if (a instanceof tb) {
                this.sortEdges();
                for (var b =
                        0; b < this.outEdges.size(); b++) {
                    var c = this.outEdges.get(b);
                    if (c.getEdge() === a) return b
                }
                return -1
            }
            if (a instanceof Ta) {
                this.sortEdges();
                for (b = 0; b < this.outEdges.size(); b++)
                    if (c = this.outEdges.get(b), c === a) return b;
                return -1
            }
            if (Number.isInteger(a)) return a %= this.outEdges.size(), 0 > a && (a += this.outEdges.size()), a
        },
        add: function(a) {
            this.outEdges.add(a);
            this.sorted = !1
        },
        getDegree: function() {
            return this.outEdges.size()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Uf
        }
    });
    x(Kb, bb);
    g(Kb.prototype, {
        isRemoved: function() {
            return null ===
                this.pt
        },
        addOutEdge: function(a) {
            this.deStar.add(a)
        },
        getCoordinate: function() {
            return this.pt
        },
        getOutEdges: function() {
            return this.deStar
        },
        remove: function() {
            0 === arguments.length ? this.pt = null : 1 === arguments.length && this.deStar.remove(arguments[0])
        },
        getIndex: function(a) {
            return this.deStar.getIndex(a)
        },
        getDegree: function() {
            return this.deStar.getDegree()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Kb
        }
    });
    Kb.getEdgesBetween = function(a, b) {
        var c = Ta.toEdges(a.getOutEdges().getEdges()),
            c = new ma(c),
            d = Ta.toEdges(b.getOutEdges().getEdges());
        return c.retainAll(d), c
    };
    x(Me, tb);
    g(Me.prototype, {
        getLine: function() {
            return this.line
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Me
        }
    });
    g(Vf.prototype, {
        find: function(a) {
            return this.nodeMap.get(a)
        },
        iterator: function() {
            return this.nodeMap.values().iterator()
        },
        remove: function(a) {
            return this.nodeMap.remove(a)
        },
        values: function() {
            return this.nodeMap.values()
        },
        add: function(a) {
            return this.nodeMap.put(a.getCoordinate(), a), a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Vf
        }
    });
    g(Wc.prototype, {
        findNodesOfDegree: function(a) {
            for (var b = new l, c = this.nodeIterator(); c.hasNext();) {
                var d = c.next();
                d.getDegree() === a && b.add(d)
            }
            return b
        },
        dirEdgeIterator: function() {
            return this.dirEdges.iterator()
        },
        edgeIterator: function() {
            return this.edges.iterator()
        },
        remove: function(a) {
            if (a instanceof tb) this.remove(a.getDirEdge(0)), this.remove(a.getDirEdge(1)), this.edges.remove(a), a.remove();
            else if (a instanceof Ta) {
                var b = a.getSym();
                null !== b && b.setSym(null);
                a.getFromNode().remove(a);
                a.remove();
                this.dirEdges.remove(a)
            } else if (a instanceof Kb) {
                for (var c = a.getOutEdges().getEdges().iterator(); c.hasNext();) {
                    var d = c.next(),
                        b = d.getSym();
                    null !== b && this.remove(b);
                    this.dirEdges.remove(d);
                    b = d.getEdge();
                    null !== b && this.edges.remove(b)
                }
                this.nodeMap.remove(a.getCoordinate());
                a.remove()
            }
        },
        findNode: function(a) {
            return this.nodeMap.find(a)
        },
        getEdges: function() {
            return this.edges
        },
        nodeIterator: function() {
            return this.nodeMap.iterator()
        },
        contains: function(a) {
            if (a instanceof tb) return this.edges.contains(a);
            if (a instanceof Ta) return this.dirEdges.contains(a)
        },
        add: function(a) {
            a instanceof Kb ? this.nodeMap.add(a) : a instanceof tb ? (this.edges.add(a), this.add(a.getDirEdge(0)), this.add(a.getDirEdge(1))) : a instanceof Ta && this.dirEdges.add(a)
        },
        getNodes: function() {
            return this.nodeMap.values()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Wc
        }
    });
    x(Ne, Wc);
    g(Ne.prototype, {
        addEdge: function(a) {
            if (a.isEmpty()) return null;
            var b = z.removeRepeatedPoints(a.getCoordinates());
            if (1 >= b.length) return null;
            var c =
                b[b.length - 1],
                d = this.getNode(b[0]),
                e = this.getNode(c),
                c = new Nd(d, e, b[1], !0),
                b = new Nd(e, d, b[b.length - 2], !1);
            a = new Me(a);
            a.setDirectedEdges(c, b);
            this.add(a)
        },
        getNode: function(a) {
            var b = this.findNode(a);
            return null === b && (b = new Kb(a), this.add(b)), b
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ne
        }
    });
    g(Wf.prototype, {
        buildEdgeStringsForUnprocessedNodes: function() {
            for (var a = this.graph.getNodes().iterator(); a.hasNext();) {
                var b = a.next();
                b.isMarked() || (t.isTrue(2 === b.getDegree()), this.buildEdgeStringsStartingAt(b),
                    b.setMarked(!0))
            }
        },
        buildEdgeStringsForNonDegree2Nodes: function() {
            for (var a = this.graph.getNodes().iterator(); a.hasNext();) {
                var b = a.next();
                2 !== b.getDegree() && (this.buildEdgeStringsStartingAt(b), b.setMarked(!0))
            }
        },
        buildEdgeStringsForObviousStartNodes: function() {
            this.buildEdgeStringsForNonDegree2Nodes()
        },
        getMergedLineStrings: function() {
            return this.merge(), this.mergedLineStrings
        },
        buildEdgeStringsStartingAt: function(a) {
            for (a = a.getOutEdges().iterator(); a.hasNext();) {
                var b = a.next();
                b.getEdge().isMarked() ||
                    this.edgeStrings.add(this.buildEdgeStringStartingWith(b))
            }
        },
        merge: function() {
            if (null !== this.mergedLineStrings) return null;
            bb.setMarked(this.graph.nodeIterator(), !1);
            bb.setMarked(this.graph.edgeIterator(), !1);
            this.edgeStrings = new l;
            this.buildEdgeStringsForObviousStartNodes();
            this.buildEdgeStringsForIsolatedLoops();
            this.mergedLineStrings = new l;
            for (var a = this.edgeStrings.iterator(); a.hasNext();) {
                var b = a.next();
                this.mergedLineStrings.add(b.toLineString())
            }
        },
        buildEdgeStringStartingWith: function(a) {
            var b =
                new Tf(this.factory),
                c = a;
            do b.add(c), c.getEdge().setMarked(!0), c = c.getNext(); while (null !== c && c !== a);
            return b
        },
        add: function(a) {
            if (a instanceof r) a.apply({
                interfaces_: function() {
                    return [eb]
                },
                filter: function(a) {
                    a instanceof C && this.add(a)
                }
            });
            else if (u(a, T))
                for (this.mergedLineStrings = null, a = a.iterator(); a.hasNext();) {
                    var b = a.next();
                    this.add(b)
                } else a instanceof C && (null === this.factory && (this.factory = a.getFactory()), this.graph.addEdge(a))
        },
        buildEdgeStringsForIsolatedLoops: function() {
            this.buildEdgeStringsForUnprocessedNodes()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Wf
        }
    });
    var Qg = Object.freeze({
            LineMerger: Wf
        }),
        Rg = Object.freeze({
            OverlayOp: w
        });
    x(Od, Ta);
    g(Od.prototype, {
        getNext: function() {
            return this.next
        },
        isInRing: function() {
            return null !== this.edgeRing
        },
        setRing: function(a) {
            this.edgeRing = a
        },
        setLabel: function(a) {
            this.label = a
        },
        getLabel: function() {
            return this.label
        },
        setNext: function(a) {
            this.next = a
        },
        getRing: function() {
            return this.edgeRing
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Od
        }
    });
    x(Oe,
        tb);
    g(Oe.prototype, {
        getLine: function() {
            return this.line
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Oe
        }
    });
    g(Pd.prototype, {
        visitInteriorRing: function(a, b) {
            var c = a.getCoordinates(),
                d = c[0],
                c = Pd.findDifferentPoint(c, d),
                d = b.findEdgeInSameDirection(d, c),
                d = b.findEdgeEnd(d),
                c = null;
            d.getLabel().getLocation(0, p.RIGHT) === h.INTERIOR ? c = d : d.getSym().getLabel().getLocation(0, p.RIGHT) === h.INTERIOR && (c = d.getSym());
            t.isTrue(null !== c, "unable to find dirEdge with Interior on RHS");
            this.visitLinkedDirectedEdges(c)
        },
        visitShellInteriors: function(a, b) {
            if (a instanceof O) {
                var c;
                this.visitInteriorRing(a.getExteriorRing(), b)
            }
            if (a instanceof na)
                for (var d = 0; d < a.getNumGeometries(); d++) c = a.getGeometryN(d), this.visitInteriorRing(c.getExteriorRing(), b)
        },
        getCoordinate: function() {
            return this.disconnectedRingcoord
        },
        setInteriorEdgesInResult: function(a) {
            for (a = a.getEdgeEnds().iterator(); a.hasNext();) {
                var b = a.next();
                b.getLabel().getLocation(0, p.RIGHT) === h.INTERIOR && b.setInResult(!0)
            }
        },
        visitLinkedDirectedEdges: function(a) {
            var b =
                a;
            do t.isTrue(null !== b, "found null Directed Edge"), b.setVisited(!0), b = b.getNext(); while (b !== a)
        },
        buildEdgeRings: function(a) {
            var b = new l;
            for (a = a.iterator(); a.hasNext();) {
                var c = a.next();
                c.isInResult() && null === c.getEdgeRing() && (c = new vd(c, this.geometryFactory), c.linkDirectedEdgesForMinimalEdgeRings(), c = c.buildMinimalRings(), b.addAll(c))
            }
            return b
        },
        hasUnvisitedShellEdge: function(a) {
            for (var b = 0; b < a.size(); b++) {
                var c = a.get(b);
                if (!c.isHole()) {
                    var c = c.getEdges(),
                        d = c.get(0);
                    if (d.getLabel().getLocation(0, p.RIGHT) ===
                        h.INTERIOR)
                        for (var e = 0; e < c.size(); e++)
                            if (d = c.get(e), !d.isVisited()) return this.disconnectedRingcoord = d.getCoordinate(), !0
                }
            }
            return !1
        },
        isInteriorsConnected: function() {
            var a = new l;
            this.geomGraph.computeSplitEdges(a);
            var b = new pb(new Qc);
            b.addEdges(a);
            this.setInteriorEdgesInResult(b);
            b.linkResultDirectedEdges();
            a = this.buildEdgeRings(b.getEdgeEnds());
            return this.visitShellInteriors(this.geomGraph.getGeometry(), b), !this.hasUnvisitedShellEdge(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Pd
        }
    });
    Pd.findDifferentPoint = function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (!a[c].equals(b)) return a[c];
        return null
    };
    g(Pe.prototype, {
        createEdgeEndForNext: function(a, b, c, d) {
            var e = c.segmentIndex + 1;
            if (e >= a.getNumPoints() && null === d) return null;
            e = a.getCoordinate(e);
            null !== d && d.segmentIndex === c.segmentIndex && (e = d.coord);
            a = new ob(a, c.coord, e, new ca(a.getLabel()));
            b.add(a)
        },
        createEdgeEndForPrev: function(a, b, c, d) {
            var e = c.segmentIndex;
            if (0 === c.dist) {
                if (0 === e) return null;
                e--
            }
            var f = a.getCoordinate(e);
            null !== d && d.segmentIndex >=
                e && (f = d.coord);
            d = new ca(a.getLabel());
            d.flip();
            a = new ob(a, c.coord, f, d);
            b.add(a)
        },
        computeEdgeEnds: function() {
            if (1 === arguments.length) {
                for (var a = arguments[0], b = new l; a.hasNext();) {
                    var c = a.next();
                    this.computeEdgeEnds(c, b)
                }
                return b
            }
            if (2 === arguments.length) {
                a = arguments[0];
                b = arguments[1];
                c = a.getEdgeIntersectionList();
                c.addEndpoints();
                var c = c.iterator(),
                    d = null,
                    e = null;
                if (!c.hasNext()) return null;
                var f = c.next();
                do d = e, e = f, f = null, c.hasNext() && (f = c.next()), null !== e && (this.createEdgeEndForPrev(a, b, e, d), this.createEdgeEndForNext(a,
                    b, e, f)); while (null !== e)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Pe
        }
    });
    x(Qd, ob);
    g(Qd.prototype, {
        insert: function(a) {
            this.edgeEnds.add(a)
        },
        print: function(a) {
            a.println("EdgeEndBundle--\x3e Label: " + this.label);
            for (var b = this.iterator(); b.hasNext();) b.next().print(a), a.println()
        },
        iterator: function() {
            return this.edgeEnds.iterator()
        },
        getEdgeEnds: function() {
            return this.edgeEnds
        },
        computeLabelOn: function(a, b) {
            for (var c = 0, d = !1, e = this.iterator(); e.hasNext();) {
                var f = e.next().getLabel().getLocation(a);
                f === h.BOUNDARY && c++;
                f === h.INTERIOR && (d = !0)
            }
            f = h.NONE;
            d && (f = h.INTERIOR);
            0 < c && (f = Fa.determineBoundary(b, c));
            this.label.setLocation(a, f)
        },
        computeLabelSide: function(a, b) {
            for (var c = this.iterator(); c.hasNext();) {
                var d = c.next();
                if (d.getLabel().isArea()) {
                    d = d.getLabel().getLocation(a, b);
                    if (d === h.INTERIOR) return this.label.setLocation(a, b, h.INTERIOR), null;
                    d === h.EXTERIOR && this.label.setLocation(a, b, h.EXTERIOR)
                }
            }
        },
        getLabel: function() {
            return this.label
        },
        computeLabelSides: function(a) {
            this.computeLabelSide(a, p.LEFT);
            this.computeLabelSide(a, p.RIGHT)
        },
        updateIM: function(a) {
            $a.updateIM(this.label, a)
        },
        computeLabel: function(a) {
            for (var b = !1, c = this.iterator(); c.hasNext();) c.next().getLabel().isArea() && (b = !0);
            this.label = b ? new ca(h.NONE, h.NONE, h.NONE) : new ca(h.NONE);
            for (c = 0; 2 > c; c++) this.computeLabelOn(c, a), b && this.computeLabelSides(c)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Qd
        }
    });
    x(Qe, yc);
    g(Qe.prototype, {
        updateIM: function(a) {
            for (var b = this.iterator(); b.hasNext();) b.next().updateIM(a)
        },
        insert: function(a) {
            var b =
                this.edgeMap.get(a);
            null === b ? (b = new Qd(a), this.insertEdgeEnd(a, b)) : b.insert(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Qe
        }
    });
    x(Re, Gb);
    g(Re.prototype, {
        updateIMFromEdges: function(a) {
            this.edges.updateIM(a)
        },
        computeIM: function(a) {
            a.setAtLeastIfValid(this.label.getLocation(0), this.label.getLocation(1), 0)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Re
        }
    });
    x(Rd, xc);
    g(Rd.prototype, {
        createNode: function(a) {
            return new Re(a, new Qe)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Rd
        }
    });
    g(Xf.prototype, {
        insertEdgeEnds: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                this.nodes.add(b)
            }
        },
        getNodeIterator: function() {
            return this.nodes.iterator()
        },
        copyNodesAndLabels: function(a, b) {
            for (var c = a.getNodeIterator(); c.hasNext();) {
                var d = c.next();
                this.nodes.addNode(d.getCoordinate()).setLabel(b, d.getLabel().getLocation(b))
            }
        },
        build: function(a) {
            this.computeIntersectionNodes(a, 0);
            this.copyNodesAndLabels(a, 0);
            a = (new Pe).computeEdgeEnds(a.getEdgeIterator());
            this.insertEdgeEnds(a)
        },
        computeIntersectionNodes: function(a,
            b) {
            for (var c = a.getEdgeIterator(); c.hasNext();)
                for (var d = c.next(), e = d.getLabel().getLocation(b), d = d.getEdgeIntersectionList().iterator(); d.hasNext();) {
                    var f = d.next(),
                        f = this.nodes.addNode(f.coord);
                    e === h.BOUNDARY ? f.setLabelBoundary(b) : f.getLabel().isNull(b) && f.setLabel(b, h.INTERIOR)
                }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Xf
        }
    });
    g(Se.prototype, {
        isNodeEdgeAreaLabelsConsistent: function() {
            for (var a = this.nodeGraph.getNodeIterator(); a.hasNext();) {
                var b = a.next();
                if (!b.getEdges().isAreaLabelsConsistent(this.geomGraph)) return this.invalidPoint =
                    b.getCoordinate().copy(), !1
            }
            return !0
        },
        getInvalidPoint: function() {
            return this.invalidPoint
        },
        hasDuplicateRings: function() {
            for (var a = this.nodeGraph.getNodeIterator(); a.hasNext();)
                for (var b = a.next().getEdges().iterator(); b.hasNext();) {
                    var c = b.next();
                    if (1 < c.getEdgeEnds().size()) return this.invalidPoint = c.getEdge().getCoordinate(0), !0
                }
            return !1
        },
        isNodeConsistentArea: function() {
            var a = this.geomGraph.computeSelfNodes(this.li, !0, !0);
            return a.hasProperIntersection() ? (this.invalidPoint = a.getProperIntersectionPoint(), !1) : (this.nodeGraph.build(this.geomGraph), this.isNodeEdgeAreaLabelsConsistent())
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Se
        }
    });
    g(Yf.prototype, {
        buildIndex: function() {
            this.index = new X;
            for (var a = 0; a < this.rings.size(); a++) {
                var b = this.rings.get(a),
                    c = b.getEnvelopeInternal();
                this.index.insert(c, b)
            }
        },
        getNestedPoint: function() {
            return this.nestedPt
        },
        isNonNested: function() {
            this.buildIndex();
            for (var a = 0; a < this.rings.size(); a++)
                for (var b = this.rings.get(a), c = b.getCoordinates(), d = this.index.query(b.getEnvelopeInternal()),
                        e = 0; e < d.size(); e++) {
                    var f = d.get(e),
                        g = f.getCoordinates();
                    if (b !== f && b.getEnvelopeInternal().intersects(f.getEnvelopeInternal()) && (f = Ua.findPtNotNode(c, f, this.graph), null !== f && q.isPointInRing(f, g))) return this.nestedPt = f, !1
                }
            return !0
        },
        add: function(a) {
            this.rings.add(a);
            this.totalEnv.expandToInclude(a.getEnvelopeInternal())
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Yf
        }
    });
    g(G.prototype, {
        getErrorType: function() {
            return this.errorType
        },
        getMessage: function() {
            return G.errMsg[this.errorType]
        },
        getCoordinate: function() {
            return this.pt
        },
        toString: function() {
            var a = "";
            return null !== this.pt && (a = " at or near point " + this.pt), this.getMessage() + a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return G
        }
    });
    G.ERROR = 0;
    G.REPEATED_POINT = 1;
    G.HOLE_OUTSIDE_SHELL = 2;
    G.NESTED_HOLES = 3;
    G.DISCONNECTED_INTERIOR = 4;
    G.SELF_INTERSECTION = 5;
    G.RING_SELF_INTERSECTION = 6;
    G.NESTED_SHELLS = 7;
    G.DUPLICATE_RINGS = 8;
    G.TOO_FEW_POINTS = 9;
    G.INVALID_COORDINATE = 10;
    G.RING_NOT_CLOSED = 11;
    G.errMsg = "Topology Validation Error;Repeated Point;Hole lies outside shell;Holes are nested;Interior is disconnected;Self-intersection;Ring Self-intersection;Nested shells;Duplicate Rings;Too few distinct points in geometry component;Invalid Coordinate;Ring is not closed".split(";");
    g(Ua.prototype, {
        checkInvalidCoordinates: function(a) {
            if (a instanceof Array)
                for (var b = 0; b < a.length; b++) {
                    if (!Ua.isValid(a[b])) return this.validErr = new G(G.INVALID_COORDINATE, a[b]), null
                } else if (a instanceof O) {
                    if (this.checkInvalidCoordinates(a.getExteriorRing().getCoordinates()), null !== this.validErr) return null;
                    for (b = 0; b < a.getNumInteriorRing(); b++)
                        if (this.checkInvalidCoordinates(a.getInteriorRingN(b).getCoordinates()), null !== this.validErr) return null
                }
        },
        checkHolesNotNested: function(a, b) {
            for (var c = new Yf(b),
                    d = 0; d < a.getNumInteriorRing(); d++) {
                var e = a.getInteriorRingN(d);
                c.add(e)
            }
            c.isNonNested() || (this.validErr = new G(G.NESTED_HOLES, c.getNestedPoint()))
        },
        checkConsistentArea: function(a) {
            a = new Se(a);
            if (!a.isNodeConsistentArea()) return this.validErr = new G(G.SELF_INTERSECTION, a.getInvalidPoint()), null;
            a.hasDuplicateRings() && (this.validErr = new G(G.DUPLICATE_RINGS, a.getInvalidPoint()))
        },
        isValid: function() {
            return this.checkValid(this.parentGeometry), null === this.validErr
        },
        checkShellInsideHole: function(a, b, c) {
            var d =
                a.getCoordinates(),
                e = b.getCoordinates();
            b = Ua.findPtNotNode(d, b, c);
            if (null !== b && !q.isPointInRing(b, e)) return b;
            a = Ua.findPtNotNode(e, a, c);
            return null !== a ? q.isPointInRing(a, d) ? a : null : (t.shouldNeverReachHere("points in shell and hole appear to be equal"), null)
        },
        checkNoSelfIntersectingRings: function(a) {
            for (a = a.getEdgeIterator(); a.hasNext();) {
                var b = a.next();
                if (this.checkNoSelfIntersectingRing(b.getEdgeIntersectionList()), null !== this.validErr) return null
            }
        },
        checkConnectedInteriors: function(a) {
            a = new Pd(a);
            a.isInteriorsConnected() || (this.validErr = new G(G.DISCONNECTED_INTERIOR, a.getCoordinate()))
        },
        checkNoSelfIntersectingRing: function(a) {
            var b = new va,
                c = !0;
            for (a = a.iterator(); a.hasNext();) {
                var d = a.next();
                if (c) c = !1;
                else {
                    if (b.contains(d.coord)) return this.validErr = new G(G.RING_SELF_INTERSECTION, d.coord), null;
                    b.add(d.coord)
                }
            }
        },
        checkHolesInShell: function(a, b) {
            for (var c = a.getExteriorRing(), d = new zd(c), e = 0; e < a.getNumInteriorRing(); e++) {
                var f = a.getInteriorRingN(e),
                    f = Ua.findPtNotNode(f.getCoordinates(), c, b);
                if (null ===
                    f) return null;
                if (!d.isInside(f)) return this.validErr = new G(G.HOLE_OUTSIDE_SHELL, f), null
            }
        },
        checkTooFewPoints: function(a) {
            if (a.hasTooFewPoints()) return this.validErr = new G(G.TOO_FEW_POINTS, a.getInvalidPoint()), null
        },
        getValidationError: function() {
            return this.checkValid(this.parentGeometry), this.validErr
        },
        checkValid: function(a) {
            if (a instanceof W) this.checkInvalidCoordinates(a.getCoordinates());
            else if (a instanceof Ia) this.checkInvalidCoordinates(a.getCoordinates());
            else if (a instanceof aa) {
                if ((this.checkInvalidCoordinates(a.getCoordinates()),
                        null !== this.validErr) || (this.checkClosedRing(a), null !== this.validErr)) return null;
                var b = new Fa(0, a);
                if (this.checkTooFewPoints(b), null !== this.validErr) return null;
                a = new ia;
                b.computeSelfNodes(a, !0, !0);
                this.checkNoSelfIntersectingRings(b)
            } else if (a instanceof C) {
                if (this.checkInvalidCoordinates(a.getCoordinates()), null !== this.validErr) return null;
                b = new Fa(0, a);
                this.checkTooFewPoints(b)
            } else if (a instanceof O) {
                if ((this.checkInvalidCoordinates(a), null !== this.validErr) || (this.checkClosedRings(a), null !==
                        this.validErr)) return null;
                b = new Fa(0, a);
                if ((this.checkTooFewPoints(b), null !== this.validErr) || (this.checkConsistentArea(b), null !== this.validErr) || !this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(b), null !== this.validErr) || (this.checkHolesInShell(a, b), null !== this.validErr) || (this.checkHolesNotNested(a, b), null !== this.validErr)) return null;
                this.checkConnectedInteriors(b)
            } else if (a instanceof na) {
                for (var c = 0; c < a.getNumGeometries(); c++) {
                    var d = a.getGeometryN(c);
                    if ((this.checkInvalidCoordinates(d),
                            null !== this.validErr) || (this.checkClosedRings(d), null !== this.validErr)) return null
                }
                b = new Fa(0, a);
                if ((this.checkTooFewPoints(b), null !== this.validErr) || (this.checkConsistentArea(b), null !== this.validErr) || !this.isSelfTouchingRingFormingHoleValid && (this.checkNoSelfIntersectingRings(b), null !== this.validErr)) return null;
                for (c = 0; c < a.getNumGeometries(); c++)
                    if (d = a.getGeometryN(c), this.checkHolesInShell(d, b), null !== this.validErr) return null;
                for (c = 0; c < a.getNumGeometries(); c++)
                    if (d = a.getGeometryN(c), this.checkHolesNotNested(d,
                            b), null !== this.validErr) return null;
                if (this.checkShellsNotNested(a, b), null !== this.validErr) return null;
                this.checkConnectedInteriors(b)
            } else if (a instanceof F)
                for (c = 0; c < a.getNumGeometries(); c++) {
                    if (b = a.getGeometryN(c), this.checkValid(b), null !== this.validErr) return null
                } else if (a instanceof r) {
                    if (this.validErr = null, a.isEmpty()) return null;
                    if (!(a instanceof W || a instanceof Ia || a instanceof aa || a instanceof C || a instanceof O || a instanceof na || a instanceof F)) throw new UnsupportedOperationException(a.getClass().getName());
                    this.checkValid(a)
                }
        },
        setSelfTouchingRingFormingHoleValid: function(a) {
            this.isSelfTouchingRingFormingHoleValid = a
        },
        checkShellNotNested: function(a, b, c) {
            var d = a.getCoordinates(),
                e = b.getExteriorRing(),
                f = e.getCoordinates(),
                d = Ua.findPtNotNode(d, e, c);
            if (null === d || !q.isPointInRing(d, f)) return null;
            if (0 >= b.getNumInteriorRing()) return this.validErr = new G(G.NESTED_SHELLS, d), null;
            d = null;
            for (f = 0; f < b.getNumInteriorRing(); f++)
                if (d = b.getInteriorRingN(f), null === (d = this.checkShellInsideHole(a, d, c))) return null;
            this.validErr =
                new G(G.NESTED_SHELLS, d)
        },
        checkClosedRings: function(a) {
            if (this.checkClosedRing(a.getExteriorRing()), null !== this.validErr) return null;
            for (var b = 0; b < a.getNumInteriorRing(); b++)
                if (this.checkClosedRing(a.getInteriorRingN(b)), null !== this.validErr) return null
        },
        checkClosedRing: function(a) {
            if (!a.isClosed()) {
                var b = null;
                1 <= a.getNumPoints() && (b = a.getCoordinateN(0));
                this.validErr = new G(G.RING_NOT_CLOSED, b)
            }
        },
        checkShellsNotNested: function(a, b) {
            for (var c = 0; c < a.getNumGeometries(); c++)
                for (var d = a.getGeometryN(c).getExteriorRing(),
                        e = 0; e < a.getNumGeometries(); e++)
                    if (c !== e) {
                        var f = a.getGeometryN(e);
                        if (this.checkShellNotNested(d, f, b), null !== this.validErr) return null
                    }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ua
        }
    });
    Ua.findPtNotNode = function(a, b, c) {
        b = c.findEdge(b).getEdgeIntersectionList();
        for (c = 0; c < a.length; c++) {
            var d = a[c];
            if (!b.isIntersection(d)) return d
        }
        return null
    };
    Ua.isValid = function(a) {
        if (a instanceof r) return (new Ua(a)).isValid();
        if (a instanceof k) return !v.isNaN(a.x) && !v.isInfinite(a.x) && !v.isNaN(a.y) && !v.isInfinite(a.y)
    };
    g(jb.prototype, {
        isIncluded: function() {
            return this._isIncluded
        },
        getCoordinates: function() {
            if (null === this.ringPts) {
                for (var a = new Z, b = this.deList.iterator(); b.hasNext();) {
                    var c = b.next(),
                        d = c.getEdge();
                    jb.addEdge(d.getLine().getCoordinates(), c.getEdgeDirection(), a)
                }
                this.ringPts = a.toCoordinateArray()
            }
            return this.ringPts
        },
        isIncludedSet: function() {
            return this._isIncludedSet
        },
        isValid: function() {
            return this.getCoordinates(), !(3 >= this.ringPts.length) && (this.getRing(), Ua.isValid(this.ring))
        },
        build: function(a) {
            var b =
                a;
            do this.add(b), b.setRing(this), b = b.getNext(), t.isTrue(null !== b, "found null DE in ring"), t.isTrue(b === a || !b.isInRing(), "found DE already in ring"); while (b !== a)
        },
        isOuterHole: function() {
            return !!this._isHole && !this.hasShell()
        },
        getPolygon: function() {
            var a = null;
            if (null !== this.holes)
                for (var a = Array(this.holes.size()).fill(null), b = 0; b < this.holes.size(); b++) a[b] = this.holes.get(b);
            return this.factory.createPolygon(this.ring, a)
        },
        isHole: function() {
            return this._isHole
        },
        isProcessed: function() {
            return this._isProcessed
        },
        addHole: function(a) {
            a instanceof aa ? (null === this.holes && (this.holes = new l), this.holes.add(a)) : a instanceof jb && (a.setShell(this), a = a.getRing(), null === this.holes && (this.holes = new l), this.holes.add(a))
        },
        setIncluded: function(a) {
            this._isIncluded = a;
            this._isIncludedSet = !0
        },
        getOuterHole: function() {
            if (this.isHole()) return null;
            for (var a = 0; a < this.deList.size(); a++) {
                var b = this.deList.get(a).getSym().getRing();
                if (b.isOuterHole()) return b
            }
            return null
        },
        computeHole: function() {
            var a = this.getRing();
            this._isHole =
                q.isCCW(a.getCoordinates())
        },
        hasShell: function() {
            return null !== this.shell
        },
        isOuterShell: function() {
            return null !== this.getOuterHole()
        },
        getLineString: function() {
            return this.getCoordinates(), this.factory.createLineString(this.ringPts)
        },
        toString: function() {
            return ra.toLineString(new Za(this.getCoordinates()))
        },
        getShell: function() {
            return this.isHole() ? this.shell : this
        },
        add: function(a) {
            this.deList.add(a)
        },
        getRing: function() {
            if (null !== this.ring) return this.ring;
            this.getCoordinates();
            3 > this.ringPts.length &&
                U.out.println(this.ringPts);
            try {
                this.ring = this.factory.createLinearRing(this.ringPts)
            } catch (a) {
                if (!(a instanceof of )) throw a;
                U.out.println(this.ringPts)
            }
            return this.ring
        },
        updateIncluded: function() {
            if (this.isHole()) return null;
            for (var a = 0; a < this.deList.size(); a++) {
                var b = this.deList.get(a).getSym().getRing().getShell();
                if (null !== b && b.isIncludedSet()) return this.setIncluded(!b.isIncluded()), null
            }
        },
        setShell: function(a) {
            this.shell = a
        },
        setProcessed: function(a) {
            this._isProcessed = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return jb
        }
    });
    jb.findDirEdgesInRing = function(a) {
        var b = a,
            c = new l;
        do c.add(b), b = b.getNext(), t.isTrue(null !== b, "found null DE in ring"), t.isTrue(b === a || !b.isInRing(), "found DE already in ring"); while (b !== a);
        return c
    };
    jb.addEdge = function(a, b, c) {
        if (b)
            for (b = 0; b < a.length; b++) c.add(a[b], !1);
        else
            for (b = a.length - 1; 0 <= b; b--) c.add(a[b], !1)
    };
    jb.findEdgeRingContaining = function(a, b) {
        for (var c = a.getRing(), d = c.getEnvelopeInternal(), e = c.getCoordinateN(0), f = null, g = null, h = b.iterator(); h.hasNext();) {
            var k =
                h.next(),
                l = k.getRing(),
                m = l.getEnvelopeInternal();
            if (!m.equals(d) && m.contains(d)) {
                var e = z.ptNotInList(c.getCoordinates(), l.getCoordinates()),
                    n = !1;
                q.isPointInRing(e, l.getCoordinates()) && (n = !0);
                n && (null === f || g.contains(m)) && (f = k, g = f.getRing().getEnvelopeInternal())
            }
        }
        return f
    };
    g(Zf.prototype, {
        compare: function(a, b) {
            return a.getRing().getEnvelope().compareTo(b.getRing().getEnvelope())
        },
        interfaces_: function() {
            return [Wb]
        },
        getClass: function() {
            return Zf
        }
    });
    jb.EnvelopeComparator = Zf;
    x(fa, Wc);
    g(fa.prototype, {
        findEdgeRing: function(a) {
            var b =
                new jb(this.factory);
            return b.build(a), b
        },
        computeDepthParity: function() {
            if (0 === arguments.length)
                for (;;) return null;
            else 1 === arguments.length && arguments[0]
        },
        computeNextCWEdges: function() {
            for (var a = this.nodeIterator(); a.hasNext();) {
                var b = a.next();
                fa.computeNextCWEdges(b)
            }
        },
        addEdge: function(a) {
            if (a.isEmpty()) return null;
            var b = z.removeRepeatedPoints(a.getCoordinates());
            if (2 > b.length) return null;
            var c = b[b.length - 1],
                d = this.getNode(b[0]),
                e = this.getNode(c),
                c = new Od(d, e, b[1], !0),
                b = new Od(e, d, b[b.length - 2], !1);
            a = new Oe(a);
            a.setDirectedEdges(c, b);
            this.add(a)
        },
        deleteCutEdges: function() {
            this.computeNextCWEdges();
            fa.findLabeledEdgeRings(this.dirEdges);
            for (var a = new l, b = this.dirEdges.iterator(); b.hasNext();) {
                var c = b.next();
                if (!c.isMarked()) {
                    var d = c.getSym();
                    c.getLabel() === d.getLabel() && (c.setMarked(!0), d.setMarked(!0), c = c.getEdge(), a.add(c.getLine()))
                }
            }
            return a
        },
        getEdgeRings: function() {
            this.computeNextCWEdges();
            fa.label(this.dirEdges, -1);
            var a = fa.findLabeledEdgeRings(this.dirEdges);
            this.convertMaximalToMinimalEdgeRings(a);
            for (var a = new l, b = this.dirEdges.iterator(); b.hasNext();) {
                var c = b.next();
                c.isMarked() || c.isInRing() || (c = this.findEdgeRing(c), a.add(c))
            }
            return a
        },
        getNode: function(a) {
            var b = this.findNode(a);
            return null === b && (b = new Kb(a), this.add(b)), b
        },
        convertMaximalToMinimalEdgeRings: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next(),
                    c = b.getLabel(),
                    b = fa.findIntersectionNodes(b, c);
                if (null !== b)
                    for (b = b.iterator(); b.hasNext();) {
                        var d = b.next();
                        fa.computeNextCCWEdges(d, c)
                    }
            }
        },
        deleteDangles: function() {
            for (var a = this.findNodesOfDegree(1),
                    b = new ma, c = new xa, a = a.iterator(); a.hasNext();) c.push(a.next());
            for (; !c.isEmpty();)
                for (a = c.pop(), fa.deleteAllEdges(a), a = a.getOutEdges().getEdges().iterator(); a.hasNext();) {
                    var d = a.next();
                    d.setMarked(!0);
                    var e = d.getSym();
                    null !== e && e.setMarked(!0);
                    e = d.getEdge();
                    b.add(e.getLine());
                    d = d.getToNode();
                    1 === fa.getDegreeNonDeleted(d) && c.push(d)
                }
            return b
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return fa
        }
    });
    fa.findLabeledEdgeRings = function(a) {
        var b = new l,
            c = 1;
        for (a = a.iterator(); a.hasNext();) {
            var d =
                a.next();
            d.isMarked() || 0 <= d.getLabel() || (b.add(d), d = jb.findDirEdgesInRing(d), fa.label(d, c), c++)
        }
        return b
    };
    fa.getDegreeNonDeleted = function(a) {
        var b = 0;
        for (a = a.getOutEdges().getEdges().iterator(); a.hasNext();) a.next().isMarked() || b++;
        return b
    };
    fa.deleteAllEdges = function(a) {
        for (a = a.getOutEdges().getEdges().iterator(); a.hasNext();) {
            var b = a.next();
            b.setMarked(!0);
            b = b.getSym();
            null !== b && b.setMarked(!0)
        }
    };
    fa.label = function(a, b) {
        for (var c = a.iterator(); c.hasNext();) c.next().setLabel(b)
    };
    fa.computeNextCWEdges =
        function(a) {
            var b = null,
                c = null;
            for (a = a.getOutEdges().getEdges().iterator(); a.hasNext();) {
                var d = a.next();
                if (!d.isMarked()) {
                    if (null === b && (b = d), null !== c) c = c.getSym(), c.setNext(d);
                    c = d
                }
            }
            null !== c && (c = c.getSym(), c.setNext(b))
        };
    fa.computeNextCCWEdges = function(a, b) {
        for (var c = null, d = null, e = a.getOutEdges().getEdges(), f = e.size() - 1; 0 <= f; f--) {
            var g = e.get(f),
                h = g.getSym(),
                k = null;
            g.getLabel() === b && (k = g);
            g = null;
            h.getLabel() === b && (g = h);
            null === k && null === g || (null !== g && (d = g), null !== k && (null !== d && (d.setNext(k), d = null), null ===
                c && (c = k)))
        }
        null !== d && (t.isTrue(null !== c), d.setNext(c))
    };
    fa.getDegree = function(a, b) {
        for (var c = 0, d = a.getOutEdges().getEdges().iterator(); d.hasNext();) d.next().getLabel() === b && c++;
        return c
    };
    fa.findIntersectionNodes = function(a, b) {
        var c = a,
            d = null;
        do {
            var e = c.getFromNode();
            1 < fa.getDegree(e, b) && (null === d && (d = new l), d.add(e));
            c = c.getNext();
            t.isTrue(null !== c, "found null DE in ring");
            t.isTrue(c === a || !c.isInRing(), "found DE already in ring")
        } while (c !== a);
        return d
    };
    g(Na.prototype, {
        getGeometry: function() {
            return null ===
                this.geomFactory && (this.geomFactory = new E), this.polygonize(), this.extractOnlyPolygonal ? this.geomFactory.buildGeometry(this.polyList) : this.geomFactory.createGeometryCollection(E.toGeometryArray(this.polyList))
        },
        getInvalidRingLines: function() {
            return this.polygonize(), this.invalidRingLines
        },
        findValidRings: function(a, b, c) {
            for (a = a.iterator(); a.hasNext();) {
                var d = a.next();
                d.isValid() ? b.add(d) : c.add(d.getLineString())
            }
        },
        polygonize: function() {
            if (null !== this.polyList || (this.polyList = new l, null === this.graph)) return null;
            this.dangles = this.graph.deleteDangles();
            this.cutEdges = this.graph.deleteCutEdges();
            var a = this.graph.getEdgeRings(),
                b = new l;
            this.invalidRingLines = new l;
            this.isCheckingRingsValid ? this.findValidRings(a, b, this.invalidRingLines) : b = a;
            this.findShellsAndHoles(b);
            Na.assignHolesToShells(this.holeList, this.shellList);
            vb.sort(this.shellList, new jb.EnvelopeComparator);
            a = !0;
            this.extractOnlyPolygonal && (Na.findDisjointShells(this.shellList), a = !1);
            this.polyList = Na.extractPolygons(this.shellList, a)
        },
        getDangles: function() {
            return this.polygonize(),
                this.dangles
        },
        getCutEdges: function() {
            return this.polygonize(), this.cutEdges
        },
        getPolygons: function() {
            return this.polygonize(), this.polyList
        },
        add: function(a) {
            if (u(a, T))
                for (a = a.iterator(); a.hasNext();) {
                    var b = a.next();
                    this.add(b)
                } else a instanceof C ? (this.geomFactory = a.getFactory(), null === this.graph && (this.graph = new fa(this.geomFactory)), this.graph.addEdge(a)) : a instanceof r && a.apply(this.lineStringAdder)
        },
        setCheckRingsValid: function(a) {
            this.isCheckingRingsValid = a
        },
        findShellsAndHoles: function(a) {
            this.holeList =
                new l;
            this.shellList = new l;
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                b.computeHole();
                b.isHole() ? this.holeList.add(b) : this.shellList.add(b)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Na
        }
    });
    Na.findOuterShells = function(a) {
        for (a = a.iterator(); a.hasNext();) {
            var b = a.next(),
                c = b.getOuterHole();
            null === c || c.isProcessed() || (b.setIncluded(!0), c.setProcessed(!0))
        }
    };
    Na.extractPolygons = function(a, b) {
        for (var c = new l, d = a.iterator(); d.hasNext();) {
            var e = d.next();
            (b || e.isIncluded()) && c.add(e.getPolygon())
        }
        return c
    };
    Na.assignHolesToShells = function(a, b) {
        for (var c = a.iterator(); c.hasNext();) {
            var d = c.next();
            Na.assignHoleToShell(d, b)
        }
    };
    Na.assignHoleToShell = function(a, b) {
        var c = jb.findEdgeRingContaining(a, b);
        null !== c && c.addHole(a)
    };
    Na.findDisjointShells = function(a) {
        Na.findOuterShells(a);
        var b = null;
        do
            for (var b = !1, c = a.iterator(); c.hasNext();) {
                var d = c.next();
                d.isIncludedSet() || (d.updateIncluded(), d.isIncludedSet() || (b = !0))
            }
        while (b)
    };
    g(Te.prototype, {
        filter: function(a) {
            a instanceof C && this.p.add(a)
        },
        interfaces_: function() {
            return [eb]
        },
        getClass: function() {
            return Te
        }
    });
    Na.LineStringAdder = Te;
    var Sg = Object.freeze({
        Polygonizer: Na
    });
    g(Ue.prototype, {
        insertEdgeEnds: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                this.nodes.add(b)
            }
        },
        computeProperIntersectionIM: function(a, b) {
            var c = this.arg[0].getGeometry().getDimension(),
                d = this.arg[1].getGeometry().getDimension(),
                e = a.hasProperIntersection(),
                f = a.hasProperInteriorIntersection();
            2 === c && 2 === d ? e && b.setAtLeast("212101212") : 2 === c && 1 === d ? (e && b.setAtLeast("FFF0FFFF2"), f && b.setAtLeast("1FFFFF1FF")) :
                1 === c && 2 === d ? (e && b.setAtLeast("F0FFFFFF2"), f && b.setAtLeast("1F1FFFFFF")) : 1 === c && 1 === d && f && b.setAtLeast("0FFFFFFFF")
        },
        labelIsolatedEdges: function(a, b) {
            for (var c = this.arg[a].getEdgeIterator(); c.hasNext();) {
                var d = c.next();
                d.isIsolated() && (this.labelIsolatedEdge(d, b, this.arg[b].getGeometry()), this.isolatedEdges.add(d))
            }
        },
        labelIsolatedEdge: function(a, b, c) {
            0 < c.getDimension() ? (c = this.ptLocator.locate(a.getCoordinate(), c), a.getLabel().setAllLocations(b, c)) : a.getLabel().setAllLocations(b, h.EXTERIOR)
        },
        computeIM: function() {
            var a =
                new N;
            if (a.set(h.EXTERIOR, h.EXTERIOR, 2), !this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal())) return this.computeDisjointIM(a), a;
            this.arg[0].computeSelfNodes(this.li, !1);
            this.arg[1].computeSelfNodes(this.li, !1);
            var b = this.arg[0].computeEdgeIntersections(this.arg[1], this.li, !1);
            this.computeIntersectionNodes(0);
            this.computeIntersectionNodes(1);
            this.copyNodesAndLabels(0);
            this.copyNodesAndLabels(1);
            this.labelIsolatedNodes();
            this.computeProperIntersectionIM(b,
                a);
            var b = new Pe,
                c = b.computeEdgeEnds(this.arg[0].getEdgeIterator());
            this.insertEdgeEnds(c);
            b = b.computeEdgeEnds(this.arg[1].getEdgeIterator());
            return this.insertEdgeEnds(b), this.labelNodeEdges(), this.labelIsolatedEdges(0, 1), this.labelIsolatedEdges(1, 0), this.updateIM(a), a
        },
        labelNodeEdges: function() {
            for (var a = this.nodes.iterator(); a.hasNext();) a.next().getEdges().computeLabelling(this.arg)
        },
        copyNodesAndLabels: function(a) {
            for (var b = this.arg[a].getNodeIterator(); b.hasNext();) {
                var c = b.next();
                this.nodes.addNode(c.getCoordinate()).setLabel(a,
                    c.getLabel().getLocation(a))
            }
        },
        labelIntersectionNodes: function(a) {
            for (var b = this.arg[a].getEdgeIterator(); b.hasNext();)
                for (var c = b.next(), d = c.getLabel().getLocation(a), c = c.getEdgeIntersectionList().iterator(); c.hasNext();) {
                    var e = c.next(),
                        e = this.nodes.find(e.coord);
                    e.getLabel().isNull(a) && (d === h.BOUNDARY ? e.setLabelBoundary(a) : e.setLabel(a, h.INTERIOR))
                }
        },
        labelIsolatedNode: function(a, b) {
            var c = this.ptLocator.locate(a.getCoordinate(), this.arg[b].getGeometry());
            a.getLabel().setAllLocations(b, c)
        },
        computeIntersectionNodes: function(a) {
            for (var b =
                    this.arg[a].getEdgeIterator(); b.hasNext();)
                for (var c = b.next(), d = c.getLabel().getLocation(a), c = c.getEdgeIntersectionList().iterator(); c.hasNext();) {
                    var e = c.next(),
                        e = this.nodes.addNode(e.coord);
                    d === h.BOUNDARY ? e.setLabelBoundary(a) : e.getLabel().isNull(a) && e.setLabel(a, h.INTERIOR)
                }
        },
        labelIsolatedNodes: function() {
            for (var a = this.nodes.iterator(); a.hasNext();) {
                var b = a.next(),
                    c = b.getLabel();
                t.isTrue(0 < c.getGeometryCount(), "node with empty label found");
                b.isIsolated() && (c.isNull(0) ? this.labelIsolatedNode(b,
                    0) : this.labelIsolatedNode(b, 1))
            }
        },
        updateIM: function(a) {
            for (var b = this.isolatedEdges.iterator(); b.hasNext();) b.next().updateIM(a);
            for (b = this.nodes.iterator(); b.hasNext();) {
                var c = b.next();
                c.updateIM(a);
                c.updateIMFromEdges(a)
            }
        },
        computeDisjointIM: function(a) {
            var b = this.arg[0].getGeometry();
            b.isEmpty() || (a.set(h.INTERIOR, h.EXTERIOR, b.getDimension()), a.set(h.BOUNDARY, h.EXTERIOR, b.getBoundaryDimension()));
            b = this.arg[1].getGeometry();
            b.isEmpty() || (a.set(h.EXTERIOR, h.INTERIOR, b.getDimension()), a.set(h.EXTERIOR,
                h.BOUNDARY, b.getBoundaryDimension()))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ue
        }
    });
    g(Sd.prototype, {
        isContainedInBoundary: function(a) {
            if (a instanceof O) return !1;
            if (a instanceof W) return this.isPointContainedInBoundary(a);
            if (a instanceof C) return this.isLineStringContainedInBoundary(a);
            for (var b = 0; b < a.getNumGeometries(); b++) {
                var c = a.getGeometryN(b);
                if (!this.isContainedInBoundary(c)) return !1
            }
            return !0
        },
        isLineSegmentContainedInBoundary: function(a, b) {
            if (a.equals(b)) return this.isPointContainedInBoundary(a);
            if (a.x === b.x) {
                if (a.x === this.rectEnv.getMinX() || a.x === this.rectEnv.getMaxX()) return !0
            } else if (a.y === b.y && (a.y === this.rectEnv.getMinY() || a.y === this.rectEnv.getMaxY())) return !0;
            return !1
        },
        isLineStringContainedInBoundary: function(a) {
            a = a.getCoordinateSequence();
            for (var b = new k, c = new k, d = 0; d < a.size() - 1; d++)
                if (a.getCoordinate(d, b), a.getCoordinate(d + 1, c), !this.isLineSegmentContainedInBoundary(b, c)) return !1;
            return !0
        },
        isPointContainedInBoundary: function(a) {
            if (a instanceof W) return this.isPointContainedInBoundary(a.getCoordinate());
            if (a instanceof k) return a.x === this.rectEnv.getMinX() || a.x === this.rectEnv.getMaxX() || a.y === this.rectEnv.getMinY() || a.y === this.rectEnv.getMaxY()
        },
        contains: function(a) {
            return !!this.rectEnv.contains(a.getEnvelopeInternal()) && !this.isContainedInBoundary(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Sd
        }
    });
    Sd.contains = function(a, b) {
        return (new Sd(a)).contains(b)
    };
    g($f.prototype, {
        intersects: function(a, b) {
            var c = new y(a, b);
            if (!this.rectEnv.intersects(c)) return !1;
            if (this.rectEnv.intersects(a) ||
                this.rectEnv.intersects(b)) return !0;
            0 < a.compareTo(b) && (b = a = b);
            c = !1;
            return b.y > a.y && (c = !0), c ? this.li.computeIntersection(a, b, this.diagDown0, this.diagDown1) : this.li.computeIntersection(a, b, this.diagUp0, this.diagUp1), !!this.li.hasIntersection()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return $f
        }
    });
    g(jc.prototype, {
        applyTo: function(a) {
            for (var b = 0; b < a.getNumGeometries() && !this._isDone; b++) {
                var c = a.getGeometryN(b);
                if (c instanceof F) this.applyTo(c);
                else if (this.visit(c), this.isDone()) return this._isDone = !0, null
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return jc
        }
    });
    g(Xc.prototype, {
        intersects: function(a) {
            if (!this.rectEnv.intersects(a.getEnvelopeInternal())) return !1;
            var b = new Ve(this.rectEnv);
            if (b.applyTo(a), b.intersects()) return !0;
            b = new We(this.rectangle);
            if (b.applyTo(a), b.containsPoint()) return !0;
            b = new Xe(this.rectangle);
            return b.applyTo(a), !!b.intersects()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Xc
        }
    });
    Xc.intersects = function(a, b) {
        return (new Xc(a)).intersects(b)
    };
    x(Ve, jc);
    g(Ve.prototype, {
        isDone: function() {
            return !0 === this._intersects
        },
        visit: function(a) {
            a = a.getEnvelopeInternal();
            return this.rectEnv.intersects(a) ? this.rectEnv.contains(a) ? (this._intersects = !0, null) : a.getMinX() >= this.rectEnv.getMinX() && a.getMaxX() <= this.rectEnv.getMaxX() ? (this._intersects = !0, null) : a.getMinY() >= this.rectEnv.getMinY() && a.getMaxY() <= this.rectEnv.getMaxY() ? (this._intersects = !0, null) : void 0 : null
        },
        intersects: function() {
            return this._intersects
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ve
        }
    });
    x(We, jc);
    g(We.prototype, {
        isDone: function() {
            return !0 === this._containsPoint
        },
        visit: function(a) {
            if (!(a instanceof O)) return null;
            var b = a.getEnvelopeInternal();
            if (!this.rectEnv.intersects(b)) return null;
            for (var c = new k, d = 0; 4 > d; d++)
                if (this.rectSeq.getCoordinate(d, c), b.contains(c) && Sa.containsPointInPolygon(c, a)) return this._containsPoint = !0, null
        },
        containsPoint: function() {
            return this._containsPoint
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return We
        }
    });
    x(Xe, jc);
    g(Xe.prototype, {
        intersects: function() {
            return this.hasIntersection
        },
        isDone: function() {
            return !0 === this.hasIntersection
        },
        visit: function(a) {
            var b = a.getEnvelopeInternal();
            if (!this.rectEnv.intersects(b)) return null;
            a = sa.getLines(a);
            this.checkIntersectionWithLineStrings(a)
        },
        checkIntersectionWithLineStrings: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                if (this.checkIntersectionWithSegments(b), this.hasIntersection) return null
            }
        },
        checkIntersectionWithSegments: function(a) {
            a = a.getCoordinateSequence();
            for (var b = 1; b < a.size(); b++)
                if (a.getCoordinate(b - 1, this.p0), a.getCoordinate(b,
                        this.p1), this.rectIntersector.intersects(this.p0, this.p1)) return this.hasIntersection = !0, null
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Xe
        }
    });
    x(J, cc);
    g(J.prototype, {
        getIntersectionMatrix: function() {
            return this._relate.computeIM()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return J
        }
    });
    J.covers = function(a, b) {
        return !!a.getEnvelopeInternal().covers(b.getEnvelopeInternal()) && (!!a.isRectangle() || J.relate(a, b).isCovers())
    };
    J.intersects = function(a, b) {
        return !!a.getEnvelopeInternal().intersects(b.getEnvelopeInternal()) &&
            (a.isRectangle() ? Xc.intersects(a, b) : b.isRectangle() ? Xc.intersects(b, a) : J.relate(a, b).isIntersects())
    };
    J.touches = function(a, b) {
        return !!a.getEnvelopeInternal().intersects(b.getEnvelopeInternal()) && J.relate(a, b).isTouches(a.getDimension(), b.getDimension())
    };
    J.within = function(a, b) {
        return b.contains(a)
    };
    J.coveredBy = function(a, b) {
        return J.covers(b, a)
    };
    J.relate = function() {
        if (2 === arguments.length) {
            var a = new J(arguments[0], arguments[1]);
            return a = a.getIntersectionMatrix()
        }
        if (3 === arguments.length) {
            if ("string" ==
                typeof arguments[2] && arguments[0] instanceof r && arguments[1] instanceof r) return a = arguments[2], J.relateWithCheck(arguments[0], arguments[1]).matches(a);
            if (u(arguments[2], ha) && arguments[0] instanceof r && arguments[1] instanceof r) return a = new J(arguments[0], arguments[1], arguments[2]), a = a.getIntersectionMatrix()
        }
    };
    J.overlaps = function(a, b) {
        return !!a.getEnvelopeInternal().intersects(b.getEnvelopeInternal()) && J.relate(a, b).isOverlaps(a.getDimension(), b.getDimension())
    };
    J.disjoint = function(a, b) {
        return !a.intersects(b)
    };
    J.relateWithCheck = function(a, b) {
        return a.checkNotGeometryCollection(a), a.checkNotGeometryCollection(b), J.relate(a, b)
    };
    J.crosses = function(a, b) {
        return !!a.getEnvelopeInternal().intersects(b.getEnvelopeInternal()) && J.relate(a, b).isCrosses(a.getDimension(), b.getDimension())
    };
    J.contains = function(a, b) {
        return !!a.getEnvelopeInternal().contains(b.getEnvelopeInternal()) && (a.isRectangle() ? Sd.contains(a, b) : J.relate(a, b).isContains())
    };
    var Tg = Object.freeze({
        RelateOp: J
    });
    g(Va.prototype, {
        extractElements: function(a,
            b) {
            if (null === a) return null;
            for (var c = 0; c < a.getNumGeometries(); c++) {
                var d = a.getGeometryN(c);
                this.skipEmpty && d.isEmpty() || b.add(d)
            }
        },
        combine: function() {
            for (var a = new l, b = this.inputGeoms.iterator(); b.hasNext();) {
                var c = b.next();
                this.extractElements(c, a)
            }
            return 0 === a.size() ? null !== this.geomFactory ? this.geomFactory.createGeometryCollection(null) : null : this.geomFactory.buildGeometry(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Va
        }
    });
    Va.combine = function() {
        if (1 === arguments.length) {
            var a =
                new Va(arguments[0]);
            return a.combine()
        }
        if (2 === arguments.length) return a = new Va(Va.createList(arguments[0], arguments[1])), a.combine();
        if (3 === arguments.length) return a = new Va(Va.createList(arguments[0], arguments[1], arguments[2])), a.combine()
    };
    Va.extractFactory = function(a) {
        return a.isEmpty() ? null : a.iterator().next().getFactory()
    };
    Va.createList = function() {
        if (2 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = new l;
            return c.add(a), c.add(b), c
        }
        if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                d = arguments[2],
                c = new l;
            return c.add(a), c.add(b), c.add(d), c
        }
    };
    g(Td.prototype, {
        union: function() {
            for (var a = new uc, b = new va, c = 0; c < this.pointGeom.getNumGeometries(); c++) {
                var d = this.pointGeom.getGeometryN(c).getCoordinate();
                a.locate(d, this.otherGeom) === h.EXTERIOR && b.add(d)
            }
            if (0 === b.size()) return this.otherGeom;
            a = null;
            b = z.toCoordinateArray(b);
            return a = 1 === b.length ? this.geomFact.createPoint(b[0]) : this.geomFact.createMultiPointFromCoords(b), Va.combine(a, this.otherGeom)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Td
        }
    });
    Td.union = function(a, b) {
        return (new Td(a, b)).union()
    };
    g(kc.prototype, {
        filter: function(a) {
            -1 !== this.sortIndex && a.getSortIndex() !== this.sortIndex || this.comps.add(a)
        },
        interfaces_: function() {
            return [Ab]
        },
        getClass: function() {
            return kc
        }
    });
    kc.extract = function() {
        if (2 === arguments.length) return kc.extract(arguments[0], arguments[1], new l);
        if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2];
            return a.getSortIndex() === b ? c.add(a) : a instanceof F && a.apply(new kc(b, c)), c
        }
    };
    g(cb.prototype, {
        reduceToGeometries: function(a) {
            var b =
                new l;
            for (a = a.iterator(); a.hasNext();) {
                var c = a.next(),
                    d = null;
                u(c, ga) ? d = this.unionTree(c) : c instanceof r && (d = c);
                b.add(d)
            }
            return b
        },
        extractByEnvelope: function(a, b, c) {
            for (var d = new l, e = 0; e < b.getNumGeometries(); e++) {
                var f = b.getGeometryN(e);
                f.getEnvelopeInternal().intersects(a) ? d.add(f) : c.add(f)
            }
            return this.geomFactory.buildGeometry(d)
        },
        unionOptimized: function(a, b) {
            var c = a.getEnvelopeInternal(),
                d = b.getEnvelopeInternal();
            if (!c.intersects(d)) return Va.combine(a, b);
            if (1 >= a.getNumGeometries() && 1 >= b.getNumGeometries()) return this.unionActual(a,
                b);
            c = c.intersection(d);
            return this.unionUsingEnvelopeIntersection(a, b, c)
        },
        union: function() {
            if (null === this.inputPolys) throw new IllegalStateException("union() method cannot be called twice");
            if (this.inputPolys.isEmpty()) return null;
            this.geomFactory = this.inputPolys.iterator().next().getFactory();
            for (var a = new X(cb.STRTREE_NODE_CAPACITY), b = this.inputPolys.iterator(); b.hasNext();) {
                var c = b.next();
                a.insert(c.getEnvelopeInternal(), c)
            }
            this.inputPolys = null;
            a = a.itemsTree();
            return this.unionTree(a)
        },
        binaryUnion: function() {
            if (1 ===
                arguments.length) {
                var a = arguments[0];
                return this.binaryUnion(a, 0, a.size())
            }
            if (3 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = arguments[2];
                if (1 >= c - b) return b = cb.getGeometry(a, b), this.unionSafe(b, null);
                if (2 == c - b) return this.unionSafe(cb.getGeometry(a, b), cb.getGeometry(a, b + 1));
                var d = Math.trunc((c + b) / 2),
                    b = this.binaryUnion(a, b, d),
                    a = this.binaryUnion(a, d, c);
                return this.unionSafe(b, a)
            }
        },
        repeatedUnion: function(a) {
            var b = null;
            for (a = a.iterator(); a.hasNext();) var c = a.next(),
                b = null === b ? c.copy() : b.union(c);
            return b
        },
        unionSafe: function(a, b) {
            return null === a && null === b ? null : null === a ? b.copy() : null === b ? a.copy() : this.unionOptimized(a, b)
        },
        unionActual: function(a, b) {
            return cb.restrictToPolygons(a.union(b))
        },
        unionTree: function(a) {
            a = this.reduceToGeometries(a);
            return this.binaryUnion(a)
        },
        unionUsingEnvelopeIntersection: function(a, b, c) {
            var d = new l;
            a = this.extractByEnvelope(c, a, d);
            b = this.extractByEnvelope(c, b, d);
            b = this.unionActual(a, b);
            return d.add(b), Va.combine(d)
        },
        bufferUnion: function() {
            if (1 === arguments.length) {
                var a =
                    arguments[0],
                    b = a.get(0).getFactory(),
                    b = b.buildGeometry(a);
                return b = b.buffer(0)
            }
            if (2 === arguments.length) {
                var a = arguments[0],
                    c = arguments[1],
                    b = a.getFactory(),
                    b = b.createGeometryCollection([a, c]);
                return b = b.buffer(0)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return cb
        }
    });
    cb.restrictToPolygons = function(a) {
        if (u(a, Bb)) return a;
        var b = Cc.getPolygons(a);
        return 1 === b.size() ? b.get(0) : a.getFactory().createMultiPolygon(E.toPolygonArray(b))
    };
    cb.getGeometry = function(a, b) {
        return b >= a.size() ? null : a.get(b)
    };
    cb.union = function(a) {
        return (new cb(a)).union()
    };
    cb.STRTREE_NODE_CAPACITY = 4;
    g(lc.prototype, {
        unionNoOpt: function(a) {
            var b = this.geomFact.createPoint();
            return ja.overlayOp(a, b, w.UNION)
        },
        unionWithNull: function(a, b) {
            return null === a && null === b ? null : null === b ? a : null === a ? b : a.union(b)
        },
        extract: function(a) {
            if (u(a, T))
                for (a = a.iterator(); a.hasNext();) {
                    var b = a.next();
                    this.extract(b)
                } else a instanceof r && (null === this.geomFact && (this.geomFact = a.getFactory()), kc.extract(a, r.SORTINDEX_POLYGON, this.polygons), kc.extract(a,
                    r.SORTINDEX_LINESTRING, this.lines), kc.extract(a, r.SORTINDEX_POINT, this.points))
        },
        union: function() {
            if (null === this.geomFact) return null;
            var a = null;
            0 < this.points.size() && (a = this.geomFact.buildGeometry(this.points), a = this.unionNoOpt(a));
            var b = null;
            0 < this.lines.size() && (b = this.geomFact.buildGeometry(this.lines), b = this.unionNoOpt(b));
            var c = null;
            0 < this.polygons.size() && (c = cb.union(this.polygons));
            b = this.unionWithNull(b, c);
            c = null;
            return c = null === a ? b : null === b ? a : Td.union(a, b), null === c ? this.geomFact.createGeometryCollection() :
                c
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return lc
        }
    });
    lc.union = function() {
        if (1 === arguments.length) {
            if (u(arguments[0], T)) {
                var a = new lc(arguments[0]);
                return a.union()
            }
            if (arguments[0] instanceof r) return a = new lc(arguments[0]), a.union()
        } else if (2 === arguments.length) return a = new lc(arguments[0], arguments[1]), a.union()
    };
    var Ug = Object.freeze({
            UnaryUnionOp: lc
        }),
        Vg = Object.freeze({
            IsValidOp: Ua,
            ConsistentAreaTester: Se
        }),
        Wg = Object.freeze({
            BoundaryOp: Ob,
            IsSimpleOp: Gd,
            buffer: Og,
            distance: Pg,
            linemerge: Qg,
            overlay: Rg,
            polygonize: Sg,
            relate: Tg,
            union: Ug,
            valid: Vg
        });
    x(Ye, Qa.CoordinateOperation);
    g(Ye.prototype, {
        editCoordinates: function(a, b) {
            if (0 === a.length) return null;
            for (var c = Array(a.length).fill(null), d = 0; d < a.length; d++) {
                var e = new k(a[d]);
                this.targetPM.makePrecise(e);
                c[d] = e
            }
            d = (new Z(c, !1)).toCoordinateArray();
            e = 0;
            b instanceof C && (e = 2);
            b instanceof aa && (e = 4);
            return this.removeCollapsed && (c = null), d.length < e ? c : d
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ye
        }
    });
    g(Ec.prototype, {
        fixPolygonalTopology: function(a) {
            var b =
                a;
            this.changePrecisionModel || (b = this.changePM(a, this.targetPM));
            var c = b = b.buffer(0);
            return this.changePrecisionModel || (c = this.changePM(b, a.getPrecisionModel())), c
        },
        reducePointwise: function(a) {
            var b = null,
                b = this.changePrecisionModel ? new Qa(this.createFactory(a.getFactory(), this.targetPM)) : new Qa,
                c = this.removeCollapsed;
            return 2 <= a.getDimension() && (c = !0), b.edit(a, new Ye(this.targetPM, c))
        },
        changePM: function(a, b) {
            return this.createEditor(a.getFactory(), b).edit(a, new Qa.NoOpGeometryOperation)
        },
        setRemoveCollapsedComponents: function(a) {
            this.removeCollapsed =
                a
        },
        createFactory: function(a, b) {
            return new E(b, a.getSRID(), a.getCoordinateSequenceFactory())
        },
        setChangePrecisionModel: function(a) {
            this.changePrecisionModel = a
        },
        reduce: function(a) {
            a = this.reducePointwise(a);
            return this.isPointwise ? a : u(a, Bb) ? a.isValid() ? a : this.fixPolygonalTopology(a) : a
        },
        setPointwise: function(a) {
            this.isPointwise = a
        },
        createEditor: function(a, b) {
            return a.getPrecisionModel() === b ? new Qa : new Qa(this.createFactory(a, b))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ec
        }
    });
    Ec.reduce =
        function(a, b) {
            return (new Ec(b)).reduce(a)
        };
    Ec.reducePointwise = function(a, b) {
        var c = new Ec(b);
        return c.setPointwise(!0), c.reduce(a)
    };
    var Xg = Object.freeze({
        GeometryPrecisionReducer: Ec
    });
    g(Ud.prototype, {
        simplifySection: function(a, b) {
            if (a + 1 === b) return null;
            this.seg.p0 = this.pts[a];
            this.seg.p1 = this.pts[b];
            for (var c = -1, d = a, e = a + 1; e < b; e++) {
                var f = this.seg.distance(this.pts[e]);
                f > c && (c = f, d = e)
            }
            if (c <= this.distanceTolerance)
                for (e = a + 1; e < b; e++) this.usePt[e] = !1;
            else this.simplifySection(a, d), this.simplifySection(d,
                b)
        },
        setDistanceTolerance: function(a) {
            this.distanceTolerance = a
        },
        simplify: function() {
            this.usePt = Array(this.pts.length).fill(null);
            for (var a = 0; a < this.pts.length; a++) this.usePt[a] = !0;
            this.simplifySection(0, this.pts.length - 1);
            for (var b = new Z, a = 0; a < this.pts.length; a++) this.usePt[a] && b.add(new k(this.pts[a]));
            return b.toCoordinateArray()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ud
        }
    });
    Ud.simplify = function(a, b) {
        var c = new Ud(a);
        return c.setDistanceTolerance(b), c.simplify()
    };
    g(Yc.prototype, {
        setEnsureValid: function(a) {
            this.isEnsureValidTopology = a
        },
        getResultGeometry: function() {
            return this.inputGeom.isEmpty() ? this.inputGeom.copy() : (new Vd(this.isEnsureValidTopology, this.distanceTolerance)).transform(this.inputGeom)
        },
        setDistanceTolerance: function(a) {
            if (0 > a) throw new K("Tolerance must be non-negative");
            this.distanceTolerance = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Yc
        }
    });
    Yc.simplify = function(a, b) {
        var c = new Yc(a);
        return c.setDistanceTolerance(b), c.getResultGeometry()
    };
    x(Vd, Ca);
    g(Vd.prototype, {
        transformPolygon: function(a, b) {
            if (a.isEmpty()) return null;
            var c = Ca.prototype.transformPolygon.call(this, a, b);
            return b instanceof na ? c : this.createValidArea(c)
        },
        createValidArea: function(a) {
            return this.isEnsureValidTopology ? a.buffer(0) : a
        },
        transformCoordinates: function(a, b) {
            var c = a.toCoordinateArray(),
                d = null;
            return d = 0 === c.length ? [].fill(null) : Ud.simplify(c, this.distanceTolerance), this.factory.getCoordinateSequenceFactory().create(d)
        },
        transformMultiPolygon: function(a, b) {
            var c =
                Ca.prototype.transformMultiPolygon.call(this, a, b);
            return this.createValidArea(c)
        },
        transformLinearRing: function(a, b) {
            var c = b instanceof O,
                d = Ca.prototype.transformLinearRing.call(this, a, b);
            return !c || d instanceof aa ? d : null
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Vd
        }
    });
    Yc.DPTransformer = Vd;
    x(Wd, A);
    g(Wd.prototype, {
        getIndex: function() {
            return this.index
        },
        getParent: function() {
            return this.parent
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Wd
        }
    });
    g(Ub.prototype, {
        addToResult: function(a) {
            this.resultSegs.add(a)
        },
        asLineString: function() {
            return this.parentLine.getFactory().createLineString(Ub.extractCoordinates(this.resultSegs))
        },
        getResultSize: function() {
            var a = this.resultSegs.size();
            return 0 === a ? 0 : a + 1
        },
        getParent: function() {
            return this.parentLine
        },
        getSegment: function(a) {
            return this.segs[a]
        },
        getParentCoordinates: function() {
            return this.parentLine.getCoordinates()
        },
        getMinimumSize: function() {
            return this.minimumSize
        },
        asLinearRing: function() {
            return this.parentLine.getFactory().createLinearRing(Ub.extractCoordinates(this.resultSegs))
        },
        getSegments: function() {
            return this.segs
        },
        init: function() {
            var a = this.parentLine.getCoordinates();
            this.segs = Array(a.length - 1).fill(null);
            for (var b = 0; b < a.length - 1; b++) {
                var c = new Wd(a[b], a[b + 1], this.parentLine, b);
                this.segs[b] = c
            }
        },
        getResultCoordinates: function() {
            return Ub.extractCoordinates(this.resultSegs)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Ub
        }
    });
    Ub.extractCoordinates = function(a) {
        for (var b = Array(a.size() + 1).fill(null), c = null, d = 0; d < a.size(); d++) c = a.get(d), b[d] = c.p0;
        return b[b.length -
            1] = c.p1, b
    };
    g(Zc.prototype, {
        remove: function(a) {
            this.index.remove(new y(a.p0, a.p1), a)
        },
        add: function(a) {
            if (a instanceof Ub) {
                a = a.getSegments();
                for (var b = 0; b < a.length; b++) this.add(a[b])
            } else a instanceof A && this.index.insert(new y(a.p0, a.p1), a)
        },
        query: function(a) {
            var b = new y(a.p0, a.p1);
            a = new ag(a);
            return this.index.query(b, a), a.getItems()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Zc
        }
    });
    g(ag.prototype, {
        visitItem: function(a) {
            y.intersects(a.p0, a.p1, this.querySeg.p0, this.querySeg.p1) && this.items.add(a)
        },
        getItems: function() {
            return this.items
        },
        interfaces_: function() {
            return [Zb]
        },
        getClass: function() {
            return ag
        }
    });
    g(Xd.prototype, {
        flatten: function(a, b) {
            var c = new A(this.linePts[a], this.linePts[b]);
            return this.remove(this.line, a, b), this.outputIndex.add(c), c
        },
        hasBadIntersection: function(a, b, c) {
            return !!this.hasBadOutputIntersection(c) || !!this.hasBadInputIntersection(a, b, c)
        },
        setDistanceTolerance: function(a) {
            this.distanceTolerance = a
        },
        simplifySection: function(a, b, c) {
            c += 1;
            var d = Array(2).fill(null);
            if (a + 1 === b) return a =
                this.line.getSegment(a), this.line.addToResult(a), null;
            var e = !0;
            this.line.getResultSize() < this.line.getMinimumSize() && c + 1 < this.line.getMinimumSize() && (e = !1);
            var f = Array(1).fill(null),
                g = this.findFurthestPoint(this.linePts, a, b, f);
            f[0] > this.distanceTolerance && (e = !1);
            f = new A;
            if (f.p0 = this.linePts[a], f.p1 = this.linePts[b], d[0] = a, d[1] = b, this.hasBadIntersection(this.line, d, f) && (e = !1), e) return a = this.flatten(a, b), this.line.addToResult(a), null;
            this.simplifySection(a, g, c);
            this.simplifySection(g, b, c)
        },
        hasBadOutputIntersection: function(a) {
            for (var b =
                    this.outputIndex.query(a).iterator(); b.hasNext();) {
                var c = b.next();
                if (this.hasInteriorIntersection(c, a)) return !0
            }
            return !1
        },
        findFurthestPoint: function(a, b, c, d) {
            var e = new A;
            e.p0 = a[b];
            e.p1 = a[c];
            var f = -1,
                g = b;
            for (b += 1; b < c; b++) {
                var h = e.distance(a[b]);
                h > f && (f = h, g = b)
            }
            return d[0] = f, g
        },
        simplify: function(a) {
            this.line = a;
            this.linePts = a.getParentCoordinates();
            this.simplifySection(0, this.linePts.length - 1, 0)
        },
        remove: function(a, b, c) {
            for (; b < c; b++) {
                var d = a.getSegment(b);
                this.inputIndex.remove(d)
            }
        },
        hasInteriorIntersection: function(a,
            b) {
            return this.li.computeIntersection(a.p0, a.p1, b.p0, b.p1), this.li.isInteriorIntersection()
        },
        hasBadInputIntersection: function(a, b, c) {
            for (var d = this.inputIndex.query(c).iterator(); d.hasNext();) {
                var e = d.next();
                if (this.hasInteriorIntersection(e, c) && !Xd.isInLineSection(a, b, e)) return !0
            }
            return !1
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Xd
        }
    });
    Xd.isInLineSection = function(a, b, c) {
        if (c.getParent() !== a.getParent()) return !1;
        a = c.getIndex();
        return a >= b[0] && a < b[1]
    };
    g(bg.prototype, {
        setDistanceTolerance: function(a) {
            this.distanceTolerance =
                a
        },
        simplify: function(a) {
            for (var b = a.iterator(); b.hasNext();) this.inputIndex.add(b.next());
            for (b = a.iterator(); b.hasNext();) a = new Xd(this.inputIndex, this.outputIndex), a.setDistanceTolerance(this.distanceTolerance), a.simplify(b.next())
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return bg
        }
    });
    g(Fc.prototype, {
        getResultGeometry: function() {
            return this.inputGeom.isEmpty() ? this.inputGeom.copy() : (this.linestringMap = new Cb, this.inputGeom.apply(new Ze(this)), this.lineSimplifier.simplify(this.linestringMap.values()),
                (new Yd(this.linestringMap)).transform(this.inputGeom))
        },
        setDistanceTolerance: function(a) {
            if (0 > a) throw new K("Tolerance must be non-negative");
            this.lineSimplifier.setDistanceTolerance(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Fc
        }
    });
    Fc.simplify = function(a, b) {
        var c = new Fc(a);
        return c.setDistanceTolerance(b), c.getResultGeometry()
    };
    x(Yd, Ca);
    g(Yd.prototype, {
        transformCoordinates: function(a, b) {
            if (0 === a.size()) return null;
            if (b instanceof C) {
                var c = this.linestringMap.get(b);
                return this.createCoordinateSequence(c.getResultCoordinates())
            }
            return Ca.prototype.transformCoordinates.call(this,
                a, b)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Yd
        }
    });
    g(Ze.prototype, {
        filter: function(a) {
            if (a instanceof C) {
                if (a.isEmpty()) return null;
                var b = a.isClosed() ? 4 : 2,
                    b = new Ub(a, b);
                this.tps.linestringMap.put(a, b)
            }
        },
        interfaces_: function() {
            return [eb]
        },
        getClass: function() {
            return Ze
        }
    });
    Fc.LineStringTransformer = Yd;
    Fc.LineStringMapBuilderFilter = Ze;
    var Yg = Object.freeze({
        DouglasPeuckerSimplifier: Yc,
        TopologyPreservingSimplifier: Fc
    });
    g($c.prototype, {
        splitAt: function() {
            if (1 === arguments.length) {
                var a =
                    arguments[0],
                    b = this.minimumLen / this.segLen;
                if (a.distance(this.seg.p0) < this.minimumLen) return this.splitPt = this.seg.pointAlong(b), null;
                if (a.distance(this.seg.p1) < this.minimumLen) return this.splitPt = $c.pointAlongReverse(this.seg, b), null;
                this.splitPt = a
            } else 2 === arguments.length && (a = arguments[1], b = this.getConstrainedLength(arguments[0]) / this.segLen, a.equals2D(this.seg.p0) ? this.splitPt = this.seg.pointAlong(b) : this.splitPt = $c.pointAlongReverse(this.seg, b))
        },
        setMinimumLength: function(a) {
            this.minimumLen = a
        },
        getConstrainedLength: function(a) {
            return a < this.minimumLen ? this.minimumLen : a
        },
        getSplitPoint: function() {
            return this.splitPt
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return $c
        }
    });
    $c.pointAlongReverse = function(a, b) {
        var c = new k;
        return c.x = a.p1.x - b * (a.p1.x - a.p0.x), c.y = a.p1.y - b * (a.p1.y - a.p0.y), c
    };
    g(cg.prototype, {
        findSplitPoint: function(a, b) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return cg
        }
    });
    g(Zd.prototype, {
        findSplitPoint: function(a, b) {
            var c = a.getLineSegment(),
                d = c.getLength() /
                2,
                c = new $c(c),
                e = Zd.projectedSplitPoint(a, b),
                f = 1.6 * e.distance(b);
            return f > d && (f = d), c.setMinimumLength(f), c.splitAt(e), c.getSplitPoint()
        },
        interfaces_: function() {
            return [cg]
        },
        getClass: function() {
            return Zd
        }
    });
    Zd.projectedSplitPoint = function(a, b) {
        return a.getLineSegment().project(b)
    };
    g(V.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return V
        }
    });
    V.triArea = function(a, b, c) {
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)
    };
    V.isInCircleDDNormalized = function(a, b, c, d) {
        var e = m.valueOf(a.x).selfSubtract(d.x),
            f = m.valueOf(a.y).selfSubtract(d.y);
        a = m.valueOf(b.x).selfSubtract(d.x);
        var g = m.valueOf(b.y).selfSubtract(d.y);
        b = m.valueOf(c.x).selfSubtract(d.x);
        var h = m.valueOf(c.y).selfSubtract(d.y);
        c = e.multiply(g).selfSubtract(a.multiply(f));
        d = a.multiply(h).selfSubtract(b.multiply(g));
        var k = b.multiply(f).selfSubtract(e.multiply(h)),
            e = e.multiply(e).selfAdd(f.multiply(f));
        a = a.multiply(a).selfAdd(g.multiply(g));
        b = b.multiply(b).selfAdd(h.multiply(h));
        return 0 < e.selfMultiply(d).selfAdd(a.selfMultiply(k)).selfAdd(b.selfMultiply(c)).doubleValue()
    };
    V.checkRobustInCircle = function(a, b, c, d) {
        var e = V.isInCircleNonRobust(a, b, c, d),
            f = V.isInCircleDDSlow(a, b, c, d),
            g = V.isInCircleCC(a, b, c, d),
            h = S.circumcentre(a, b, c);
        U.out.println("p radius diff a \x3d " + Math.abs(d.distance(h) - a.distance(h)) / a.distance(h));
        e === f && e === g || (U.out.println("inCircle robustness failure (double result \x3d " + e + ", DD result \x3d " + f + ", CC result \x3d " + g + ")"), U.out.println(ra.toLineString(new Za([a, b, c, d]))), U.out.println("Circumcentre \x3d " + ra.toPoint(h) + " radius \x3d " + a.distance(h)),
            U.out.println("p radius diff a \x3d " + Math.abs(d.distance(h) / a.distance(h) - 1)), U.out.println("p radius diff b \x3d " + Math.abs(d.distance(h) / b.distance(h) - 1)), U.out.println("p radius diff c \x3d " + Math.abs(d.distance(h) / c.distance(h) - 1)), U.out.println())
    };
    V.isInCircleDDFast = function(a, b, c, d) {
        var e = m.sqr(a.x).selfAdd(m.sqr(a.y)).selfMultiply(V.triAreaDDFast(b, c, d)),
            f = m.sqr(b.x).selfAdd(m.sqr(b.y)).selfMultiply(V.triAreaDDFast(a, c, d)),
            g = m.sqr(c.x).selfAdd(m.sqr(c.y)).selfMultiply(V.triAreaDDFast(a, b,
                d));
        a = m.sqr(d.x).selfAdd(m.sqr(d.y)).selfMultiply(V.triAreaDDFast(a, b, c));
        return 0 < e.selfSubtract(f).selfAdd(g).selfSubtract(a).doubleValue()
    };
    V.isInCircleCC = function(a, b, c, d) {
        b = S.circumcentre(a, b, c);
        a = a.distance(b);
        return 0 >= d.distance(b) - a
    };
    V.isInCircleNormalized = function(a, b, c, d) {
        var e = a.x - d.x;
        a = a.y - d.y;
        var f = b.x - d.x;
        b = b.y - d.y;
        var g = c.x - d.x;
        c = c.y - d.y;
        return 0 < (e * e + a * a) * (f * c - g * b) + (f * f + b * b) * (g * a - e * c) + (g * g + c * c) * (e * b - f * a)
    };
    V.isInCircleDDSlow = function(a, b, c, d) {
        var e = m.valueOf(d.x);
        d = m.valueOf(d.y);
        var f = m.valueOf(a.x);
        a = m.valueOf(a.y);
        var g = m.valueOf(b.x);
        b = m.valueOf(b.y);
        var h = m.valueOf(c.x),
            k = m.valueOf(c.y);
        c = f.multiply(f).add(a.multiply(a)).multiply(V.triAreaDDSlow(g, b, h, k, e, d));
        var l = g.multiply(g).add(b.multiply(b)).multiply(V.triAreaDDSlow(f, a, h, k, e, d)),
            n = h.multiply(h).add(k.multiply(k)).multiply(V.triAreaDDSlow(f, a, g, b, e, d)),
            e = e.multiply(e).add(d.multiply(d)).multiply(V.triAreaDDSlow(f, a, g, b, h, k));
        return 0 < c.subtract(l).add(n).subtract(e).doubleValue()
    };
    V.isInCircleNonRobust = function(a,
        b, c, d) {
        return 0 < (a.x * a.x + a.y * a.y) * V.triArea(b, c, d) - (b.x * b.x + b.y * b.y) * V.triArea(a, c, d) + (c.x * c.x + c.y * c.y) * V.triArea(a, b, d) - (d.x * d.x + d.y * d.y) * V.triArea(a, b, c)
    };
    V.isInCircleRobust = function(a, b, c, d) {
        return V.isInCircleNormalized(a, b, c, d)
    };
    V.triAreaDDSlow = function(a, b, c, d, e, f) {
        return c.subtract(a).multiply(f.subtract(b)).subtract(d.subtract(b).multiply(e.subtract(a)))
    };
    V.triAreaDDFast = function(a, b, c) {
        var d = m.valueOf(b.x).selfSubtract(a.x).selfMultiply(m.valueOf(c.y).selfSubtract(a.y));
        a = m.valueOf(b.y).selfSubtract(a.y).selfMultiply(m.valueOf(c.x).selfSubtract(a.x));
        return d.selfSubtract(a)
    };
    g(M.prototype, {
        circleCenter: function(a, b) {
            var c = new M(this.getX(), this.getY()),
                d = this.bisector(c, a),
                e = this.bisector(a, b),
                d = new Ha(d, e),
                e = null;
            try {
                e = new M(d.getX(), d.getY())
            } catch (f) {
                if (!(f instanceof xb)) throw f;
                U.err.println("a: " + c + "  b: " + a + "  c: " + b);
                U.err.println(f)
            }
            return e
        },
        dot: function(a) {
            return this.p.x * a.getX() + this.p.y * a.getY()
        },
        magn: function() {
            return Math.sqrt(this.p.x * this.p.x + this.p.y * this.p.y)
        },
        getZ: function() {
            return this.p.z
        },
        bisector: function(a, b) {
            var c =
                b.getX() - a.getX(),
                d = b.getY() - a.getY();
            return new Ha(new Ha(a.getX() + c / 2, a.getY() + d / 2, 1), new Ha(a.getX() - d + c / 2, a.getY() + c + d / 2, 1))
        },
        equals: function() {
            if (1 === arguments.length) {
                var a = arguments[0];
                return this.p.x === a.getX() && this.p.y === a.getY()
            }
            if (2 === arguments.length) return a = arguments[1], this.p.distance(arguments[0].getCoordinate()) < a
        },
        getCoordinate: function() {
            return this.p
        },
        isInCircle: function(a, b, c) {
            return V.isInCircleRobust(a.p, b.p, c.p, this.p)
        },
        interpolateZValue: function(a, b, c) {
            var d = a.getX(),
                e = a.getY(),
                f = b.getX() - d,
                g = c.getX() - d,
                h = b.getY() - e,
                k = c.getY() - e,
                l = f * k - g * h,
                d = this.getX() - d,
                e = this.getY() - e,
                g = (k * d - g * e) / l,
                f = (-h * d + f * e) / l;
            return a.getZ() + g * (b.getZ() - a.getZ()) + f * (c.getZ() - a.getZ())
        },
        midPoint: function(a) {
            return new M((this.p.x + a.getX()) / 2, (this.p.y + a.getY()) / 2, (this.p.z + a.getZ()) / 2)
        },
        rightOf: function(a) {
            return this.isCCW(a.dest(), a.orig())
        },
        isCCW: function(a, b) {
            return 0 < (a.p.x - this.p.x) * (b.p.y - this.p.y) - (a.p.y - this.p.y) * (b.p.x - this.p.x)
        },
        getX: function() {
            return this.p.x
        },
        crossProduct: function(a) {
            return this.p.x *
                a.getY() - this.p.y * a.getX()
        },
        setZ: function(a) {
            this.p.z = a
        },
        times: function(a) {
            return new M(a * this.p.x, a * this.p.y)
        },
        cross: function() {
            return new M(this.p.y, -this.p.x)
        },
        leftOf: function(a) {
            return this.isCCW(a.orig(), a.dest())
        },
        toString: function() {
            return "POINT (" + this.p.x + " " + this.p.y + ")"
        },
        sub: function(a) {
            return new M(this.p.x - a.getX(), this.p.y - a.getY())
        },
        getY: function() {
            return this.p.y
        },
        classify: function(a, b) {
            var c = b.sub(a),
                d = this.sub(a),
                e = c.crossProduct(d);
            return 0 < e ? M.LEFT : 0 > e ? M.RIGHT : 0 > c.getX() * d.getX() ||
                0 > c.getY() * d.getY() ? M.BEHIND : c.magn() < d.magn() ? M.BEYOND : a.equals(this) ? M.ORIGIN : b.equals(this) ? M.DESTINATION : M.BETWEEN
        },
        sum: function(a) {
            return new M(this.p.x + a.getX(), this.p.y + a.getY())
        },
        distance: function(a, b) {
            return Math.sqrt(Math.pow(b.getX() - a.getX(), 2) + Math.pow(b.getY() - a.getY(), 2))
        },
        circumRadiusRatio: function(a, b) {
            var c = this.circleCenter(a, b),
                c = this.distance(c, a),
                d = this.distance(this, a),
                e = this.distance(a, b);
            return e < d && (d = e), e = this.distance(b, this), e < d && (d = e), c / d
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return M
        }
    });
    M.interpolateZ = function() {
        if (3 === arguments.length) {
            var a = arguments[0],
                b = arguments[1],
                c = arguments[2],
                d = b.distance(c),
                a = a.distance(b);
            return b.z + a / d * (c.z - b.z)
        }
        if (4 === arguments.length) {
            var e = arguments[0],
                b = arguments[1],
                c = arguments[2],
                d = arguments[3],
                f = b.x,
                g = b.y,
                a = c.x - f,
                h = d.x - f,
                k = c.y - g,
                l = d.y - g,
                m = a * l - h * k,
                f = e.x - f,
                e = e.y - g;
            return b.z + (l * f - h * e) / m * (c.z - b.z) + (-k * f + a * e) / m * (d.z - b.z)
        }
    };
    M.LEFT = 0;
    M.RIGHT = 1;
    M.BEYOND = 2;
    M.BEHIND = 3;
    M.BETWEEN = 4;
    M.ORIGIN = 5;
    M.DESTINATION = 6;
    x(mc, M);
    g(mc.prototype, {
        getConstraint: function() {
            return this.constraint
        },
        setOnConstraint: function(a) {
            this._isOnConstraint = a
        },
        merge: function(a) {
            a._isOnConstraint && (this._isOnConstraint = !0, this.constraint = a.constraint)
        },
        isOnConstraint: function() {
            return this._isOnConstraint
        },
        setConstraint: function(a) {
            this._isOnConstraint = !0;
            this.constraint = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return mc
        }
    });
    g(Y.prototype, {
        equalsNonOriented: function(a) {
            return !!this.equalsOriented(a) || !!this.equalsOriented(a.sym())
        },
        toLineSegment: function() {
            return new A(this.vertex.getCoordinate(),
                this.dest().getCoordinate())
        },
        dest: function() {
            return this.sym().orig()
        },
        oNext: function() {
            return this.next
        },
        equalsOriented: function(a) {
            return !(!this.orig().getCoordinate().equals2D(a.orig().getCoordinate()) || !this.dest().getCoordinate().equals2D(a.dest().getCoordinate()))
        },
        dNext: function() {
            return this.sym().oNext().sym()
        },
        lPrev: function() {
            return this.next.sym()
        },
        rPrev: function() {
            return this.sym().oNext()
        },
        rot: function() {
            return this._rot
        },
        oPrev: function() {
            return this._rot.next._rot
        },
        sym: function() {
            return this._rot._rot
        },
        setOrig: function(a) {
            this.vertex = a
        },
        lNext: function() {
            return this.invRot().oNext().rot()
        },
        getLength: function() {
            return this.orig().getCoordinate().distance(this.dest().getCoordinate())
        },
        invRot: function() {
            return this._rot.sym()
        },
        setDest: function(a) {
            this.sym().setOrig(a)
        },
        setData: function(a) {
            this.data = a
        },
        getData: function() {
            return this.data
        },
        "delete": function() {
            this._rot = null
        },
        orig: function() {
            return this.vertex
        },
        rNext: function() {
            return this._rot.next.invRot()
        },
        toString: function() {
            var a = this.vertex.getCoordinate(),
                b = this.dest().getCoordinate();
            return ra.toLineString(a, b)
        },
        isLive: function() {
            return null !== this._rot
        },
        getPrimary: function() {
            return 0 >= this.orig().getCoordinate().compareTo(this.dest().getCoordinate()) ? this : this.sym()
        },
        dPrev: function() {
            return this.invRot().oNext().invRot()
        },
        setNext: function(a) {
            this.next = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Y
        }
    });
    Y.makeEdge = function(a, b) {
        var c = new Y,
            d = new Y,
            e = new Y,
            f = new Y;
        c._rot = d;
        d._rot = e;
        e._rot = f;
        f._rot = c;
        c.setNext(c);
        d.setNext(f);
        e.setNext(e);
        f.setNext(d);
        return c.setOrig(a), c.setDest(b), c
    };
    Y.swap = function(a) {
        var b = a.oPrev(),
            c = a.sym().oPrev();
        Y.splice(a, b);
        Y.splice(a.sym(), c);
        Y.splice(a, b.lNext());
        Y.splice(a.sym(), c.lNext());
        a.setOrig(b.dest());
        a.setDest(c.dest())
    };
    Y.splice = function(a, b) {
        var c = a.oNext().rot(),
            d = b.oNext().rot(),
            e = b.oNext(),
            f = a.oNext(),
            g = d.oNext(),
            h = c.oNext();
        a.setNext(e);
        b.setNext(f);
        c.setNext(g);
        d.setNext(h)
    };
    Y.connect = function(a, b) {
        var c = Y.makeEdge(a.dest(), b.orig());
        return Y.splice(c, a.lNext()), Y.splice(c.sym(), b), c
    };
    g($d.prototype, {
        insertSite: function(a) {
            var b = this.subdiv.locate(a);
            if (this.subdiv.isVertexOfEdge(b, a)) return b;
            this.subdiv.isOnEdge(b, a.getCoordinate()) && (b = b.oPrev(), this.subdiv["delete"](b.oNext()));
            var c = this.subdiv.makeEdge(b.orig(), a);
            Y.splice(c, b);
            var d = c;
            do c = this.subdiv.connect(b, c.sym()), b = c.oPrev(); while (b.lNext() !== d);
            for (;;) {
                var e = b.oPrev();
                if (e.dest().rightOf(b) && a.isInCircle(b.orig(), e.dest(), b.dest())) Y.swap(b), b = b.oPrev();
                else {
                    if (b.oNext() === d) return c;
                    b = b.oNext().lPrev()
                }
            }
        },
        insertSites: function(a) {
            for (a =
                a.iterator(); a.hasNext();) {
                var b = a.next();
                this.insertSite(b)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return $d
        }
    });
    g(dg.prototype, {
        locate: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return dg
        }
    });
    g($e.prototype, {
        init: function() {
            this.lastEdge = this.findEdge()
        },
        locate: function(a) {
            this.lastEdge.isLive() || this.init();
            a = this.subdiv.locateFromEdge(a, this.lastEdge);
            return this.lastEdge = a, a
        },
        findEdge: function() {
            return this.subdiv.getEdges().iterator().next()
        },
        interfaces_: function() {
            return [dg]
        },
        getClass: function() {
            return $e
        }
    });
    x(ad, la);
    g(ad.prototype, {
        getSegment: function() {
            return this.seg
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ad
        }
    });
    ad.msgWithSpatial = function(a, b) {
        return null !== b ? a + " [ " + b + " ]" : a
    };
    g(bd.prototype, {
        visit: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return bd
        }
    });
    g(Wa.prototype, {
        getTriangleVertices: function(a) {
            var b = new cf;
            return this.visitTriangles(b, a), b.getTriangleVertices()
        },
        isFrameVertex: function(a) {
            return !!a.equals(this.frameVertex[0]) ||
                !!a.equals(this.frameVertex[1]) || !!a.equals(this.frameVertex[2])
        },
        isVertexOfEdge: function(a, b) {
            return !(!b.equals(a.orig(), this.tolerance) && !b.equals(a.dest(), this.tolerance))
        },
        connect: function(a, b) {
            var c = Y.connect(a, b);
            return this.quadEdges.add(c), c
        },
        getVoronoiCellPolygon: function(a, b) {
            var c = new l,
                d = a;
            do {
                var e = a.rot().orig().getCoordinate();
                c.add(e);
                a = a.oPrev()
            } while (a !== d);
            e = new Z;
            e.addAll(c, !1);
            e.closeRing();
            4 > e.size() && (U.out.println(e), e.add(e.get(e.size() - 1), !0));
            c = e.toCoordinateArray();
            c = b.createPolygon(b.createLinearRing(c),
                null);
            d = d.orig();
            return c.setUserData(d.getCoordinate()), c
        },
        setLocator: function(a) {
            this.locator = a
        },
        initSubdiv: function() {
            var a = this.makeEdge(this.frameVertex[0], this.frameVertex[1]),
                b = this.makeEdge(this.frameVertex[1], this.frameVertex[2]);
            Y.splice(a.sym(), b);
            var c = this.makeEdge(this.frameVertex[2], this.frameVertex[0]);
            return Y.splice(b.sym(), c), Y.splice(c.sym(), a), a
        },
        isFrameBorderEdge: function(a) {
            var b = Array(3).fill(null);
            Wa.getTriangleEdges(a, b);
            b = Array(3).fill(null);
            Wa.getTriangleEdges(a.sym(),
                b);
            b = a.lNext().dest();
            if (this.isFrameVertex(b)) return !0;
            a = a.sym().lNext().dest();
            return !!this.isFrameVertex(a)
        },
        makeEdge: function(a, b) {
            var c = Y.makeEdge(a, b);
            return this.quadEdges.add(c), c
        },
        visitTriangles: function(a, b) {
            this.visitedKey++;
            var c = new xa;
            c.push(this.startingEdge);
            for (var d = new ma; !c.empty();) {
                var e = c.pop();
                d.contains(e) || (e = this.fetchTriangleToVisit(e, c, b, d), null !== e && a.visit(e))
            }
        },
        isFrameEdge: function(a) {
            return !(!this.isFrameVertex(a.orig()) && !this.isFrameVertex(a.dest()))
        },
        isOnEdge: function(a,
            b) {
            return this.seg.setCoordinates(a.orig().getCoordinate(), a.dest().getCoordinate()), this.seg.distance(b) < this.edgeCoincidenceTolerance
        },
        getEnvelope: function() {
            return new y(this.frameEnv)
        },
        createFrame: function(a) {
            var b = a.getWidth(),
                c = a.getHeight(),
                d = 0,
                d = b > c ? 10 * b : 10 * c;
            this.frameVertex[0] = new M((a.getMaxX() + a.getMinX()) / 2, a.getMaxY() + d);
            this.frameVertex[1] = new M(a.getMinX() - d, a.getMinY() - d);
            this.frameVertex[2] = new M(a.getMaxX() + d, a.getMinY() - d);
            this.frameEnv = new y(this.frameVertex[0].getCoordinate(),
                this.frameVertex[1].getCoordinate());
            this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())
        },
        getTriangleCoordinates: function(a) {
            var b = new df;
            return this.visitTriangles(b, a), b.getTriangles()
        },
        getVertices: function(a) {
            for (var b = new ma, c = this.quadEdges.iterator(); c.hasNext();) {
                var d = c.next(),
                    e = d.orig();
                !a && this.isFrameVertex(e) || b.add(e);
                d = d.dest();
                !a && this.isFrameVertex(d) || b.add(d)
            }
            return b
        },
        fetchTriangleToVisit: function(a, b, c, d) {
            var e = a,
                f = 0,
                g = !1;
            do {
                this.triEdges[f] = e;
                this.isFrameEdge(e) &&
                    (g = !0);
                var h = e.sym();
                d.contains(h) || b.push(h);
                d.add(e);
                f++;
                e = e.lNext()
            } while (e !== a);
            return g && !c ? null : this.triEdges
        },
        getEdges: function() {
            if (0 === arguments.length) return this.quadEdges;
            if (1 === arguments.length) {
                for (var a = arguments[0], b = this.getPrimaryEdges(!1), c = Array(b.size()).fill(null), d = 0, b = b.iterator(); b.hasNext();) {
                    var e = b.next();
                    c[d++] = a.createLineString([e.orig().getCoordinate(), e.dest().getCoordinate()])
                }
                return a.createMultiLineString(c)
            }
        },
        getVertexUniqueEdges: function(a) {
            for (var b = new l, c =
                    new ma, d = this.quadEdges.iterator(); d.hasNext();) {
                var e = d.next(),
                    f = e.orig();
                c.contains(f) || (c.add(f), !a && this.isFrameVertex(f) || b.add(e));
                e = e.sym();
                f = e.orig();
                c.contains(f) || (c.add(f), !a && this.isFrameVertex(f) || b.add(e))
            }
            return b
        },
        getTriangleEdges: function(a) {
            var b = new bf;
            return this.visitTriangles(b, a), b.getTriangleEdges()
        },
        getPrimaryEdges: function(a) {
            this.visitedKey++;
            var b = new l,
                c = new xa;
            c.push(this.startingEdge);
            for (var d = new ma; !c.empty();) {
                var e = c.pop();
                if (!d.contains(e)) {
                    var f = e.getPrimary();
                    !a && this.isFrameEdge(f) || b.add(f);
                    c.push(e.oNext());
                    c.push(e.sym().oNext());
                    d.add(e);
                    d.add(e.sym())
                }
            }
            return b
        },
        "delete": function(a) {
            Y.splice(a, a.oPrev());
            Y.splice(a.sym(), a.sym().oPrev());
            var b = a.sym(),
                c = a.rot(),
                d = a.rot().sym();
            this.quadEdges.remove(a);
            this.quadEdges.remove(b);
            this.quadEdges.remove(c);
            this.quadEdges.remove(d);
            a["delete"]();
            b["delete"]();
            c["delete"]();
            d["delete"]()
        },
        locateFromEdge: function(a, b) {
            for (var c = 0, d = this.quadEdges.size(), e = b;;) {
                if (++c > d) throw new ad(e.toLineSegment());
                if (a.equals(e.orig()) ||
                    a.equals(e.dest())) break;
                if (a.rightOf(e)) e = e.sym();
                else if (a.rightOf(e.oNext())) {
                    if (a.rightOf(e.dPrev())) break;
                    e = e.dPrev()
                } else e = e.oNext()
            }
            return e
        },
        getTolerance: function() {
            return this.tolerance
        },
        getVoronoiCellPolygons: function(a) {
            this.visitTriangles(new af, !0);
            for (var b = new l, c = this.getVertexUniqueEdges(!1).iterator(); c.hasNext();) {
                var d = c.next();
                b.add(this.getVoronoiCellPolygon(d, a))
            }
            return b
        },
        getVoronoiDiagram: function(a) {
            var b = this.getVoronoiCellPolygons(a);
            return a.createGeometryCollection(E.toGeometryArray(b))
        },
        getTriangles: function(a) {
            for (var b = this.getTriangleCoordinates(!1), c = Array(b.size()).fill(null), d = 0, b = b.iterator(); b.hasNext();) {
                var e = b.next();
                c[d++] = a.createPolygon(a.createLinearRing(e), null)
            }
            return a.createGeometryCollection(c)
        },
        insertSite: function(a) {
            var b = this.locate(a);
            if (a.equals(b.orig(), this.tolerance) || a.equals(b.dest(), this.tolerance)) return b;
            a = this.makeEdge(b.orig(), a);
            Y.splice(a, b);
            var c = a;
            do a = this.connect(b, a.sym()), b = a.oPrev(); while (b.lNext() !== c);
            return c
        },
        locate: function() {
            if (1 ===
                arguments.length) {
                if (arguments[0] instanceof M) return this.locator.locate(arguments[0]);
                if (arguments[0] instanceof k) return this.locator.locate(new M(arguments[0]))
            } else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = this.locator.locate(new M(a));
                if (null === c) return null;
                var d = c;
                c.dest().getCoordinate().equals2D(a) && (d = c.sym());
                a = d;
                do {
                    if (a.dest().getCoordinate().equals2D(b)) return a;
                    a = a.oNext()
                } while (a !== d);
                return null
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Wa
        }
    });
    Wa.getTriangleEdges = function(a, b) {
        if (b[0] = a, b[1] = b[0].lNext(), b[2] = b[1].lNext(), b[2].lNext() !== b[0]) throw new K("Edges do not form a triangle");
    };
    g(af.prototype, {
        visit: function(a) {
            for (var b = a[0].orig().getCoordinate(), c = a[1].orig().getCoordinate(), d = a[2].orig().getCoordinate(), b = S.circumcentre(b, c, d), b = new M(b), c = 0; 3 > c; c++) a[c].rot().setOrig(b)
        },
        interfaces_: function() {
            return [bd]
        },
        getClass: function() {
            return af
        }
    });
    g(bf.prototype, {
        getTriangleEdges: function() {
            return this.triList
        },
        visit: function(a) {
            this.triList.add(a.clone())
        },
        interfaces_: function() {
            return [bd]
        },
        getClass: function() {
            return bf
        }
    });
    g(cf.prototype, {
        visit: function(a) {
            this.triList.add([a[0].orig(), a[1].orig(), a[2].orig()])
        },
        getTriangleVertices: function() {
            return this.triList
        },
        interfaces_: function() {
            return [bd]
        },
        getClass: function() {
            return cf
        }
    });
    g(df.prototype, {
        checkTriangleSize: function(a) {
            2 <= a.length ? ra.toLineString(a[0], a[1]) : 1 <= a.length && ra.toPoint(a[0])
        },
        visit: function(a) {
            this.coordList.clear();
            for (var b = 0; 3 > b; b++) {
                var c = a[b].orig();
                this.coordList.add(c.getCoordinate())
            }
            if (0 <
                this.coordList.size()) {
                this.coordList.closeRing();
                a = this.coordList.toCoordinateArray();
                if (4 !== a.length) return null;
                this.triCoords.add(a)
            }
        },
        getTriangles: function() {
            return this.triCoords
        },
        interfaces_: function() {
            return [bd]
        },
        getClass: function() {
            return df
        }
    });
    Wa.TriangleCircumcentreVisitor = af;
    Wa.TriangleEdgesListVisitor = bf;
    Wa.TriangleVertexListVisitor = cf;
    Wa.TriangleCoordinatesVisitor = df;
    Wa.EDGE_COINCIDENCE_TOL_FACTOR = 1E3;
    g(Gc.prototype, {
        getLineSegment: function() {
            return this.ls
        },
        getEndZ: function() {
            return this.ls.getCoordinate(1).z
        },
        getStartZ: function() {
            return this.ls.getCoordinate(0).z
        },
        intersection: function(a) {
            return this.ls.intersection(a.getLineSegment())
        },
        getStart: function() {
            return this.ls.getCoordinate(0)
        },
        getEnd: function() {
            return this.ls.getCoordinate(1)
        },
        getEndY: function() {
            return this.ls.getCoordinate(1).y
        },
        getStartX: function() {
            return this.ls.getCoordinate(0).x
        },
        equalsTopo: function(a) {
            return this.ls.equalsTopo(a.getLineSegment())
        },
        getStartY: function() {
            return this.ls.getCoordinate(0).y
        },
        setData: function(a) {
            this.data = a
        },
        getData: function() {
            return this.data
        },
        getEndX: function() {
            return this.ls.getCoordinate(1).x
        },
        toString: function() {
            return this.ls.toString()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Gc
        }
    });
    g(ae.prototype, {
        visit: function(a) {},
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ae
        }
    });
    g(ef.prototype, {
        isRepeated: function() {
            return 1 < this.count
        },
        getRight: function() {
            return this.right
        },
        getCoordinate: function() {
            return this.p
        },
        setLeft: function(a) {
            this.left = a
        },
        getX: function() {
            return this.p.x
        },
        getData: function() {
            return this.data
        },
        getCount: function() {
            return this.count
        },
        getLeft: function() {
            return this.left
        },
        getY: function() {
            return this.p.y
        },
        increment: function() {
            this.count += 1
        },
        setRight: function(a) {
            this.right = a
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ef
        }
    });
    g(Hc.prototype, {
        insert: function() {
            if (1 === arguments.length) return this.insert(arguments[0], null);
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                if (null === this.root) return this.root = new ef(a, b), this.root;
                if (0 <
                    this.tolerance) {
                    var c = this.findBestMatchNode(a);
                    if (null !== c) return c.increment(), c
                }
                return this.insertExact(a, b)
            }
        },
        query: function() {
            if (1 === arguments.length) {
                var a = arguments[0],
                    b = new l;
                return this.query(a, b), b
            }
            if (2 === arguments.length)
                if (arguments[0] instanceof y && u(arguments[1], ga)) {
                    var c = arguments[1];
                    this.queryNode(this.root, arguments[0], !0, {
                        interfaces_: function() {
                            return [ae]
                        },
                        visit: function(a) {
                            c.add(a)
                        }
                    })
                } else arguments[0] instanceof y && u(arguments[1], ae) && this.queryNode(this.root, arguments[0], !0, arguments[1])
        },
        queryNode: function(a, b, c, d) {
            if (null === a) return null;
            var e = null,
                f = null,
                g = null;
            c ? (e = b.getMinX(), f = b.getMaxX(), g = a.getX()) : (e = b.getMinY(), f = b.getMaxY(), g = a.getY());
            f = g <= f;
            e < g && this.queryNode(a.getLeft(), b, !c, d);
            b.contains(a.getCoordinate()) && d.visit(a);
            f && this.queryNode(a.getRight(), b, !c, d)
        },
        findBestMatchNode: function(a) {
            a = new ff(a, this.tolerance);
            return this.query(a.queryEnvelope(), a), a.getNode()
        },
        isEmpty: function() {
            return null === this.root
        },
        insertExact: function(a, b) {
            for (var c = this.root, d = this.root,
                    e = !0, f = !0; null !== c;) {
                if (null !== c && a.distance(c.getCoordinate()) <= this.tolerance) return c.increment(), c;
                f = e ? a.x < c.getX() : a.y < c.getY();
                d = c;
                c = f ? c.getLeft() : c.getRight();
                e = !e
            }
            this.numberOfNodes += 1;
            c = new ef(a, b);
            return f ? d.setLeft(c) : d.setRight(c), c
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Hc
        }
    });
    Hc.toCoordinates = function() {
        if (1 === arguments.length) return Hc.toCoordinates(arguments[0], !1);
        if (2 === arguments.length) {
            for (var a = arguments[0], b = arguments[1], c = new Z, a = a.iterator(); a.hasNext();)
                for (var d =
                        a.next(), e = b ? d.getCount() : 1, f = 0; f < e; f++) c.add(d.getCoordinate(), !0);
            return c.toCoordinateArray()
        }
    };
    g(ff.prototype, {
        visit: function(a) {
            var b = this.p.distance(a.getCoordinate());
            if (!(b <= this.tolerance)) return null;
            var c = !1;
            (null === this.matchNode || b < this.matchDist || null !== this.matchNode && b === this.matchDist && 1 > a.getCoordinate().compareTo(this.matchNode.getCoordinate())) && (c = !0);
            c && (this.matchNode = a, this.matchDist = b)
        },
        queryEnvelope: function() {
            var a = new y(this.p);
            return a.expandBy(this.tolerance), a
        },
        getNode: function() {
            return this.matchNode
        },
        interfaces_: function() {
            return [ae]
        },
        getClass: function() {
            return ff
        }
    });
    Hc.BestMatchVisitor = ff;
    g(nc.prototype, {
        getInitialVertices: function() {
            return this.initialVertices
        },
        getKDT: function() {
            return this.kdt
        },
        enforceConstraints: function() {
            this.addConstraintVertices();
            var a = 0,
                b = 0;
            do b = this.enforceGabriel(this.segments), a++; while (0 < b && a < nc.MAX_SPLIT_ITER)
        },
        insertSites: function(a) {
            for (a = a.iterator(); a.hasNext();) {
                var b = a.next();
                this.insertSite(b)
            }
        },
        getVertexFactory: function() {
            return this.vertexFactory
        },
        getPointArray: function() {
            for (var a =
                    Array(this.initialVertices.size() + this.segVertices.size()).fill(null), b = 0, c = this.initialVertices.iterator(); c.hasNext();) {
                var d = c.next();
                a[b++] = d.getCoordinate()
            }
            for (c = this.segVertices.iterator(); c.hasNext();) d = c.next(), a[b++] = d.getCoordinate();
            return a
        },
        setConstraints: function(a, b) {
            this.segments = a;
            this.segVertices = b
        },
        computeConvexHull: function() {
            var a = new E,
                b = this.getPointArray();
            this.convexHull = (new Eb(b, a)).getConvexHull()
        },
        addConstraintVertices: function() {
            this.computeConvexHull();
            this.insertSites(this.segVertices)
        },
        findNonGabrielPoint: function(a) {
            var b = a.getStart();
            a = a.getEnd();
            var c = new k((b.x + a.x) / 2, (b.y + a.y) / 2),
                d = b.distance(c),
                e = new y(c);
            e.expandBy(d);
            for (var f = this.kdt.query(e), e = null, g = v.MAX_VALUE, f = f.iterator(); f.hasNext();) {
                var h = f.next().getCoordinate();
                if (!h.equals2D(b) && !h.equals2D(a)) {
                    var l = c.distance(h);
                    l < d && (null === e || l < g) && (e = h, g = l)
                }
            }
            return e
        },
        getConstraintSegments: function() {
            return this.segments
        },
        setSplitPointFinder: function(a) {
            this.splitFinder = a
        },
        getConvexHull: function() {
            return this.convexHull
        },
        getTolerance: function() {
            return this.tolerance
        },
        enforceGabriel: function(a) {
            for (var b = new l, c = 0, d = new l, e = a.iterator(); e.hasNext();) {
                var f = e.next(),
                    g = this.findNonGabrielPoint(f);
                if (null !== g) {
                    this.splitPt = this.splitFinder.findSplitPoint(f, g);
                    var h = this.createVertex(this.splitPt, f),
                        g = (this.insertSite(h), new Gc(f.getStartX(), f.getStartY(), f.getStartZ(), h.getX(), h.getY(), h.getZ(), f.getData())),
                        h = new Gc(h.getX(), h.getY(), h.getZ(), f.getEndX(), f.getEndY(), f.getEndZ(), f.getData());
                    b.add(g);
                    b.add(h);
                    d.add(f);
                    c += 1
                }
            }
            return a.removeAll(d), a.addAll(b), c
        },
        createVertex: function() {
            if (1 === arguments.length) {
                var a = arguments[0],
                    b = null;
                return null !== this.vertexFactory ? this.vertexFactory.createVertex(a, null) : new mc(a)
            }
            if (2 === arguments.length) {
                var a = arguments[0],
                    c = arguments[1],
                    b = null;
                return b = null !== this.vertexFactory ? this.vertexFactory.createVertex(a, c) : new mc(a), b.setOnConstraint(!0), b
            }
        },
        getSubdivision: function() {
            return this.subdiv
        },
        computeBoundingBox: function() {
            var a = nc.computeVertexEnvelope(this.initialVertices),
                b = nc.computeVertexEnvelope(this.segVertices),
                a = new y(a);
            a.expandToInclude(b);
            var b = .2 * a.getWidth(),
                c = .2 * a.getHeight(),
                b = Math.max(b, c);
            this.computeAreaEnv = new y(a);
            this.computeAreaEnv.expandBy(b)
        },
        setVertexFactory: function(a) {
            this.vertexFactory = a
        },
        formInitialDelaunay: function() {
            this.computeBoundingBox();
            this.subdiv = new Wa(this.computeAreaEnv, this.tolerance);
            this.subdiv.setLocator(new $e(this.subdiv));
            this.incDel = new $d(this.subdiv);
            this.insertSites(this.initialVertices)
        },
        insertSite: function(a) {
            if (a instanceof mc) {
                var b = this.kdt.insert(a.getCoordinate(), a);
                return b.isRepeated() ? (b = b.getData(), b.merge(a), b) : (this.incDel.insertSite(a), a)
            }
            a instanceof k && this.insertSite(this.createVertex(a))
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return nc
        }
    });
    nc.computeVertexEnvelope = function(a) {
        var b = new y;
        for (a = a.iterator(); a.hasNext();) {
            var c = a.next();
            b.expandToInclude(c.getCoordinate())
        }
        return b
    };
    nc.MAX_SPLIT_ITER = 99;
    g(ua.prototype, {
        create: function() {
            if (null !== this.subdiv) return null;
            var a = ua.envelope(this.siteCoords),
                b = ua.toVertices(this.siteCoords);
            this.subdiv = new Wa(a, this.tolerance);
            (new $d(this.subdiv)).insertSites(b)
        },
        setTolerance: function(a) {
            this.tolerance = a
        },
        setSites: function(a) {
            a instanceof r ? this.siteCoords = ua.extractUniqueCoordinates(a) : u(a, T) && (this.siteCoords = ua.unique(z.toCoordinateArray(a)))
        },
        getEdges: function(a) {
            return this.create(), this.subdiv.getEdges(a)
        },
        getSubdivision: function() {
            return this.create(), this.subdiv
        },
        getTriangles: function(a) {
            return this.create(), this.subdiv.getTriangles(a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ua
        }
    });
    ua.extractUniqueCoordinates = function(a) {
        if (null === a) return new Z;
        a = a.getCoordinates();
        return ua.unique(a)
    };
    ua.envelope = function(a) {
        var b = new y;
        for (a = a.iterator(); a.hasNext();) {
            var c = a.next();
            b.expandToInclude(c)
        }
        return b
    };
    ua.unique = function(a) {
        a = z.copyDeep(a);
        return zb.sort(a), new Z(a, !1)
    };
    ua.toVertices = function(a) {
        var b = new l;
        for (a = a.iterator(); a.hasNext();) {
            var c = a.next();
            b.add(new M(c))
        }
        return b
    };
    g(cd.prototype, {
        createSiteVertices: function(a) {
            var b = new l;
            for (a =
                a.iterator(); a.hasNext();) {
                var c = a.next();
                this.constraintVertexMap.containsKey(c) || b.add(new mc(c))
            }
            return b
        },
        create: function() {
            if (null !== this.subdiv) return null;
            var a = ua.envelope(this.siteCoords),
                b = new l;
            null !== this.constraintLines && (a.expandToInclude(this.constraintLines.getEnvelopeInternal()), this.createVertices(this.constraintLines), b = cd.createConstraintSegments(this.constraintLines));
            a = this.createSiteVertices(this.siteCoords);
            a = new nc(a, this.tolerance);
            a.setConstraints(b, new l(this.constraintVertexMap.values()));
            a.formInitialDelaunay();
            a.enforceConstraints();
            this.subdiv = a.getSubdivision()
        },
        setTolerance: function(a) {
            this.tolerance = a
        },
        setConstraints: function(a) {
            this.constraintLines = a
        },
        setSites: function(a) {
            this.siteCoords = ua.extractUniqueCoordinates(a)
        },
        getEdges: function(a) {
            return this.create(), this.subdiv.getEdges(a)
        },
        getSubdivision: function() {
            return this.create(), this.subdiv
        },
        getTriangles: function(a) {
            return this.create(), this.subdiv.getTriangles(a)
        },
        createVertices: function(a) {
            a = a.getCoordinates();
            for (var b =
                    0; b < a.length; b++) {
                var c = new mc(a[b]);
                this.constraintVertexMap.put(a[b], c)
            }
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return cd
        }
    });
    cd.createConstraintSegments = function() {
        if (1 === arguments.length) {
            for (var a = sa.getLines(arguments[0]), b = new l, a = a.iterator(); a.hasNext();) {
                var c = a.next();
                cd.createConstraintSegments(c, b)
            }
            return b
        }
        if (2 === arguments.length)
            for (b = arguments[1], c = arguments[0].getCoordinates(), a = 1; a < c.length; a++) b.add(new Gc(c[a - 1], c[a]))
    };
    g(be.prototype, {
        create: function() {
            if (null !==
                this.subdiv) return null;
            var a = ua.envelope(this.siteCoords);
            this.diagramEnv = a;
            var b = Math.max(this.diagramEnv.getWidth(), this.diagramEnv.getHeight());
            this.diagramEnv.expandBy(b);
            null !== this.clipEnv && this.diagramEnv.expandToInclude(this.clipEnv);
            b = ua.toVertices(this.siteCoords);
            this.subdiv = new Wa(a, this.tolerance);
            (new $d(this.subdiv)).insertSites(b)
        },
        getDiagram: function(a) {
            this.create();
            a = this.subdiv.getVoronoiDiagram(a);
            return be.clipGeometryCollection(a, this.diagramEnv)
        },
        setTolerance: function(a) {
            this.tolerance =
                a
        },
        setSites: function(a) {
            a instanceof r ? this.siteCoords = ua.extractUniqueCoordinates(a) : u(a, T) && (this.siteCoords = ua.unique(z.toCoordinateArray(a)))
        },
        setClipEnvelope: function(a) {
            this.clipEnv = a
        },
        getSubdivision: function() {
            return this.create(), this.subdiv
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return be
        }
    });
    be.clipGeometryCollection = function(a, b) {
        for (var c = a.getFactory().toGeometry(b), d = new l, e = 0; e < a.getNumGeometries(); e++) {
            var f = a.getGeometryN(e),
                g = null;
            b.contains(f.getEnvelopeInternal()) ?
                g = f : b.intersects(f.getEnvelopeInternal()) && (g = c.intersection(f), g.setUserData(f.getUserData()));
            null === g || g.isEmpty() || d.add(g)
        }
        return a.getFactory().createGeometryCollection(E.toGeometryArray(d))
    };
    var Zg = Object.freeze({
            Vertex: M
        }),
        $g = Object.freeze({
            ConformingDelaunayTriangulationBuilder: cd,
            DelaunayTriangulationBuilder: ua,
            VoronoiDiagramBuilder: be,
            quadedge: Zg
        });
    g(ka.prototype, {
        getSegmentIndex: function() {
            return this.segmentIndex
        },
        getComponentIndex: function() {
            return this.componentIndex
        },
        isEndpoint: function(a) {
            a =
                a.getGeometryN(this.componentIndex).getNumPoints() - 1;
            return this.segmentIndex >= a || this.segmentIndex === a && 1 <= this.segmentFraction
        },
        isValid: function(a) {
            if (0 > this.componentIndex || this.componentIndex >= a.getNumGeometries()) return !1;
            a = a.getGeometryN(this.componentIndex);
            return !(0 > this.segmentIndex || this.segmentIndex > a.getNumPoints()) && (this.segmentIndex !== a.getNumPoints() || 0 === this.segmentFraction) && !(0 > this.segmentFraction || 1 < this.segmentFraction)
        },
        normalize: function() {
            0 > this.segmentFraction && (this.segmentFraction =
                0);
            1 < this.segmentFraction && (this.segmentFraction = 1);
            0 > this.componentIndex && (this.componentIndex = 0, this.segmentIndex = 0, this.segmentFraction = 0);
            0 > this.segmentIndex && (this.segmentIndex = 0, this.segmentFraction = 0);
            1 === this.segmentFraction && (this.segmentFraction = 0, this.segmentIndex += 1)
        },
        toLowest: function(a) {
            a = a.getGeometryN(this.componentIndex).getNumPoints() - 1;
            return this.segmentIndex < a ? this : new ka(this.componentIndex, a, 1, !1)
        },
        getCoordinate: function(a) {
            var b = a.getGeometryN(this.componentIndex);
            a = b.getCoordinateN(this.segmentIndex);
            if (this.segmentIndex >= b.getNumPoints() - 1) return a;
            b = b.getCoordinateN(this.segmentIndex + 1);
            return ka.pointAlongSegmentByFraction(a, b, this.segmentFraction)
        },
        getSegmentFraction: function() {
            return this.segmentFraction
        },
        getSegment: function(a) {
            a = a.getGeometryN(this.componentIndex);
            var b = a.getCoordinateN(this.segmentIndex);
            return this.segmentIndex >= a.getNumPoints() - 1 ? new A(a.getCoordinateN(a.getNumPoints() - 2), b) : new A(b, a.getCoordinateN(this.segmentIndex + 1))
        },
        clamp: function(a) {
            if (this.componentIndex >= a.getNumGeometries()) return this.setToEnd(a),
                null;
            this.segmentIndex >= a.getNumPoints() && (this.segmentIndex = a.getGeometryN(this.componentIndex).getNumPoints() - 1, this.segmentFraction = 1)
        },
        setToEnd: function(a) {
            this.componentIndex = a.getNumGeometries() - 1;
            this.segmentIndex = a.getGeometryN(this.componentIndex).getNumPoints() - 1;
            this.segmentFraction = 1
        },
        compareTo: function(a) {
            return this.componentIndex < a.componentIndex ? -1 : this.componentIndex > a.componentIndex ? 1 : this.segmentIndex < a.segmentIndex ? -1 : this.segmentIndex > a.segmentIndex ? 1 : this.segmentFraction < a.segmentFraction ?
                -1 : this.segmentFraction > a.segmentFraction ? 1 : 0
        },
        clone: function() {
            return new ka(this.componentIndex, this.segmentIndex, this.segmentFraction)
        },
        toString: function() {
            return "LinearLoc[" + this.componentIndex + ", " + this.segmentIndex + ", " + this.segmentFraction + "]"
        },
        isOnSameSegment: function(a) {
            return this.componentIndex === a.componentIndex && (this.segmentIndex === a.segmentIndex || 1 == a.segmentIndex - this.segmentIndex && 0 === a.segmentFraction || 1 == this.segmentIndex - a.segmentIndex && 0 === this.segmentFraction)
        },
        snapToVertex: function(a,
            b) {
            if (0 >= this.segmentFraction || 1 <= this.segmentFraction) return null;
            var c = this.getSegmentLength(a),
                d = this.segmentFraction * c,
                c = c - d;
            d <= c && d < b ? this.segmentFraction = 0 : c <= d && c < b && (this.segmentFraction = 1)
        },
        compareLocationValues: function(a, b, c) {
            return this.componentIndex < a ? -1 : this.componentIndex > a ? 1 : this.segmentIndex < b ? -1 : this.segmentIndex > b ? 1 : this.segmentFraction < c ? -1 : this.segmentFraction > c ? 1 : 0
        },
        getSegmentLength: function(a) {
            var b = a.getGeometryN(this.componentIndex),
                c = this.segmentIndex;
            this.segmentIndex >=
                b.getNumPoints() - 1 && (c = b.getNumPoints() - 2);
            a = b.getCoordinateN(c);
            b = b.getCoordinateN(c + 1);
            return a.distance(b)
        },
        isVertex: function() {
            return 0 >= this.segmentFraction || 1 <= this.segmentFraction
        },
        interfaces_: function() {
            return [Aa]
        },
        getClass: function() {
            return ka
        }
    });
    ka.getEndLocation = function(a) {
        var b = new ka;
        return b.setToEnd(a), b
    };
    ka.pointAlongSegmentByFraction = function(a, b, c) {
        return 0 >= c ? a : 1 <= c ? b : new k((b.x - a.x) * c + a.x, (b.y - a.y) * c + a.y, (b.z - a.z) * c + a.z)
    };
    ka.compareLocationValues = function(a, b, c, d, e, f) {
        return a <
            d ? -1 : a > d ? 1 : b < e ? -1 : b > e ? 1 : c < f ? -1 : c > f ? 1 : 0
    };
    g(kb.prototype, {
        getComponentIndex: function() {
            return this.componentIndex
        },
        getLine: function() {
            return this.currentLine
        },
        getVertexIndex: function() {
            return this.vertexIndex
        },
        getSegmentEnd: function() {
            return this.vertexIndex < this.getLine().getNumPoints() - 1 ? this.currentLine.getCoordinateN(this.vertexIndex + 1) : null
        },
        next: function() {
            if (!this.hasNext()) return null;
            ++this.vertexIndex >= this.currentLine.getNumPoints() && (this.componentIndex++, this.loadCurrentLine(), this.vertexIndex =
                0)
        },
        loadCurrentLine: function() {
            if (this.componentIndex >= this.numLines) return this.currentLine = null, null;
            this.currentLine = this.linearGeom.getGeometryN(this.componentIndex)
        },
        getSegmentStart: function() {
            return this.currentLine.getCoordinateN(this.vertexIndex)
        },
        isEndOfLine: function() {
            return !(this.componentIndex >= this.numLines) && !(this.vertexIndex < this.currentLine.getNumPoints() - 1)
        },
        hasNext: function() {
            return !(this.componentIndex >= this.numLines) && !(this.componentIndex === this.numLines - 1 && this.vertexIndex >=
                this.currentLine.getNumPoints())
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return kb
        }
    });
    kb.segmentEndVertexIndex = function(a) {
        return 0 < a.getSegmentFraction() ? a.getSegmentIndex() + 1 : a.getSegmentIndex()
    };
    g(Lb.prototype, {
        indexOf: function(a) {
            return this.indexOfFromStart(a, null)
        },
        indexOfFromStart: function(a, b) {
            for (var c = v.MAX_VALUE, d = 0, e = 0, f = -1, g = new A, h = new kb(this.linearGeom); h.hasNext(); h.next())
                if (!h.isEndOfLine()) {
                    g.p0 = h.getSegmentStart();
                    g.p1 = h.getSegmentEnd();
                    var k = g.distance(a),
                        l = g.segmentFraction(a),
                        m = h.getComponentIndex(),
                        n = h.getVertexIndex();
                    k < c && (null === b || 0 > b.compareLocationValues(m, n, l)) && (d = m, e = n, f = l, c = k)
                }
            return c === v.MAX_VALUE ? new ka(b) : new ka(d, e, f)
        },
        indexOfAfter: function(a, b) {
            if (null === b) return this.indexOf(a);
            var c = ka.getEndLocation(this.linearGeom);
            if (0 >= c.compareTo(b)) return c;
            c = this.indexOfFromStart(a, b);
            return t.isTrue(0 <= c.compareTo(b), "computed location is before specified minimum location"), c
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Lb
        }
    });
    Lb.indexOf = function(a,
        b) {
        return (new Lb(a)).indexOf(b)
    };
    Lb.indexOfAfter = function(a, b, c) {
        return (new Lb(a)).indexOfAfter(b, c)
    };
    g(dd.prototype, {
        indicesOf: function(a) {
            var b = a.getGeometryN(0).getCoordinateN(0),
                c = a.getGeometryN(a.getNumGeometries() - 1),
                c = c.getCoordinateN(c.getNumPoints() - 1),
                d = new Lb(this.linearGeom),
                e = Array(2).fill(null);
            return e[0] = d.indexOf(b), 0 === a.getLength() ? e[1] = e[0].clone() : e[1] = d.indexOfAfter(c, e[0]), e
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return dd
        }
    });
    dd.indicesOf = function(a, b) {
        return (new dd(a)).indicesOf(b)
    };
    g(gf.prototype, {
        getGeometry: function() {
            return this.endLine(), this.geomFact.buildGeometry(this.lines)
        },
        getLastCoordinate: function() {
            return this.lastPt
        },
        endLine: function() {
            if (null === this.coordList) return null;
            if (this.ignoreInvalidLines && 2 > this.coordList.size()) return this.coordList = null, null;
            var a = this.coordList.toCoordinateArray(),
                b = a;
            this.fixInvalidLines && (b = this.validCoordinateSequence(a));
            a = this.coordList = null;
            try {
                a = this.geomFact.createLineString(b)
            } catch (c) {
                if (!(c instanceof K)) throw c;
                if (!this.ignoreInvalidLines) throw c;
            }
            null !== a && this.lines.add(a)
        },
        setFixInvalidLines: function(a) {
            this.fixInvalidLines = a
        },
        add: function() {
            if (1 === arguments.length) this.add(arguments[0], !0);
            else if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1];
                null === this.coordList && (this.coordList = new Z);
                this.coordList.add(a, b);
                this.lastPt = a
            }
        },
        setIgnoreInvalidLines: function(a) {
            this.ignoreInvalidLines = a
        },
        validCoordinateSequence: function(a) {
            return 2 <= a.length ? a : [a[0], a[0]]
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return gf
        }
    });
    g(ed.prototype, {
        computeLinear: function(a, b) {
            var c = new gf(this.line.getFactory());
            c.setFixInvalidLines(!0);
            a.isVertex() || c.add(a.getCoordinate(this.line));
            for (var d = new kb(this.line, a); d.hasNext() && !(0 > b.compareLocationValues(d.getComponentIndex(), d.getVertexIndex(), 0)); d.next()) {
                var e = d.getSegmentStart();
                c.add(e);
                d.isEndOfLine() && c.endLine()
            }
            return b.isVertex() || c.add(b.getCoordinate(this.line)), c.getGeometry()
        },
        computeLine: function(a, b) {
            var c = this.line.getCoordinates(),
                d = new Z,
                e = a.getSegmentIndex();
            0 < a.getSegmentFraction() &&
                (e += 1);
            var f = b.getSegmentIndex();
            1 === b.getSegmentFraction() && (f += 1);
            f >= c.length && (f = c.length - 1);
            for (a.isVertex() || d.add(a.getCoordinate(this.line)); e <= f; e++) d.add(c[e]);
            b.isVertex() || d.add(b.getCoordinate(this.line));
            0 >= d.size() && d.add(a.getCoordinate(this.line));
            c = d.toCoordinateArray();
            return 1 >= c.length && (c = [c[0], c[0]]), this.line.getFactory().createLineString(c)
        },
        extract: function(a, b) {
            return 0 > b.compareTo(a) ? this.reverse(this.computeLinear(b, a)) : this.computeLinear(a, b)
        },
        reverse: function(a) {
            return a instanceof
            C ? a.reverse() : a instanceof wa ? a.reverse() : (t.shouldNeverReachHere("non-linear geometry encountered"), null)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return ed
        }
    });
    ed.extract = function(a, b, c) {
        return (new ed(a)).extract(b, c)
    };
    g(hf.prototype, {
        clampIndex: function(a) {
            a = a.clone();
            return a.clamp(this.linearGeom), a
        },
        project: function(a) {
            return Lb.indexOf(this.linearGeom, a)
        },
        checkGeometryType: function() {
            if (!(this.linearGeom instanceof C || this.linearGeom instanceof wa)) throw new K("Input geometry must be linear");
        },
        extractPoint: function() {
            if (1 === arguments.length) return arguments[0].getCoordinate(this.linearGeom);
            if (2 === arguments.length) {
                var a = arguments[1],
                    b = arguments[0].toLowest(this.linearGeom);
                return b.getSegment(this.linearGeom).pointAlongOffset(b.getSegmentFraction(), a)
            }
        },
        isValidIndex: function(a) {
            return a.isValid(this.linearGeom)
        },
        getEndIndex: function() {
            return ka.getEndLocation(this.linearGeom)
        },
        getStartIndex: function() {
            return new ka
        },
        indexOfAfter: function(a, b) {
            return Lb.indexOfAfter(this.linearGeom, a,
                b)
        },
        extractLine: function(a, b) {
            return ed.extract(this.linearGeom, a, b)
        },
        indexOf: function(a) {
            return Lb.indexOf(this.linearGeom, a)
        },
        indicesOf: function(a) {
            return dd.indicesOf(this.linearGeom, a)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return hf
        }
    });
    g(Vb.prototype, {
        indexOf: function(a) {
            return this.indexOfFromStart(a, -1)
        },
        indexOfFromStart: function(a, b) {
            for (var c = v.MAX_VALUE, d = b, e = 0, f = new A, g = new kb(this.linearGeom); g.hasNext();) {
                if (!g.isEndOfLine()) {
                    f.p0 = g.getSegmentStart();
                    f.p1 = g.getSegmentEnd();
                    var h = f.distance(a),
                        k = this.segmentNearestMeasure(f, a, e);
                    h < c && k > b && (d = k, c = h);
                    e += f.getLength()
                }
                g.next()
            }
            return d
        },
        indexOfAfter: function(a, b) {
            if (0 > b) return this.indexOf(a);
            var c = this.linearGeom.getLength();
            if (c < b) return c;
            c = this.indexOfFromStart(a, b);
            return t.isTrue(c >= b, "computed index is before specified minimum index"), c
        },
        segmentNearestMeasure: function(a, b, c) {
            b = a.projectionFactor(b);
            return 0 >= b ? c : 1 >= b ? c + b * a.getLength() : c + a.getLength()
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Vb
        }
    });
    Vb.indexOf = function(a, b) {
        return (new Vb(a)).indexOf(b)
    };
    Vb.indexOfAfter = function(a, b, c) {
        return (new Vb(a)).indexOfAfter(b, c)
    };
    g(Xa.prototype, {
        getLength: function(a) {
            for (var b = 0, c = new kb(this.linearGeom); c.hasNext();) {
                if (!c.isEndOfLine()) {
                    var d = c.getSegmentStart(),
                        d = c.getSegmentEnd().distance(d);
                    if (a.getComponentIndex() === c.getComponentIndex() && a.getSegmentIndex() === c.getVertexIndex()) return b + d * a.getSegmentFraction();
                    b += d
                }
                c.next()
            }
            return b
        },
        resolveHigher: function(a) {
            if (!a.isEndpoint(this.linearGeom)) return a;
            var b = a.getComponentIndex();
            if (b >= this.linearGeom.getNumGeometries() - 1) return a;
            do b++; while (b < this.linearGeom.getNumGeometries() - 1 && 0 === this.linearGeom.getGeometryN(b).getLength());
            return new ka(b, 0, 0)
        },
        getLocation: function() {
            if (1 === arguments.length) return this.getLocation(arguments[0], !0);
            if (2 === arguments.length) {
                var a = arguments[0],
                    b = arguments[1],
                    c = a;
                0 > a && (c = this.linearGeom.getLength() + a);
                a = this.getLocationForward(c);
                return b ? a : this.resolveHigher(a)
            }
        },
        getLocationForward: function(a) {
            if (0 >= a) return new ka;
            for (var b = 0, c = new kb(this.linearGeom); c.hasNext();) {
                if (c.isEndOfLine()) {
                    if (b === a) return a = c.getComponentIndex(), c = c.getVertexIndex(), new ka(a, c, 0)
                } else {
                    var d = c.getSegmentStart(),
                        d = c.getSegmentEnd().distance(d);
                    if (b + d > a) return b = (a - b) / d, a = c.getComponentIndex(), c = c.getVertexIndex(), new ka(a, c, b);
                    b += d
                }
                c.next()
            }
            return ka.getEndLocation(this.linearGeom)
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return Xa
        }
    });
    Xa.getLength = function(a, b) {
        return (new Xa(a)).getLength(b)
    };
    Xa.getLocation = function() {
        if (2 ===
            arguments.length) {
            var a = arguments[1],
                b = new Xa(arguments[0]);
            return b.getLocation(a)
        }
        if (3 === arguments.length) {
            var a = arguments[1],
                c = arguments[2],
                b = new Xa(arguments[0]);
            return b.getLocation(a, c)
        }
    };
    g(eg.prototype, {
        clampIndex: function(a) {
            a = this.positiveIndex(a);
            var b = this.getStartIndex();
            if (a < b) return b;
            b = this.getEndIndex();
            return a > b ? b : a
        },
        locationOf: function() {
            if (1 === arguments.length) return Xa.getLocation(this.linearGeom, arguments[0]);
            if (2 === arguments.length) return Xa.getLocation(this.linearGeom, arguments[0],
                arguments[1])
        },
        project: function(a) {
            return Vb.indexOf(this.linearGeom, a)
        },
        positiveIndex: function(a) {
            return 0 <= a ? a : this.linearGeom.getLength() + a
        },
        extractPoint: function() {
            if (1 === arguments.length) {
                var a = Xa.getLocation(this.linearGeom, arguments[0]);
                return a.getCoordinate(this.linearGeom)
            }
            if (2 === arguments.length) {
                var b = arguments[1],
                    a = Xa.getLocation(this.linearGeom, arguments[0]),
                    a = a.toLowest(this.linearGeom);
                return a.getSegment(this.linearGeom).pointAlongOffset(a.getSegmentFraction(), b)
            }
        },
        isValidIndex: function(a) {
            return a >=
                this.getStartIndex() && a <= this.getEndIndex()
        },
        getEndIndex: function() {
            return this.linearGeom.getLength()
        },
        getStartIndex: function() {
            return 0
        },
        indexOfAfter: function(a, b) {
            return Vb.indexOfAfter(this.linearGeom, a, b)
        },
        extractLine: function(a, b) {
            var c = (new hf(this.linearGeom), this.clampIndex(a)),
                d = this.clampIndex(b),
                c = this.locationOf(c, c === d),
                d = this.locationOf(d);
            return ed.extract(this.linearGeom, c, d)
        },
        indexOf: function(a) {
            return Vb.indexOf(this.linearGeom, a)
        },
        indicesOf: function(a) {
            a = dd.indicesOf(this.linearGeom,
                a);
            return [Xa.getLength(this.linearGeom, a[0]), Xa.getLength(this.linearGeom, a[1])]
        },
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return eg
        }
    });
    var ah = Object.freeze({
        LengthIndexedLine: eg,
        LengthLocationMap: Xa,
        LinearGeometryBuilder: gf,
        LinearIterator: kb,
        LinearLocation: ka,
        LocationIndexedLine: hf
    });
    g(jf.prototype, {
        interfaces_: function() {
            return []
        },
        getClass: function() {
            return jf
        }
    });
    jf.union = function(a, b) {
        if (a.isEmpty() || b.isEmpty()) {
            if (a.isEmpty() && b.isEmpty()) return w.createEmptyResult(w.UNION, a, b, a.getFactory());
            if (a.isEmpty()) return b.copy();
            if (b.isEmpty()) return a.copy()
        }
        return a.checkNotGeometryCollection(a), a.checkNotGeometryCollection(b), ja.overlayOp(a, b, w.UNION)
    };
    g(r.prototype, {
        equalsTopo: function(a) {
            return !!this.getEnvelopeInternal().equals(a.getEnvelopeInternal()) && J.relate(this, a).isEquals(this.getDimension(), a.getDimension())
        },
        union: function() {
            if (0 === arguments.length) return lc.union(this);
            if (1 === arguments.length) return jf.union(this, arguments[0])
        },
        isValid: function() {
            return Ua.isValid(this)
        },
        intersection: function(a) {
            return this.isEmpty() ||
                a.isEmpty() ? w.createEmptyResult(w.INTERSECTION, this, a, this.factory) : this.isGeometryCollection() ? Nc.map(this, {
                    interfaces_: function() {
                        return [MapOp]
                    },
                    map: function(b) {
                        return b.intersection(a)
                    }
                }) : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(a), ja.overlayOp(this, a, w.INTERSECTION))
        },
        covers: function(a) {
            return J.covers(this, a)
        },
        coveredBy: function(a) {
            return J.coveredBy(this, a)
        },
        touches: function(a) {
            return J.touches(this, a)
        },
        intersects: function(a) {
            return J.intersects(this, a)
        },
        within: function(a) {
            return J.within(this,
                a)
        },
        overlaps: function(a) {
            return J.overlaps(this, a)
        },
        disjoint: function(a) {
            return J.disjoint(this, a)
        },
        crosses: function(a) {
            return J.crosses(this, a)
        },
        buffer: function() {
            if (1 === arguments.length) return pa.bufferOp(this, arguments[0]);
            if (2 === arguments.length) return pa.bufferOp(this, arguments[0], arguments[1]);
            if (3 === arguments.length) return pa.bufferOp(this, arguments[0], arguments[1], arguments[2])
        },
        convexHull: function() {
            return (new Eb(this)).getConvexHull()
        },
        relate: function() {
            for (var a = arguments.length, b = Array(a),
                    c = 0; c < a; c++) b[c] = arguments[c];
            return J.relate.apply(J, [this].concat(b))
        },
        getCentroid: function() {
            if (this.isEmpty()) return this.factory.createPoint();
            var a = Db.getCentroid(this);
            return this.createPointFromInternalCoord(a, this)
        },
        getInteriorPoint: function() {
            if (this.isEmpty()) return this.factory.createPoint();
            var a = null,
                a = this.getDimension(),
                a = (0 === a ? new Ee(this) : 1 === a ? new De(this) : new hb(this)).getInteriorPoint();
            return this.createPointFromInternalCoord(a, this)
        },
        symDifference: function(a) {
            if (this.isEmpty() ||
                a.isEmpty()) {
                if (this.isEmpty() && a.isEmpty()) return w.createEmptyResult(w.SYMDIFFERENCE, this, a, this.factory);
                if (this.isEmpty()) return a.copy();
                if (a.isEmpty()) return this.copy()
            }
            return this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(a), ja.overlayOp(this, a, w.SYMDIFFERENCE)
        },
        createPointFromInternalCoord: function(a, b) {
            return b.getPrecisionModel().makePrecise(a), b.getFactory().createPoint(a)
        },
        toText: function() {
            return (new ra).write(this)
        },
        toString: function() {
            this.toText()
        },
        contains: function(a) {
            return J.contains(this,
                a)
        },
        difference: function(a) {
            return this.isEmpty() ? w.createEmptyResult(w.DIFFERENCE, this, a, this.factory) : a.isEmpty() ? this.copy() : (this.checkNotGeometryCollection(this), this.checkNotGeometryCollection(a), ja.overlayOp(this, a, w.DIFFERENCE))
        },
        isSimple: function() {
            return (new Gd(this)).isSimple()
        },
        isWithinDistance: function(a, b) {
            return !(this.getEnvelopeInternal().distance(a.getEnvelopeInternal()) > b) && ib.isWithinDistance(this, a, b)
        },
        distance: function(a) {
            return ib.distance(this, a)
        },
        isEquivalentClass: function(a) {
            return this.getClass() ===
                a.getClass()
        }
    });
    qa.version = "1.4.0 (93f117d)";
    qa.algorithm = Eg;
    qa.densify = Fg;
    qa.dissolve = Gg;
    qa.geom = Dg;
    qa.geomgraph = Hg;
    qa.index = Kg;
    qa.io = Mg;
    qa.noding = Ng;
    qa.operation = Wg;
    qa.precision = Xg;
    qa.simplify = Yg;
    qa.triangulate = $g;
    qa.linearref = ah;
    Object.defineProperty(qa, "__esModule", {
        value: !0
    })
});
var platform = {
    version: "1.0.5-SNAPSHOT",
    buildDate: "2017-09-19 10:29:11"
};
Dialog = {
    defaultPosition: "center",
    dialogsPosition: {},
    dialogsResizedPosition: {},
    dialogTitleHeight: 45,
    resizableDialogs: "popupViewAttachmentImage popupViewAttachmentPdf popupAddFeatureOnDraw popupInfoEditFeature popupInfo popupSearch popupNewSearchFromExisting popupSearchReserve popupSearchFoncier popupCreateNewLayer mapAndToolbarContainer thematicGroupsContainer editLayerMetadataPopup popupGeosign popupAddComments popupAddAttachments editLayerMetadataEditValuesPopup popupSearchComments popupSearchAttachments popupCG34ArbresAddComment popupCG34ArbresOperationMode statisticsReport popupRoadSchematic popupEditLayerAttributes".split(" "),
    dialogPositionArray: [],
    dialogIsClosed: function(a) {
        "undefined" !== typeof ImajnetUI && ImajnetUI && a == ImajnetUI.clipboardContainerId && ImajnetUI.removeActiveState(ImajnetUI.btnEnableClipboardDiv);
        var b = "doWhen" + a + "Closed";
        try {
            if ("function" == typeof window.Dialog[b]) window.Dialog[b]()
        } catch (e) {}
        if (Dialog.dialogExist(a)) try {
            jQuery("#" + a).dialog("destroy")
        } catch (e) {}
    },
    resizeDialogContent: function(a) {
        var b = window.innerHeight,
            e = jQuery("#" + a),
            c = e.parent().width(),
            d = e.parent().height();
        Dialog.dialogsResizedPosition[a] =
            Object({
                width: c,
                height: d
            });
        switch (a) {
            case "popupAddAttachments":
                jQuery("#attachmentsContainer").width(c - 20).height(d - 190);
                jQuery(".attachmentTitle").width(c - 150);
                jQuery(".attachmentDescription").width(c - 150);
                break;
            case "popupAddComments":
                jQuery("#commentsContainer").width(c - 20).height(d - 190);
                jQuery(".commentTitle").width(c - 150);
                jQuery(".commentContent").width(c - 150);
                break;
            case "popupViewAttachmentPdf":
                d = e.height();
                jQuery("#popupViewAttachmentPdfContent").css("width", c - 2);
                jQuery("#popupViewAttachmentPdfContent").css("height",
                    d - 70);
                jQuery("#pdfView").css("width", c - 2);
                jQuery("#pdfView").css("height", d - 95);
                break;
            case "popupViewAttachmentImage":
                d = e.height();
                jQuery("#popupViewAttachmentImageContent").width(c - 20);
                jQuery("#popupViewAttachmentImageContent").height(d - 80);
                jQuery("#attachmentImage").css("max-width", c - 20);
                jQuery("#attachmentImage").css("max-height", d - 85);
                break;
            case "popupSearch":
            case "popupNewSearchFromExisting":
                jQuery("#" + a + "_ResponseContainer").width(c - 20);
                d = e.height();
                "searchAttributes" == Search.searchType ? (d -=
                    jQuery("#" + a + "_LRSConstraintMainContainer").height() + jQuery("#" + a + "_GeographicConstraintMainContainer").height() + jQuery("#" + a + "_LimitByConditionContainer").height() + 185, jQuery("#" + a + "_ResponseContainer").height(d + 20).css("overflow", "hidden"), FeaturesListing.resizeFeaturesListingContainer(a)) : "searchAttachments" == Search.searchType && (d -= 100, jQuery("#attachmentsListingContainer").height(d - 70), jQuery("#" + a + "_ResponseContainer").height(d + 20).css("overflow", "hidden"));
                a = jQuery('table[id\x3d"' + a + "_FeaturesByLayerGrid_" +
                    CommonCore.getLayerNameWithoutWorkspace("popupSearch" == a ? Search.getSearchLayerName("popupNewSearchFromExisting") : jQuery("#popupNewSearchFromExisting_SearchableLayers").val()) + '"]');
                FeaturesListing.setGridWidth(a, c - 45);
                FeaturesListing.setGridHeight(a, d - 180);
                break;
            case "popupSearchReserve":
                b = jQuery("#" + a + "_LRSConstraintContainer");
                d = d - (b.is(":visible") ? b.height() : 0) - jQuery("#" + a + "_LimitByConditionContainer").height() - 210;
                jQuery("#" + a + "_ResponseContainer").height(d).css("overflow", "hidden");
                FeaturesListing.resizeFeaturesListingContainer(a);
                a = jQuery('table[id\x3d"' + a + "_FeaturesByLayerGrid_" + CommonCore.getLayerNameWithoutWorkspace(Reserve.reserveLayerName) + '"]');
                FeaturesListing.setGridWidth(a, c - 45);
                FeaturesListing.setGridHeight(a, d - 220);
                break;
            case "popupSearchFoncier":
                d = d - jQuery("#" + a + "_LimitByConditionContainer").height() - 170;
                jQuery("#searchFoncierResponseContainer").width(c - 22).height(d);
                Foncier.searchFoncierGridContainer && (FeaturesListing.setGridWidth(Foncier.searchFoncierGridContainer.jqGrid(), c - 45), FeaturesListing.setGridHeight(Foncier.searchFoncierGridContainer.jqGrid(),
                    d - 90));
                break;
            case "popupCG34ArbresAddComment":
                jQuery("#popupCG34ArbresAddCommentContainer").width(c - 180).height(d - 140);
                break;
            case "popupCG34ArbresOperationMode":
                jQuery("#popupCG34ArbresOperationModeContent").width(c - 20).height(d - 140);
                break;
            case "popupSearchComments":
                jQuery("#popupSearchCommentsResponseContainer").width(c - 22).height(d - jQuery("#" + a + "_LimitByConditionContainer").height() - 180);
                jQuery(".searchCommentResultItemMiddle").width(c - 330);
                jQuery(".searchCommentResultLayerName").width(c - 590);
                break;
            case "popupSearchAttachments":
                jQuery("#popupSearchAttachmentsResponseContainer").width(c - 22).height(d - jQuery("#" + a + "_LimitByConditionContainer").height() - 180 - (jQuery("#downloadAllAttachments").is(":visible") ? 30 : 0));
                jQuery(".searchAttachmentResultTitle").width(c - 330);
                jQuery(".searchAttachmentResultDescription").width(c - 330);
                break;
            case "popupInfoEditFeature":
                jQuery("#popupInfoEditFeatureContentAttributes").width(c - 272);
                jQuery("#popupInfoEditFeatureContentAttributes").height(d - 230);
                jQuery("#popupInfoEditFeatureListContentTabs").height(d -
                    235);
                jQuery("#popupInfoEditFeature").css("min-width", c + 4);
                jQuery("#infoFeatureLinksTab").height(d - 221);
                c = CommonCore.getFeatureAndLayerForEdit();
                PlatformGraphic.drawFeatureLinks(c.layerName, c.featureId);
                break;
            case "popupInfo":
                d = e.height();
                e.height(d);
                jQuery("#" + a + "Content").width(c - 40).height(d - 10);
                FeaturesListing.resizeFeaturesListingContainer(a);
                a = jQuery(".ui-jqgrid-btable");
                for (d = 0; d < a.length; d++) FeaturesListing.setGridWidth(jQuery(a[d]), c - 45);
                break;
            case "popupAddFeatureOnDraw":
                jQuery("#" + a + "Content").css("width",
                    c - 10);
                jQuery("#" + a + "Content").css("height", d - 130);
                break;
            case "popupImajnet":
                ImajnetUI.onImageResize();
                break;
            case "popupAttachFiles":
                buttonCliked = "";
                break;
            case "popupCreateNewLayer":
                d = e.height();
                jQuery("#newLayerAttributesContainer").height(d - 385);
                jQuery("#newLayerAttributesItemsContainer").height(d - 425);
                MainMethods.resizeNewLayerElements(c);
                break;
            case "popupEditLayerAttributes":
                d = e.height();
                jQuery("#newLayerAttributesContainer").height(d - 90);
                jQuery("#newLayerAttributesItemsContainer").height(d - 130);
                MainMethods.resizeNewLayerElements(c);
                break;
            case "editLayerMetadataPopup":
                d = e.height();
                d > b && (d = b - 100);
                jQuery("#editLayerMetadataAttributesContent").width(c - 10).height(d - 190);
                jQuery(".editLayerMetadataItemInput").width(c - 510);
                break;
            case "editLayerMetadataEditValuesPopup":
                d = e.height();
                jQuery("#attributeValuesContainerHTML").width(c - 40).height(d - 190);
                jQuery(".editLayerMetadataEditValuesPopupContentItem").width(c - 180);
                break;
            case "thematicGroupsContainer":
                MainCore.thematicGroupsContainer.height(d - 45);
                MainCore.thematicGroupsParentContainer.height(d - 45);
                MapMethodsCore.recalculateThematicGroupsDimension();
                break;
            case "popupGeosign":
                jQuery("#popupGeosignContentListing").height(d - 125);
                break;
            case "mapAndToolbarContainer":
                MapMethodsCore.setMapAndLRSSchematicDimension(c, e.height());
                break;
            case "popupRoadSchematic":
                jQuery("#" + a + "Content").height(d - 121), jQuery("#" + a + "Content").width(c), RoadSchematic.onResize(c)
        }
    },
    positionAndResizeMapPopup: function(a, b, e) {
        b++;
        Dialog.dialogExist("map") && (jQuery("#map").dialog("option",
            "height", b), a && jQuery("#map").dialog("option", "width", a - dialogMargins), Dialog.setDialogPosition(jQuery("#map"), [e.left, e.top]));
        a && CommonCore.mapContainer.width(a - dialogMargins);
        CommonCore.mapContainer.height(b - Dialog.dialogTitleHeight - dialogMargins);
        map && map.updateSize();
        CommonCore.addPanZoomBarEvents()
    },
    positionAndResizeImajnetPopup: function(a, b) {
        a++;
        isImajnetMode() && (Dialog.dialogTitleHeight = 0);
        var e = a - Dialog.dialogTitleHeight - dialogMargins,
            c = Math.round(e * ImajnetUI.getImageAspectRatio());
        Dialog.dialogExist(ImajnetUI.imageContainerId) &&
            (jQuery("#" + ImajnetUI.imageContainerId).dialog("option", "width", c), jQuery("#" + ImajnetUI.imageContainerId).dialog("option", "height", a), Dialog.setDialogPosition(jQuery("#" + ImajnetUI.imageContainerId), [Math.ceil(b.left), Math.ceil(b.top)]), ImajnetUI.imageContainer.width(c).height(e), ImajnetUI.resizeImageElements(c, e, !0));
        return c
    },
    positionAndResizeImajnetImageAndMap: function() {
        var a = container.position();
        a.top += getContainerMarginTop();
        var b = Dialog.positionAndResizeImajnetPopup(container.height() * imajnetImageContainerDimensionPercentage.height,
            a);
        Dialog.positionAndResizeMapPopup(container.width() - b - dialogMargins, container.height() * mapContainerDimensionPercentage.height, {
            left: Math.ceil(a.left + b + dialogMargins),
            top: Math.ceil(a.top)
        })
    },
    moveDialogToPosition: function(a) {
        try {
            var b = jQuery("#" + a);
            if (jQuery.isEmptyObject(Dialog.dialogPositionArray[a]))
                if ("undefined" !== typeof ImajnetUI && ImajnetUI && a == ImajnetUI.clipboardContainerId) Dialog.setDialogPosition(b, "right");
                else if ("popupNewSearchFromExisting" == a) {
                var e = jQuery("#popupSearch").dialog("option",
                    "position");
                Dialog.setDialogPosition(b, [e[0] + 200, e[1]])
            } else Dialog.setDialogPosition(b, Dialog.defaultPosition);
            else "popupStyleEditorNewImage" != a && (Dialog.setDialogPosition(b, [Dialog.dialogPositionArray[a].x, 28 > Dialog.dialogPositionArray[a].y && isImajnetMode() ? 28 : Dialog.dialogPositionArray[a].y]), 28 > Dialog.dialogPositionArray[a].y && b.parent().css("top", 28))
        } catch (c) {}
    },
    resizeStyleDialog: function() {
        var a = jQuery(window).height(),
            b = jQuery("#popupStyleEditor");
        if (b.height() > a - 40) try {
            if (b.dialog("option",
                    "height", a - 10), b.css("overflow", "auto"), isImajnetMode()) Dialog.defaultPosition = ["center", 30];
            else {
                Dialog.defaultPosition = "top";
                var e = b.dialog("option", "position");
                Dialog.setDialogPosition(b, [e[0], Dialog.defaultPosition])
            }
        } catch (c) {} else Nigsys.browserIsIE7() && b.addClass("customDialog")
    },
    getDialogButtons: function(a) {
        var b = (CommonCore.isMobile ? "../" : applicationUrl) + "resources/img/";
        return '\x3cdiv class\x3d"dialogButtons"\x3e\x3cdiv class\x3d"collapseDialogButtonContainer dialogButtonsItem"\x3e\x3cimg src\x3d"' +
            b + 'buttons/BTN-FM-3.PNG" /\x3e\x3c/div\x3e\x3cdiv class\x3d"dialogButtonsItem expandDialogButtonContainer"\x3e\x3cimg src\x3d"' + b + 'buttons/BTN-FM-2.PNG" /\x3e\x3c/div\x3e' + (a ? '\x3cdiv class\x3d"dialogButtonsItem fillHeightDialogButtonContainer"\x3e\x3cimg src\x3d"' + b + 'buttons/BTN-FM-1.PNG" /\x3e\x3c/div\x3e\x3cdiv class\x3d"dialogButtonsItem fillScreenDialogButtonContainer"\x3e\x3cimg src\x3d"' + b + 'buttons/BTN-FM-5.PNG" /\x3e\x3c/div\x3e' : "") + "\x3c/div\x3e"
    },
    bindDialogButtonsEvents: function(a) {
        Nigsys.bindClickEvent(a.find(".collapseDialogButtonContainer"),
            Dialog.collapseDialog);
        Nigsys.bindClickEvent(a.find(".expandDialogButtonContainer"), Dialog.expandDialog);
        Nigsys.bindClickEvent(a.find(".fillHeightDialogButtonContainer"), Dialog.fillHeightDialog);
        Nigsys.bindClickEvent(a.find(".fillScreenDialogButtonContainer"), Dialog.fillScreen)
    },
    dialogIsCollapsed: function(a) {
        return jQuery(a).is(":hidden")
    },
    dialogIsResizable: function(a) {
        for (var b = 0; b < Dialog.resizableDialogs.length; b++)
            if (Dialog.resizableDialogs[b] == a) return !0;
        return !1
    },
    setDialogPosition: function(a,
        b) {
        a.dialog("option", "position", b);
        "left" == b ? a.parent().css({
            left: 0
        }) : "top" == b ? a.parent().css({
            top: 0
        }) : !b[0] && 0 != b[0] || !b[1] && 0 != b[1] || a.parent().css({
            top: "top" == b[1] ? 0 : b[1],
            left: "left" == b[0] ? 0 : b[0]
        })
    },
    doWhenDialogExpanded: function(a) {
        Dialog.dialogIsResizable(a.attr("id")) && (a.parent().addClass("dialogResizable"), a.parent().find(".ui-resizable-se").show())
    },
    collapseDialog: function(a) {
        a = jQuery(a.currentTarget.parentNode.parentNode.parentNode.children[1]);
        var b = a.attr("id");
        Dialog.dialogsResizedPosition[b] &&
            Dialog.dialogIsCollapsed(a) ? (Dialog.doWhenDialogExpanded(a), a.parent().addClass("dimensionDialog"), a.dialog("option", "width", Dialog.dialogsResizedPosition[b].width), a.dialog("option", "height", Dialog.dialogsResizedPosition[b].height), Dialog.resizeDialogContent(b)) : (a.parent().removeClass("dimensionDialog").removeClass("dialogResizable").height(0), a.parent().find(".ui-resizable-se").hide(), a.height(0).hide())
    },
    expandDialog: function(a) {
        var b = jQuery(a.currentTarget.parentNode.parentNode.parentNode.children[1]);
        b.parent().addClass("dimensionDialog");
        var e = b.attr("id");
        Dialog.dialogsPosition[e] ? (Dialog.doWhenDialogExpanded(b), b.dialog("option", "width", Dialog.dialogsPosition[e].width), b.dialog("option", "height", Dialog.dialogsPosition[e].height), Dialog.resizeDialogContent(e)) : Dialog.fillHeightDialog(a)
    },
    fillHeightDialog: function(a) {
        a = jQuery(a.currentTarget.parentNode.parentNode.parentNode.children[1]);
        Dialog.doWhenDialogExpanded(a);
        a.parent().addClass("dimensionDialog");
        Dialog.setDialogPosition(a, [a.dialog("option",
            "position")[0], "top"]);
        a.dialog("option", "height", Nigsys.getWindowSize().height);
        Dialog.resizeDialogContent(a.attr("id"));
        jQuery(".expandTable").trigger("click")
    },
    fillScreen: function(a) {
        a = jQuery(a.currentTarget.parentNode.parentNode.parentNode.children[1]);
        a.attr("id");
        Dialog.doWhenDialogExpanded(a);
        a.parent().addClass("dimensionDialog fullScreen");
        Dialog.setDialogPosition(a, [0, 0]);
        var b = Nigsys.getWindowSize();
        a.dialog("option", {
            width: b.width,
            height: b.height
        });
        Dialog.resizeDialogContent(a.attr("id"));
        jQuery(".expandTable").trigger("click")
    },
    dialogResize: function(a) {
        Dialog.resizeDialogContent(a.target.id)
    },
    dialogResizeStop: function(a) {
        a = jQuery("#" + a.target.id);
        a.width(a.parent().width() - parseInt(a.css("padding-left").replace("px", "")) - parseInt(a.css("padding-right").replace("px", "")))
    },
    setDialogZIndex: function(a) {
        jQuery("#" + a).parent().css("z-index", $.ui.dialog.maxZ)
    },
    showDialog: function(a, b, e, c, d, k) {
        Nigsys.hideDialogError(a);
        "undefined" !== typeof ImajnetUI && a == ImajnetUI.imageContainerId && (b || (b =
            ImajnetUI.imajnetImageContainerSize.width), e || (e = ImajnetUI.imajnetImageContainerSize.height));
        if ("undefined" === typeof ImajnetUI || a != ImajnetUI.imageContainerId || "undefined" === typeof MapMethodsCore || !MapMethodsCore.layoutData || MapMethodsCore.layoutData.haveDialogs) {
            var m = Dialog.dialogIsResizable(a);
            if (Dialog.dialogIsOpen(a)) jQuery("#" + a).dialog("moveToTop"), CommonCore.isMobile && Dialog.setDialogZIndex(a);
            else {
                "popupAddFeatureOnDraw" != a && "popupInfoEditFeature" != a || "LRSSchematic" != MapCore.editModeType ||
                    Nigsys.showLoading(container);
                k || (k = "", jQuery.app[a] ? k = jQuery.app[a].title : jQuery.app.map[a] ? k = jQuery.app.map[a].title : jQuery.imajnet[a] && (k = jQuery.imajnet[a].title));
                if (b) {
                    var h = b;
                    c && c > b && (h = c);
                    k.length > h / 9 && (k = k.substring(0, h / 9) + "...")
                } else b = "auto";
                e || (e = "auto");
                var f = jQuery("#" + a),
                    h = f.length ? parseInt(f.css("min-width").replace("px", "")) : 0;
                isImajnetMode() ? "map" == a ? h = "auto" : a !== ImajnetUI.imageContainerId && (h = 330) : "undefined" === typeof ImajnetUI || a != ImajnetUI.imageContainerId && "thematicGroupsContainer" !=
                    a ? "popupCreateNewLayer" == a && (h = 560) : h = "auto";
                var l = 150;
                "popupInfo" == a ? l = 370 : "popupSearch" == a ? l = 470 : "popupAddAttachments" == a ? l = 390 : "popupAddFeatureOnDraw" == a ? l = 400 : "popupCreateNewLayer" == a ? l = 615 : "popupInfoEditFeature" == a ? h = 685 : "editLayerMetadataPopup" == a ? l = 550 : "editLayerMetadataEditValuesPopup" == a ? (h = 500, l = 320) : "popupSearchComments" == a ? h = 530 : "popupSearchAttachments" == a ? h = 530 : "popupCG34ArbresOperationMode" == a ? h = 555 : "popupRoadSchematic" == a && (h = RoadSchematic.dialogWidth);
                Dialog.dialogsPosition[a] = Object({
                    width: b &&
                        "auto" !== b ? b : f.width(),
                    height: e
                });
                Dialog.dialogsResizedPosition[a] = Dialog.dialogsPosition[a];
                b = {
                    title: k,
                    resizable: m,
                    width: b,
                    height: e,
                    minHeight: l,
                    minWidth: h ? h : 350,
                    position: Dialog.defaultPosition,
                    open: function(a, b) {
                        var g = a.target.id;
                        if (isImajnetMode())
                            if (g == ImajnetUI.imageContainerId || "map" == g) {
                                var f = $(this);
                                f.closest(".ui-dialog").find(".ui-dialog-titlebar:first").hide();
                                f.addClass("imajnetDialogNoCorner");
                                f.parent().addClass("imajnetDialogNoCorner")
                            } else "popupSequenceDetails" == g ? jQuery("#" + g).parent().css("z-index",
                                999999) : g == ImajnetUI.newsContainerId && $(this).parent().attr("id", "imajnetNewsDialog");
                        else "popupImajnet" == g ? jQuery("#" + g).parent().children(".ui-dialog-titlebar").addClass("imajnetPopupTitleBar") : "mapAndToolbarContainer" == g ? $(this).closest(".ui-dialog").find(".ui-dialog-titlebar-close").hide() : "popupViewAttachmentImage" == g ? (jQuery("#attachmentImage").css("max-width", c - 1), jQuery("#attachmentImage").css("max-height", d - 110), jQuery("#" + g + "Content").css("max-width", c - 1), jQuery("#" + g + "Content").css("max-height",
                                d - 100)) : "popupViewAttachmentPdf" == g ? (jQuery("#pdfView").css("max-width", c - 1), jQuery("#pdfView").css("max-height", d - 110), jQuery("#" + g + "Content").css("max-width", c - 1), jQuery("#" + g + "Content").css("max-height", d - 100)) : "popupAddFeatureOnDraw" == g ? (jQuery("#" + g + "Content").css("min-width", 510), jQuery("#" + g + "Content").css("min-height", 150)) : "popupInfoEditFeature" == g ? ($(this).parent().attr("id", "popupInfoEditFeatureDialog"), Nigsys.browserIsIE7() || jQuery("#submitAddAttachmentOrComment").css("margin-left", 35)) :
                            "popupExportFeatures" == g ? Export.fillExportTypes() : "popupSearch" == g ? Attachments.previousSearchAttachmentsActionResponse = "" : "popupStyleEditor" == g ? jQuery("#styleEditorTabsContainer").removeClass("ui-widget-content") : "popupOfflineMode" == g ? $(this).parent().attr("id", "popupOfflineModeDialog") : "mapAndToolbarContainer" == g ? $(this).parent().attr("id", "mapAndToolbarContainerDialog") : "popupAddAttachments" == g ? $(this).parent().attr("id", "popupAddAttachmentsDialog") : "popupReservePicture" == g && $(this).parent().attr("id",
                                "popupReservePictureDialog");
                        Dialog.moveDialogToPosition(g);
                        var f = jQuery("#" + g),
                            h = f.parent(),
                            k = h.children(".ui-dialog-titlebar");
                        if (!isImajnetMode() && "map" != g) {
                            try {
                                g == ImajnetUI.imageContainerId ? ApplicationStorage.readObject("layout") || f.dialog("option", "height", e + dialogMargins / 2 + Dialog.dialogTitleHeight) : f.dialog("option", "height", e)
                            } catch (l) {}
                            "popupImajnet" != g && (h.addClass("dimensionDialog"), m && "popupViewAttachmentImage" !== g && h.addClass("dialogResizable"), h.children(".ui-resizable-ne").hide(), h.children(".ui-resizable-n").css("width",
                                "98%"), h.children(".ui-resizable-e").css("height", "98%").css("margin-top", "2%"), k.append(Dialog.getDialogButtons(m)), Dialog.bindDialogButtonsEvents(h))
                        }
                        isImajnetMode() && "popupImajnet" == g && h.prop("id", "popupImajnetDialog");
                        k.addClass("dialogTitleContainer_" + g)
                    },
                    beforeClose: function(a) {
                        return CommonCore.beforeCloseDialog(a.target.id)
                    },
                    resize: function(a, b) {
                        Dialog.dialogResize(a)
                    },
                    resizeStop: function(a, b) {
                        Dialog.dialogResizeStop(a)
                    },
                    dragStop: function(a, b) {
                        jQuery(".ui-autocomplete").hide();
                        "undefined" !==
                        typeof ImajnetUI && ImajnetUI && a.target.id == ImajnetUI.imageContainerId && (ImajnetZoom.setDraggableContainment(), ImajnetUI.setSliderDraggableContainment());
                        if (isImajnetMode() || CommonCore.isMobile) {
                            var c = CommonCore.isMobile ? 0 : 28;
                            b.position.top < c && Dialog.setDialogPosition(jQuery("#" + a.target.id), [b.position.left, c])
                        }
                        "mapAndToolbarContainer" == a.target.id && map.updateSize()
                    }
                };
                CommonCore.isMobile && (b.appendTo = "#container");
                isImajnetMode() && "popupSequenceDetails" == a && (b.position = "top", b.focus = function(a, b) {
                    f.parent().css("z-index",
                        999999)
                });
                "popupImajnet" != a || isImajnetMode() ? f.data("dialog", "true").dialog(b) : f.data("dialog", "true").dialog(b).resizable({
                    alsoResize: jQuery(".imajnetPopupTitleBar").parent(),
                    aspectRatio: ImajnetUI.imageAspectRatio,
                    resize: Dialog.dialogResize
                });
                isImajnetMode() ? a == ImajnetUI.imageContainerId ? (f.dialog("option", "closeOnEscape", !1), f.dialog("option", "resizable", !1), f.dialog("option", "draggable", !1), f.dialog("option", "stack", !1), jQuery("#imajnetImageTitle").hide(), Nigsys.hideImajnetLoading(), CommonCore.showMap(),
                    ImajnetPlugin.showImajnetItem("map"), CheckDockingCookie("header"), CommonCore.applyContainerDimension(), Nigsys.onMobile() && f.parent().addClass("uiDialogOnMobile")) : "map" == a ? (f.dialog("option", "closeOnEscape", !1), f.dialog("option", "resizable", !1), f.dialog("option", "draggable", !1), f.dialog("option", "stack", !1), ImajnetWeb.initTimeframeContainer(), Nigsys.onMobile() && f.parent().addClass("uiDialogOnMobile")) : Dialog.moveDialogToPosition(a) : ("undefined" !== typeof ImajnetUI && a == ImajnetUI.imageContainerId ? CommonCore.applyContainerDimension(CommonCore.mapContainer.height()) :
                    "mapAndToolbarContainer" == a && (f.dialog("option", "stack", !1), f.parent().addClass("mapDialog")), "thematicGroupsContainer" == a ? f.parent().addClass("thematicGroupsContainer") : f.dialog("option", "stack", !0), "undefined" !== typeof MapCore && "LRSSchematic" == MapCore.editModeType ? "popupAddFeatureOnDraw" == a || "popupInfoEditFeature" == a ? f.parent().addClass("dialogModalWithLoading") : "popupAddAttachments" != a && -1 === a.indexOf("popupViewAttachment") && "popupGenerateLink" != a && "popupGenerateAttachmentLink" != a && "popupSearchFoncier" !=
                    a && "popupFoncierSynthese" != a || f.parent().addClass("dialogModalWithLoadingOver") : (f.parent().removeClass("dialogModalWithLoading"), f.parent().removeClass("dialogModalWithLoadingOver")), "wpsSearch" != a && "statisticsReport" != a || f.parent().addClass("dialogModalWithLoadingOver"), Dialog.moveDialogToPosition(a), Dialog.resizeDialogContent(a));
                c && f.dialog("option", "maxWidth", c);
                d && f.dialog("option", "maxHeight", d);
                b = jQuery(".ui-dialog-titlebar");
                b.css("z-index", "2");
                Nigsys.browserIsIE7() || b.css("height", "12px").css("line-height",
                    "12px");
                "popupStyleEditor" != a && "thematicGroupsContainer" != a && f.addClass("customDialog");
                CommonCore.isMobile && f.show()
            }
        }
    },
    hideDialog: function(a, b, e) {
        var c = jQuery.Deferred();
        if (!Dialog.dialogIsOpen(a)) return c.resolve(), c.promise();
        "popupImajnet" == a && ImageControler.currentGraphic && ImageControler.currentGraphic.clearLRSGUIImageOrientation(ImajnetUI.LRSGUI);
        var d = jQuery("#" + a);
        if (!e && Dialog.dialogExist(a)) try {
            var k = d.dialog("widget").position();
            !k || 0 == k.left && 0 == k.top || (Dialog.dialogPositionArray[a] = {}, Dialog.dialogPositionArray[a].x = k.left, Dialog.dialogPositionArray[a].y = k.top)
        } catch (m) {}
        if (b) Dialog.dialogIsClosed(a);
        else if (Dialog.dialogExist(a)) try {
            d.dialog("destroy")
        } catch (m) {}
        "popupAddFeatureOnDraw" == a && (CG34Arbres.onClose(!0), CG34SH.onClose(), PolygonFromPoint.onClose());
        "popup" == a ? (jQuery("#popup").remove(), StyleEditor.checkIfUnsavedFeatures(b, !0).done(function() {
                ThematicGroupsTree.closePopup(!0).done(function() {
                    c.resolve()
                }).fail(function() {
                    c.resolve()
                })
            }).fail(function() {
                ThematicGroupsTree.closePopup(!0).done(function() {
                    c.resolve()
                }).fail(function() {
                    c.resolve()
                })
            }),
            MainCore.currentLayer = "", LayerTimeline.timelineSlider = null) : c.resolve();
        "popupReservePicture" == a && $(".ui-dialog").show();
        CommonCore.isMobile && d.hide();
        return c.promise()
    },
    closeAllDialogs: function() {
        for (var a = jQuery.Deferred(), b = [], e = jQuery(".popupTemplate"), c = 0; c < e.length; c++) "popupAddFeatureOnDraw" != e[c].id && "popupInfoEditFeature" != e[c].id && "popupStyleEditor" != e[c].id && "popupSaveWFST" != e[c].id && b.push(Dialog.hideDialog(e[c].id, !0));
        "undefined" !== typeof Feature && b.push(Feature.closePopupInfoEditFeature(!0));
        jQuery.when.apply($, b).done(function() {
            a.resolve()
        }).fail(function(b) {
            a.reject()
        });
        return a.promise()
    },
    dialogExist: function(a) {
        return jQuery("#" + a).is(":data(dialog)")
    },
    dialogIsOpen: function(a) {
        try {
            return Dialog.dialogExist(a) && jQuery("#" + a).dialog("isOpen")
        } catch (b) {
            return !1
        }
    },
    doWhenpopupAddFeatureOnDrawClosed: function() {
        MapMethodsCore.popupAddFeatureOnDrawRemove()
    },
    doWhenpopupExportFeaturesClosed: function() {
        Export.closePopupExportFeatures()
    },
    doWhenpopupPrintClosed: function() {
        Print.disablePrint()
    },
    doWhenpopupClosed: function() {
        Nigsys.browserIsIE7() || Nigsys.browserIsIE8() || "map" == CommonCore.page && jQuery.each(map.layers, function(a, b) {
            if ("undefined" != typeof map.layers[a].params && map.layers[a].params.LAYERS == MainCore.currentLayer) return map.layers[a].setOpacity((100 - Main.initialLayerOpacity) / 100), !1
        });
        MainCore.currentLayer = "";
        LayerTimeline.timelineSlider = null;
        MainCore.editLayerMetadataAttributes = null;
        MainCore.editLayerMetadataParent = null
    },
    doWhenpopupAddAttachmentsClosed: function() {
        CommonCore.buttonClicked =
            "";
        cancelAddAttachments = !0;
        MainCore.addAttachmentIncrementor = 0;
        Nigsys.hideLoading(jQuery("#popupAddAttachments"))
    },
    doWhenpopupInfoClosed: function() {
        FeaturesListing.gridNameChanged = [];
        FeaturesListing.gridFeaturesChangedAttributesIds = [];
        MapMethodsCore.featuresDrawBox.features && ImajnetPlugin.removeAllFeatures(MapMethodsCore.featuresDrawBox.features);
        Feature.infoFeaturesTableGeometryChanged = !1;
        MapMethodsCore.removeZoomedWfsFromMap();
        FeaturesListing.removeSelectedFeaturesOnMap();
        MapMethodsCore.clearDrawLayer()
    },
    doWhenpopupInfoEditFeatureClosed: function() {
        CG34Arbres.onClose(!1);
        CG34SH.onClose();
        PolygonFromPoint.onClose();
        map && (MapMethodsCore.removeZoomedWfsFromMap(), draw && "drawFeature" == CommonCore.buttonClicked && draw.setActive(!0));
        CommonCore.buttonClicked = "";
        Feature.removeGetFeatureControl();
        "LRSSchematic" == MapCore.editModeType && Nigsys.hideLoading(container)
    },
    doWhenpopupSearchClosed: function() {
        MainMethodsCore.logoutImajnetNotActive(!0);
        Search.cancelSearch();
        jQuery("#popupSearch_ResponseContainer").html("");
        FeaturesListing.removeSelectedFeaturesOnMap("popupSearch");
        Search.removeGeographicConstraintSelectTool("popupSearch", !0)
    },
    doWhenpopupNewSearchFromExistingClosed: function() {
        jQuery("#popupNewSearchFromExisting_ResponseContainer").html("");
        FeaturesListing.removeSelectedFeaturesOnMap("popupNewSearchFromExisting");
        Search.removeGeographicConstraintSelectTool("popupNewSearchFromExisting", !0)
    },
    doWhenpopupSearchReserveClosed: function() {
        MainMethodsCore.logoutImajnetNotActive(!0);
        Reserve.onClose()
    },
    doWhenpopupSearchFoncierClosed: function() {
        Foncier.onClose();
        MapMethodsCore.removeZoomedWfsFromMap()
    },
    doWhenpopupViewAttachmentPdfClosed: function() {
        jQuery("#popupViewAttachmentPdfContent").children("iframe").remove()
    },
    doWhenpopupInsertGPSPositionClosed: function() {
        CommonCore.deactivateButton("olControlInsertGPSPosition")
    },
    doWhenpopupInsertLRSLineClosed: function() {
        CommonCore.deactivateButton("olControlInsertLRSLine")
    },
    doWhengenerateStyleRulesPopupClosed: function() {
        generateStyleRulesPopupRemove()
    },
    doWhensearchLRSContainerClosed: function() {
        MainMethodsCore.logoutImajnetNotActive(!0)
    },
    doWhenpopupMeasureClosed: function() {
        CommonCore.disableMeasurement();
        isImajnetMode() && Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage");
        CommonCore.activateMapClick()
    },
    doWhenpopupMeasureSurfaceClosed: function() {
        CommonCore.disableSurfaceMeasurement();
        isImajnetMode() && Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage");
        CommonCore.activateMapClick()
    },
    doWhenpopupOfflineModeClosed: function() {
        Nigsys.disableEventPropagation(event);
        MapCacheUtil.stopSeeding();
        MainMobile.deactivateWMSExtentDraw();
        Nigsys.hideLoading(container)
    },
    doWhenpopupRoadSchematicClosed: function() {
        MapMethodsCore.popupRoadSchematicRemove()
    },
    doWhenpopupGeosignClosed: function() {
        MapMethodsCore.popupGeosignRemove()
    },
    doWhenpopupImajnetClosed: function() {
        ImajnetMap.hideOrientation();
        ImajnetMap.hideImajboxMarker();
        ImajnetAPI.imajnetOrderRequest && ImajnetAPI.imajnetOrderRequest.abort();
        ImajnetMap.currentPosition = null;
        ImajnetUrl.changeUrlParam(ImajnetUrl.LOCATION_URL_PARAM_NAME, "", !0)
    }
};
var map = null,
    container = null;
CommonCore = {
    currentMapViewIndex: -1,
    mapViewsArray: [],
    isFromNavigationHistory: !1,
    isMobile: !1,
    devMode: !1,
    userInfo: null,
    geometryPropertyName: "the_geom",
    map: null,
    editor: null,
    currentEditorActiveControl: null,
    page: "map",
    container: null,
    loadingContainer: null,
    mapContainer: null,
    measureLine: null,
    measureSurface: null,
    sphericalMercatorExtent: [-2.003750834E7, -2.003750834E7, 2.003750834E7, 2.003750834E7],
    wgs84Crs: "EPSG:4326",
    customerCrs: "EPSG:4326",
    sphericalMercatorCrs: "EPSG:900913",
    lambertCrs: "EPSG:2154",
    numZoomLevels: 25,
    bodyMargins: 0,
    buttonClicked: "",
    BING_TYPE_ROAD: "Road",
    BING_TYPE_SATELLITE: "Aerial",
    BING_TYPE_HYBRID: "AerialWithLabels",
    notificationLoginContainer: null,
    mapMinZoom: 0,
    zoomBar: null,
    zoomBox: null,
    projHash: {},
    searchReserveButton: null,
    polygonFromPointButton: null,
    searchFoncierButton: null,
    navigation: null,
    platformMapInitialized: $.Deferred(),
    overviewMap: null,
    dialogNamesArray: "popupInfo popupMeasure popupMeasureSurface popupInfoEditFeature popupSearchReserve popupSearchFoncier popupFoncierSynthese popupSearchComments popupSearchAttachments".split(" "),
    mapMousePosition: null,
    lastMouseCoordinateX: 0,
    lastMouseCoordinateY: 0,
    mapClickHandlerDisabled: !1,
    bingApiKey: "",
    attachmentOrCommentSelected: "attachment",
    boxControl: {},
    measurementLayer: null,
    mapMainMenuChooseMap: null,
    mapMainMenuChooseMapItems: null,
    mapMainMenuWindowModes: null,
    mapMainMenuWindowModesItems: null,
    currentMeasurement: 0,
    lineMeasureComponentsLength: 2,
    groupBounds: null,
    baseLayersMaxZoom: 20,
    lastBaseLayer: null,
    lastBaseLayerName: null,
    currentBaseLayerName: null,
    LRSMeasurementIsFirstPoint: !0,
    LRSMeasurementFirstPoint: null,
    LRSMeasurementFirstPointLRS: null,
    LRSMeasurementSecondPointLRS: null,
    LRSMeasurementFeatureWrapperPoint: null,
    LRSMeasurementFeatureWrapperFirstPoint: null,
    LRSMeasurementFeatureWrapperSecondPoint: null,
    LRSMeasurementFeatureWrapperLine: null,
    mapClickType: "",
    isWMSLayer: function(a) {
        return a.getSource() instanceof ol.source.TileWMS
    },
    isWFSLayer: function(a) {
        return a.getSource() instanceof ol.source.Vector
    },
    getLayerNameWithoutWorkspace: function(a) {
        if (a) {
            a = a.toString();
            var b = a.indexOf(":");
            return -1 == b ? a : a.substring(b +
                1, a.length)
        }
        return ""
    },
    getLayerNameFromFeatureId: function(a) {
        return a ? a.toString().split(".")[0] : (console.log("No feature id"), "")
    },
    activateInfo: function() {
        CommonCore.isMobile && app.isOnline() && !appSettings.settings.offlineMode && jQuery("#menuSaveWFSTPanel").is(":visible") ? ImajnetUI.showNotificationInfoOk(jQuery.app.notifications.infoSaveOfflineData, "", "center") : MainMethodsCore.checkForUnsavedData(MainMethodsCore.ASK_FOR_SAVE_EDIT).done(function(a, b) {
            if (b) MainMethodsCore.deactivateAskForSave(MainMethodsCore.ASK_FOR_SAVE_EDIT),
                CommonCore.onInfoPressed();
            else if (a) MapCore.saveChangedFeatures().done(function() {
                CommonCore.onInfoPressed()
            });
            else CommonCore.onInfoPressed()
        })
    },
    deactivateInfo: function() {
        CommonCore.buttonClicked = "";
        "undefined" !== typeof MapMethodsCore && MapMethodsCore.removeBoxControl("features", null);
        Dialog.hideDialog("popupInfo", !0);
        CommonCore.deactivateButton("olControlInfoFeatures")
    },
    imajnetIsActive: function() {
        return isImajnetMode() || "FULL" == CommonCore.userInfo.imajnetSubscriptionType
    },
    getFeatureValuePopupHTMLBlue: function(a) {
        return '\x3cdiv class\x3d"infoFeatureItem semibold15Blue"\x3e\x3cdiv class\x3d"left "\x3e' +
            Nigsys.escapeHtml(a) + '\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft popupInfoFeatureClearLeft"\x3e\x3c/div\x3e'
    },
    getFeatureInfoPopupItemHTMLId: function(a, b, c) {
        return '\x3cdiv class\x3d"infoFeatureItem"\x3e\x3cdiv id\x3d"' + c + '" class\x3d"left imajnetInfoFeatureLabel"\x3e\x26nbsp;' + a + '\x3c/div\x3e\x3cdiv class\x3d"left popupFeatureInfoItemValue" style\x3d"max-width:270px;"\x3e' + Nigsys.escapeHtml(b) + '\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft popupInfoFeatureClearLeft"\x3e\x3c/div\x3e'
    },
    getFeatureInfoPopupContentBlue: function(a, b, c) {
        a = "";
        c = LRS.getLabelsValueFromSettings(b[3].value, "referential");
        "admin" == ImajnetUser.data.role.name || -1 < ImajnetUser.data.role.name.indexOf("imajnet-") ? (a += CommonCore.getFeatureInfoPopupItemHTMLId("" + c.roadLabel + ":", b[1].value, "infoFeatureItemRoad"), a += CommonCore.getFeatureInfoPopupItemHTMLId(jQuery.app.map.popupFeatureInfo[b[2].key], b[2].value, "infoFeatureItemSection")) : a += CommonCore.getFeatureInfoPopupItemHTMLId("" + c.roadLabel + ":", b[0].value, "infoFeatureItemRoad");
        return '\x3cdiv class\x3d"popupFeatureInfo"  onclick\x3d"jQuery(this).remove();"\x3e\x3cdiv class\x3d"imajnetPopupFeatureInfoContainer"\x3e' + ("undefined" === typeof b[0].value ? CommonCore.getFeatureValuePopupHTMLBlue(b[1].value) : CommonCore.getFeatureValuePopupHTMLBlue(b[0].value)) + '\x3cdiv id\x3d"popupFeatureInfoLRS"\x3e\x3c/div\x3e' + a + "\x3c/div\x3e\x3c/div\x3e"
    },
    getFeatureInfoPopupContentPR: function(a, b, c) {
        a = LRS.getLabelsValueFromSettings(b[3].value, "referential");
        return '\x3cdiv class\x3d"popupFeatureInfo" onclick\x3d"jQuery(this).remove();"\x3e\x3cdiv class\x3d"imajnetPopupFeatureInfoContainer"\x3e' +
            CommonCore.getFeatureValuePopupHTMLBlue(b[1].value) + '\x3cdiv id\x3d"popupFeatureInfoLRSPRAbs"\x3e\x3c/div\x3e\x3cdiv id\x3d"popupFeatureInfoLRSPR"\x3e\x3c/div\x3e' + CommonCore.getFeatureInfoPopupItemHTMLId("" + a.relativePointLabel + ":", b[0].value, "infoFeaturePr") + CommonCore.getFeatureInfoPopupItemHTMLId("" + a.roadLabel + ":", b[2].value, "infoFeatureItemRoad") + "\x3c/div\x3e\x3c/div\x3e"
    },
    getLRSFieldsForPopup: function(a) {
        var b = LRS.getLabelsValueFromSettings(a.road.type, "referential"),
            c = "";
        a.relativeAbscisa &&
            (c += CommonCore.getFeatureValuePopupHTMLBlue("" + a.keyPoint.prNumber + "+" + Math.round(a.relativeAbscisa) + ""));
        a.cumulatedAbscisa && ImajnetLRSSettings.LRSSettings.display.addressAndLRS.imajnetSettingsLRSShowCumulated && (c += CommonCore.getFeatureInfoPopupItemHTMLId(b.cumulatedAbscisaLabel + ":", Math.round(a.cumulatedAbscisa), "infoFeatureDist"));
        return c
    },
    getLRSFieldsForPopupPR: function(a) {
        var b = LRS.getLabelsValueFromSettings(a.road.type, "referential"),
            c = "";
        a.cumulatedAbscisa && ImajnetLRSSettings.LRSSettings.display.addressAndLRS.imajnetSettingsLRSShowCumulated &&
            (c += CommonCore.getFeatureInfoPopupItemHTMLId(b.cumulatedAbscisaLabel + ":", Math.round(a.cumulatedAbscisa), "infoFeatureDist"));
        return c
    },
    getLRSFieldsForPopupPRAbs: function(a) {
        var b = "";
        a.relativeAbscisa && (b += CommonCore.getFeatureValuePopupHTMLBlue("" + a.keyPoint.prNumber + "+" + Math.round(a.relativeAbscisa) + ""));
        return b
    },
    onSpanCheckboxClick: function(a) {
        $(a.currentTarget).hasClass("checkboxAsSpanChecked") ? $(a.currentTarget).removeClass("checkboxAsSpanChecked") : $(a.currentTarget).addClass("checkboxAsSpanChecked")
    },
    deleteLastChar: function(a) {
        return a.substring(0, a.length - 1)
    },
    initProj4js: function() {
        if ("undefined" !== typeof Proj4js && Proj4js) {
            "map" != CommonCore.page && "searchReserves" != CommonCore.page || isImajnetMode() || (Proj4js.defs[CommonCore.lambertCrs] = "+proj\x3dlcc +lat_1\x3d49 +lat_2\x3d44 +lat_0\x3d46.5 +lon_0\x3d3 +x_0\x3d700000 +y_0\x3d6600000 +ellps\x3dGRS80 +towgs84\x3d0,0,0,0,0,0,0 +units\x3dm +no_defs");
            for (var a in Proj4js.defs)
                if ("EPSG:32632" != a || "map" == CommonCore.page && !isImajnetMode()) "EPSG:3785" ==
                    a && (CommonCore.projHash[CommonCore.sphericalMercatorCrs] = new Proj4js.Proj(a)), CommonCore.projHash[a] = new Proj4js.Proj(a)
        }
    },
    removeFeatureInfo: function() {
        jQuery(".popupFeatureInfo").remove()
    },
    changePredefinedZoom: function(a, b) {
        0 < b ? (ImajnetPlugin.zoomMapTo(b), isImajnetMode() && ImajnetPlugin.centerMapToPosition({
                lon: ImajnetMap.currentPosition.lon,
                lat: ImajnetMap.currentPosition.lat
            }), CommonCore.deactivateButton("olControlGeneralView")) : CommonCore.groupBounds ? (map.getView().fit(CommonCore.groupBounds), CommonCore.enableGeneralView()) :
            ImajnetPlugin.zoomMapTo(10);
        jQuery("#predefinedZoomLevelsValue").html(a.html());
        jQuery(".buttonExpandedDiv").hide();
        CommonCore.buttonClicked = "";
        jQuery("#predefinedZoomDropDownDiv").hide()
    },
    showHidePredefinedZoomDropDown: function() {
        jQuery("#predefinedZoomDropDownDiv").is(":visible") ? (jQuery("#predefinedZoomDropDownDiv").hide(), CommonCore.buttonClicked = "") : ImajnetUI.docking.imajnetMapButtons ? ImajnetUI.showAndPositionInside(ImajnetUI.docking.imajnetMapButtons.mainContainer, jQuery("#predefinedZoomDropDownDiv")) :
            jQuery("#predefinedZoomDropDownDiv").show()
    },
    showHideDropDownDiv: function(a) {
        a ? ("searchDropDownButton" != a.target.id && jQuery("#searchDropDownDiv").hide(), "predefinedZoomLevelsValue" != a.target.id && "predefinedZoomDropDownDiv" != a.target.id && jQuery("#predefinedZoomDropDownDiv").hide(), 0 === jQuery("#allLayersTitleContainer").has(a.target).length && jQuery("#allLayersEditPopup").hide()) : (jQuery("#searchDropDownDiv").hide(), jQuery("#predefinedZoomDropDownDiv").hide());
        a && "SELECT" !== a.target.nodeName && "string" ===
            typeof a.target.className && -1 === a.target.className.indexOf("selectboxit") && jQuery(".selectboxit-options").hide()
    },
    buttonIsActive: function(a) {
        return 0 != jQuery("." + a + "ItemActive").length
    },
    enableGeneralView: function() {
        "undefined" !== typeof generalViewButton && generalViewButton && CommonCore.activateButton("olControlGeneralView")
    },
    activateButton: function(a) {
        CommonCore.buttonIsInactive(a) && jQuery("." + a + "ItemInactive").attr("class", a + "ItemActive")
    },
    buttonIsInactive: function(a) {
        return 0 != jQuery("." + a + "ItemInactive").length
    },
    deactivateButton: function(a) {
        CommonCore.buttonIsActive(a) && jQuery("." + a + "ItemActive").attr("class", a + "ItemInactive")
    },
    isBaseMap: function(a) {
        return "emptyBaseLayer" == a || a == ImajnetUrl.OSM_LAYER_PARAM_NAME || a == ImajnetUrl.OSMMAPNIK_LAYER_PARAM_NAME || a == ImajnetUrl.OCM_LAYER_PARAM_NAME || a == ImajnetUrl.OTM_LAYER_PARAM_NAME || a == ImajnetUrl.BING_ROAD_LAYER_PARAM_NAME || a == ImajnetUrl.BING_SATELLITE_LAYER_PARAM_NAME || a == ImajnetUrl.BING_HYBRID_LAYER_PARAM_NAME
    },
    disableGeneralView: function() {
        "undefined" !== typeof generalViewButton &&
            generalViewButton && CommonCore.deactivateButton("olControlGeneralView")
    },
    getPartialLineMeasurement: function(a) {
        var b = "",
            b = a.measure < lastSegmentMeasurement ? 1E3 * a.measure - lastSegmentMeasurement : a.measure - lastSegmentMeasurement;
        return b.toFixed(3)
    },
    onInfoPressed: function() {
        CommonCore.disableCommonControls("info");
        CommonCore.buttonClicked = "info";
        MapMethodsCore.addBoxSelectToMap("features", MapCore.onInfoSelectBoxDrawComplete);
        CommonCore.activateButton("olControlInfoFeatures")
    },
    showMap: function() {
        CommonCore.mapContainer.css("opacity",
            "1")
    },
    getContainerDimension: function(a) {
        var b = Nigsys.getWindowSize(),
            c = b.height - ("undefined" !== typeof footer && footer ? footer.height() : 0) - CommonCore.bodyMargins;
        isImajnetMode() ? ((a || 0 == a) && container && container.length && container.css("margin-top", a), c -= getContainerMarginTop()) : c -= "undefined" !== typeof header && header ? header.height() : 0;
        return {
            width: b.width - CommonCore.bodyMargins,
            height: c
        }
    },
    onApplyContainerDimension: function(a, b) {
        var c = CommonCore.getContainerDimension(a);
        container && container.length && (container.width(c.width),
            container.height(c.height), CommonCore.mapMainMenuChooseMapItems.css("max-height", c.height - 80));
        b && (Nigsys.positionNotificationCenter(), Nigsys.positionLoginNotificationErrorCenter(), Nigsys.positionLoginNotificationCenter());
        try {
            ImajnetUI.computeImageAspectRatio(), isImajnetMode() && Dialog.positionAndResizeImajnetImageAndMap(), Nigsys.getCookie("IMAJNET", "DOCKING_imageButtons_position") || ImajnetUI.docking.imageButtons.mainContainer.css("top", parseInt(ImajnetUI.imajnetImageContainerSize.height / 2 - ImajnetUI.docking.imageButtons.css.height /
                2)), Nigsys.getCookie("IMAJNET", "DOCKING_imageLRSGUI_position") || ImajnetUI.docking.imageLRSGUI.mainContainer.css("top", parseInt(ImajnetUI.imajnetImageContainerSize.height / 2 - ImajnetUI.docking.imageLRSGUI.css.height / 2)), ImajnetUI.setSliderDraggableContainment()
        } catch (e) {}
        360 > CommonCore.mapContainer.width() ? jQuery("#imajnetDockingMainContainer_imajnetTimeframe").hide() : jQuery("#imajnetDockingMainContainer_imajnetTimeframe").show();
        return c
    },
    applyContainerDimension: function(a, b) {
        CommonCore.onApplyContainerDimension(a,
            b);
        Nigsys.onMobile() && setTimeout("CommonCore.onApplyContainerDimension('" + a + "', '" + b + "')", 300)
    },
    isValidBaseLayer: function(a) {
        return a == ImajnetUrl.OSM_LAYER_PARAM_NAME || a == ImajnetUrl.OSMMAPNIK_LAYER_PARAM_NAME || a == ImajnetUrl.OCM_LAYER_PARAM_NAME || a == ImajnetUrl.OTM_LAYER_PARAM_NAME || a == ImajnetUrl.BING_ROAD_LAYER_PARAM_NAME || a == ImajnetUrl.BING_SATELLITE_LAYER_PARAM_NAME || a == ImajnetUrl.BING_HYBRID_LAYER_PARAM_NAME || a == ImajnetUrl.GOOGLE_ROAD_LAYER_PARAM_NAME || a == ImajnetUrl.GOOGLE_SATELLITE_LAYER_PARAM_NAME ||
            a == ImajnetUrl.GOOGLE_HYBRID_LAYER_PARAM_NAME
    },
    getBaseLayerName: function() {
        var a = ImajnetUrl.getUrlParamValue(ImajnetUrl.MAP_URL_PARAM_NAME);
        if (a && CommonCore.isValidBaseLayer(a)) return a;
        if (isImajnetMode()) {
            var b = Nigsys.getCookie("IMAJNET", "SETTINGS_MAP_TYPE");
            return CommonCore.isValidBaseLayer(b) ? b : ImajnetUrl.OSM_LAYER_PARAM_NAME
        }
        b = Nigsys.getCookie("WEB_APP", "OPTIONS_BASE_LAYER");
        return CommonCore.isValidBaseLayer(a) ? b : ""
    },
    setBaseLayerCookie: function(a) {
        isImajnetMode() ? Nigsys.setCookie("IMAJNET", "SETTINGS_MAP_TYPE",
            a) : Nigsys.setCookie("WEB_APP", "OPTIONS_BASE_LAYER", a)
    },
    removeAttributionLinks: function() {
        CommonCore.isMobile && jQuery(".olControlAttribution a").prop("href", "javascript: void(0);")
    },
    mapBaseLayerChangeHandler: function(a) {
        if (a) {
            var b = "";
            a.target.id == "set" + ImajnetUrl.OSM_LAYER_PARAM_NAME ? b = ImajnetUrl.OSM_LAYER_PARAM_NAME : a.target.id == "set" + ImajnetUrl.OCM_LAYER_PARAM_NAME ? b = ImajnetUrl.OCM_LAYER_PARAM_NAME : a.target.id == "set" + ImajnetUrl.OTM_LAYER_PARAM_NAME ? b = ImajnetUrl.OTM_LAYER_PARAM_NAME : a.target.id ==
                "set" + ImajnetUrl.BING_ROAD_LAYER_PARAM_NAME ? b = ImajnetUrl.BING_ROAD_LAYER_PARAM_NAME : a.target.id == "set" + ImajnetUrl.BING_SATELLITE_LAYER_PARAM_NAME ? b = ImajnetUrl.BING_SATELLITE_LAYER_PARAM_NAME : a.target.id == "set" + ImajnetUrl.BING_HYBRID_LAYER_PARAM_NAME ? b = ImajnetUrl.BING_HYBRID_LAYER_PARAM_NAME : a.target.id == "set" + ImajnetUrl.GOOGLE_ROAD_LAYER_PARAM_NAME ? b = ImajnetUrl.GOOGLE_ROAD_LAYER_PARAM_NAME : a.target.id == "set" + ImajnetUrl.GOOGLE_SATELLITE_LAYER_PARAM_NAME ? b = ImajnetUrl.GOOGLE_SATELLITE_LAYER_PARAM_NAME :
                a.target.id == "set" + ImajnetUrl.GOOGLE_HYBRID_LAYER_PARAM_NAME && (b = ImajnetUrl.GOOGLE_HYBRID_LAYER_PARAM_NAME);
            ImajnetUrl.changeUrlParam(ImajnetUrl.MAP_URL_PARAM_NAME, b);
            CommonCore.setBaseLayerCookie(b)
        }
        CommonCore.updateOverviewMap();
        CommonCore.removeAttributionLinks()
    },
    isEmptyBaseLayer: function(a) {
        return "emptyBaseLayer" == a
    },
    canSetBaseLayer: function() {
        return !CommonCore.isMobile || app.isOnline()
    },
    onCheckForUnsavedDataThematicGroup: function(a, b, c, e, d, f) {
        MainMethodsCore.haveUnsavedData(MainMethodsCore.ASK_FOR_SAVE_LAYER_SETTINGS) ?
            ThematicGroupsTree.closePopup(a, b, c, e).done(function() {
                MainMethodsCore.checkForUnsavedData(MainMethodsCore.ASK_FOR_SAVE_THEMATIC_GROUP, {
                    reloadAfterSave: e
                }).done(function(a) {
                    d(f)
                })
            }).fail(function() {
                MainMethodsCore.checkForUnsavedData(MainMethodsCore.ASK_FOR_SAVE_THEMATIC_GROUP, {
                    reloadAfterSave: e
                }).done(function(a) {
                    d(f)
                })
            }) : MainMethodsCore.checkForUnsavedData(MainMethodsCore.ASK_FOR_SAVE_THEMATIC_GROUP, {
                reloadAfterSave: e
            }).done(function(a) {
                d(f)
            })
    },
    checkForUnsavedDataThematicGroup: function(a, b, c, e,
        d, f) {
        if (MainMethodsCore.haveUnsavedData(MainMethodsCore.ASK_FOR_SAVE_LAYER_METADATA_VALUES)) ThematicGroupsTree.closeMetadataValuesPopup(!0, curentLayerMetadata).done(function() {
            MainMethodsCore.haveUnsavedData(MainMethodsCore.ASK_FOR_SAVE_LAYER_METADATA) && ThematicGroupsTree.closeMetadataPopup(!0, {
                layerName: MainCore.currentLayer
            }).done(function() {
                CommonCore.onCheckForUnsavedDataThematicGroup(a, b, c, e, d, f)
            }).fail(function() {
                CommonCore.onCheckForUnsavedDataThematicGroup(a, b, c, e, d, f)
            })
        }).fail(function() {
            MainMethodsCore.haveUnsavedData(MainMethodsCore.ASK_FOR_SAVE_LAYER_METADATA) &&
                ThematicGroupsTree.closeMetadataPopup(!0, {
                    layerName: MainCore.currentLayer
                }).done(function() {
                    CommonCore.onCheckForUnsavedDataThematicGroup(a, b, c, e, d, f)
                }).fail(function() {
                    CommonCore.onCheckForUnsavedDataThematicGroup(a, b, c, e, d, f)
                })
        });
        else CommonCore.onCheckForUnsavedDataThematicGroup(a, b, c, e, d, f)
    },
    bindGroupEvents: function(a) {
        if (!CommonCore.isMobile || app.isOnline() && !appSettings.settings.offlineMode || jQuery("#thematicGroupsTreeDiv_" + a).hasClass("groupIsCached")) {
            var b = jQuery("#thematicGroupsTreeDiv_" +
                    a + " a:first-child"),
                c = "click";
            CommonCore.isMobile && (c = "tap");
            b.off().on(c, function(b) {
                b.preventDefault();
                jQuery(".groupActionsContainer").remove();
                jQuery("#rightExportMenu").hide();
                jQuery("#rightExportSubmenu").hide();
                if (a == ThematicGroupsTreeCore.lastValidGroupId && !CommonCore.isMobile) {
                    var c = document.createElement("div");
                    c.setAttribute("class", "groupActionsContainer");
                    c.appendChild(MainMethodsCore.getNewImageElement("", "layerActionsItem button left", applicationUrl + "resources/img/buttons/BTN-CC4.PNG",
                        25, 25, jQuery.app.map.featuresListing.buttonExport,
                        function() {
                            Export.showExportRightMenu(a, b, "Export.exportGroup")
                        }));
                    jQuery(b.target).parent().parent().parent().append(c);
                    return !1
                }
                if (CommonCore.isMobile && a == ThematicGroupsTreeCore.clickedThematicGroupId) ThematicGroupsTree.onGroupTap();
                else CommonCore.isMobile || (ImajnetUrl.changeUrlParam(ImajnetUrl.POSITION_URL_PARAM_NAME, ""), ImajnetUrl.changeUrlParam(ImajnetUrl.ZOOM_URL_PARAM_NAME, "")), "map" == CommonCore.page ? ThematicGroupsTreeCore.fillGroup(a) : CommonCore.checkForUnsavedDataThematicGroup(!0,
                    Main.layerSettingsIsGeoserverLayer, !0, !0, ThematicGroupsTreeCore.fillGroup, a)
            })
        }
    },
    activateImage: function(a) {
        a.src = a.src.replace("Off", "On")
    },
    deactivateImage: function(a) {
        a.src = a.src.replace("On", "Off")
    },
    onMapChanged: function(a) {
        for (var b = document.getElementsByClassName("mapMainMenuChooseMapItemImage"), c = 0; c < b.length; c++) CommonCore.deactivateImage(b[c]);
        a || (a = Object({
            currentTarget: document.getElementById("set" + ImajnetUrl.urlParams[ImajnetUrl.MAP_URL_PARAM_NAME])
        }));
        CommonCore.activateImage(a.currentTarget)
    },
    onHaveEmptyBaseLayer: function(a) {
        CommonCore.mapMainMenuChooseMapItems.hide();
        CommonCore.isMobile && (a = jQuery("#WMSCacheZoomEnd"), a.find('option[value\x3d"19"]').prop("disabled", !1), a.find('option[value\x3d"20"]').prop("disabled", !1), a.val(20 < CommonCore.numZoomLevels ? 20 : CommonCore.numZoomLevels - 1).selectmenu("refresh"))
    },
    onHaveBaseLayer: function(a) {
        CommonCore.mapMainMenuChooseMapItems.hide();
        if (CommonCore.isMobile) {
            var b = jQuery("#WMSCacheZoomEnd");
            b.find('option[value\x3d"19"]').prop("disabled", !0);
            b.find('option[value\x3d"20"]').prop("disabled", !0);
            b.val(18).selectmenu("refresh")
        }
        CommonCore.mapBaseLayerChangeHandler(a)
    },
    getSearchDialogContent: function(a) {
        return '\x3cdiv id\x3d"' + a + '" class\x3d"popupTemplate"\x3e\x3cdiv class\x3d"popupContentContainer" style\x3d"height: 35px;"\x3e\x3cdiv class\x3d"left"\x3e\x3cinput type\x3d"button" value\x3d"' + jQuery.app.map.button.search + '" onclick\x3d"Search.searchMore(\'' + a + '\', false, false);" class\x3d"dialogButton buttonSearch" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e\x3cdiv class\x3d"left"\x3e\x3cinput type\x3d"button" value\x3d"' +
            jQuery.app.button.cancel + '" onclick\x3d"Dialog.hideDialog(\'' + a + '\', true);" class\x3d"dialogButton dialogButtonCancel" /\x3e\x3c/div\x3e\x3cdiv id\x3d"' + a + 'TotalResults" class\x3d"left searchTotalRecords"\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"' + a + 'LimitByConditionContainer"\x3e\x3c/div\x3e\x3cdiv id\x3d"' + a + 'ResponseContainer" class\x3d"searchResponseContainer scrollable"\x3e\x3c/div\x3e\x3c/div\x3e'
    },
    getDialogHTML: function(a) {
        return "popupInfo" == a ?
            '\x3cdiv id\x3d"' + a + '"\x3e\x3cdiv id\x3d"popupInfoContent" class\x3d"popupContent scrollable"\x3e\x3c/div\x3e\x3c/div\x3e' : "popupMeasure" == a ? '\x3cdiv id\x3d"' + a + '" class\x3d"popupTemplate"\x3e\x3cdiv id\x3d"popupLineMeasureTabs" class\x3d"popupMeasureContent"\x3e\x3cul id\x3d"popupLineMeasureTabsUL"\x3e\x3cli class\x3d"tabsLi"\x3e\x3ca href\x3d"#simpleMeasurementTab" class\x3d"tabs"\x3e' + jQuery.app.map.popupMeasure.simple + '\x3c/a\x3e\x3c/li\x3e\x3cli class\x3d"tabsLi"\x3e\x3ca href\x3d"#LRSMeasurementTab" class\x3d"tabs"\x3e' +
            jQuery.app.map.popupMeasure.LRS + '\x3c/a\x3e\x3c/li\x3e\x3c/ul\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv id\x3d"simpleMeasurementTab" class\x3d"mainTabContent"\x3e\x3cdiv class\x3d"totalMeasurement"\x3e\x3cdiv class\x3d"left dialogContentTitle measurementItemLabel"\x3e' + jQuery.app.map.popupMeasure.text + ':\x3c/div\x3e\x3cdiv id\x3d"popupMeasureContentText" class\x3d"left"\x3e 0\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"lastSegmentMeasurement" style\x3d"display: none; margin-top: 3px;"\x3e\x3cdiv class\x3d"left dialogContentTitle measurementItemLabel"\x3e' +
            jQuery.app.map.popupMeasure.lastSegment + ':\x3c/div\x3e\x3cdiv id\x3d"lastSegmentMeasurementText" class\x3d"left"\x3e 0\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"LRSMeasurementTab" class\x3d"mainTabContent"\x3e\x3cdiv class\x3d"left dialogContentTitle measurementItemLabel"\x3e' + jQuery.app.map.popupMeasure.road + ':\x3c/div\x3e\x3cdiv id\x3d"LRSMeasurementRoad" class\x3d"left"\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv class\x3d"left dialogContentTitle measurementItemLabel"\x3e' +
            jQuery.app.map.popupMeasure.text + ':\x3c/div\x3e\x3cdiv id\x3d"LRSMeasurementValue" class\x3d"left"\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e' : "popupMeasureSurface" == a ? '\x3cdiv id\x3d"' + a + '" class\x3d"popupTemplate"\x3e\x3cdiv class\x3d"popupMeasureSurfaceContent"\x3e\x3cdiv class\x3d"totalMeasurement"\x3e\x3cdiv class\x3d"left dialogContentTitle" style\x3d"margin-right: 20px;"\x3e' + jQuery.app.map.popupMeasureSurface.textSurface + ':\x3c/div\x3e\x3cdiv id\x3d"popupMeasureSurfaceContentText" class\x3d"left"\x3e 0\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e' :
            "popupInfoEditFeature" == a ? '\x3cdiv id\x3d"' + a + '" class\x3d"popupTemplate" style\x3d"min-width: 600px;"\x3e\x3cdiv id\x3d"popupInfoEditFeatureContentTabs"\x3e\x3cdiv class\x3d"left"\x3e\x3cul id\x3d"infoEditFeatureTabs"\x3e\x3cli class\x3d"tabsLi"\x3e\x3ca href\x3d"#infoFeatureTab" class\x3d"tabs"\x3e' + jQuery.app.map.popupInfoEditFeature.edit + '\x3c/a\x3e\x3c/li\x3e\x3cli class\x3d"tabsLi"\x3e\x3ca href\x3d"#infoFeatureLinksTab" class\x3d"tabs"\x3e' + jQuery.app.map.popupInfoEditFeature.links + '\x3c/a\x3e\x3c/li\x3e\x3c/ul\x3e\x3c/div\x3e\x3cdiv class\x3d"left"\x3e\x3cinput type\x3d"hidden" id\x3d"feature_to_edit_LAYER_NAME" value\x3d"" /\x3e\x3cdiv id\x3d"feature_to_edit_FID" class\x3d"semibold14Blue"\x3e\x3c/div\x3e\x3cdiv id\x3d"feature_to_edit_representativeField" class\x3d"semibold14Blue"\x3e\x3c/div\x3e' +
            ("undefined" !== typeof Foncier ? '\x3cdiv class\x3d"right" style\x3d"margin-top: 3px;"\x3e\x3cinput type\x3d"button" id\x3d"idFoncierInfo" value\x3d"' + jQuery.foncier.foncierInfo + '"class\x3d"dialogButton hidden" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e' : "") + '\x3cdiv class\x3d"right" style\x3d"margin-top: 3px;"\x3e\x3cinput type\x3d"button" id\x3d"generateFeatureReport" value\x3d"' + jQuery.app.generateReport + '"class\x3d"dialogButton hidden" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"clear"\x3e\x3c/div\x3e\x3cdiv id\x3d"infoFeatureTab" class\x3d"tabContentContainer"\x3e\x3cdiv id\x3d"popupInfoEditFeatureContentAttributes" class\x3d"scrollable dialogWhite50" style\x3d"clear: both"\x3e\x3c/div\x3e\x3cdiv id\x3d"popupInfoEditFeatureListContentTabs"\x3e\x3cdiv\x3e\x3cul id\x3d"popupInfoEditFeatureListTabs"\x3e\x3cli class\x3d"tabsLi"\x3e\x3ca href\x3d"#popupInfoEditFeatureAttachmentsTab" class\x3d"tabs attachmentTab"\x3e' +
            jQuery.app.attachments.title + '\x3c/a\x3e\x3c/li\x3e\x3cli id\x3d"popupInfoEditFeatureCommentsTabLi" class\x3d"tabsLi"\x3e\x3ca href\x3d"#popupInfoEditFeatureCommentsTab" class\x3d"tabs commentTab"\x3e' + jQuery.app.comments.title + '\x3c/a\x3e\x3c/li\x3e\x3c/ul\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv id\x3d"popupInfoEditFeatureAttachmentsTab" class\x3d"tabContentContainer"\x3e\x3c/div\x3e\x3cdiv id\x3d"popupInfoEditFeatureCommentsTab" class\x3d"tabContentContainer"\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"infoFeatureLinksTab" class\x3d"tabContentContainer"\x3e\x3c/div\x3e\x3cdiv id\x3d"' +
            a + 'DialogErrorsContainer" class\x3d"dialogErrorsContainer"\x3e\x3cdiv class\x3d"dialogErrorsInnerContainer"\x3e\x3cdiv class\x3d"left dialogErrorsCloseContainer"\x3e\x3cimg id\x3d"' + a + 'DialogErrorsClose" class\x3d"dialogErrorsClose" src\x3d"' + (CommonCore.isMobile ? "../" : applicationUrl) + 'resources/img/buttons/BTN-FF7.PNG" /\x3e\x3c/div\x3e\x3cdiv id\x3d"' + a + 'Errors" class\x3d"errors errorsText left"\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"popupInfoEditFeatureButtons"\x3e\x3cdiv class\x3d"left"\x3e\x3cdiv\x3e\x3cinput type\x3d"button" id\x3d"popupInfoEditFeatureButtongenerateLink" value\x3d"' +
            jQuery.app.button.viewLink + '" class\x3d"dialogWhiteButton buttonViewLink" /\x3e\x3cinput type\x3d"button" id\x3d"popupInfoEditFeatureButtonZoomToFeature" value\x3d"' + jQuery.app.button.zoomToFeature + '" class\x3d"dialogWhiteButton buttonZoomToFeature" /\x3e\x3c/div\x3e\x3cdiv style\x3d"margin-top: 10px; "\x3e\x3cinput type\x3d"button" id\x3d"popupInfoEditFeatureButtonEditGeometrySave" value\x3d"' + jQuery.app.button.editGeometry + '" class\x3d"dialogWhiteButton buttonEditGeometry" /\x3e' + (CommonCore.isMobile ?
                "" : '\x3cselect id\x3d"popupInfoEditFeature_ExportSelect" class\x3d"dialogWhiteButton featuresListingExport"\x3e\x3c/select\x3e') + '\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"right" style\x3d"margin-right: 20px;"\x3e\x3cdiv\x3e\x3cinput type\x3d"button" id\x3d"submitAddAttachmentOrComment" value\x3d"' + jQuery.app.attachments.buttonAddTitle + '" class\x3d"dialogWhiteButton buttonAddAttachment" disabled\x3d"disabled" /\x3e\x3c/div\x3e\x3cdiv style\x3d"margin-top: 10px; "\x3e\x3cinput type\x3d"button" value\x3d"' +
            jQuery.app.button.cancel + '" onclick\x3d"Feature.closePopupInfoEditFeature(true);" class\x3d"dialogButton dialogButtonCancel" /\x3e\x3cinput id\x3d"popupInfoEditFeatureButtonSave" type\x3d"button" value\x3d"' + jQuery.app.button.save + '" class\x3d"dialogButton dialogButtonSave" disabled\x3d"disabled" /\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv style\x3d"display: none;" class\x3d"right" id\x3d"idReserveSearch" onclick\x3d"Reserve.searchById()"\x3e\x3cimg src\x3d"' + applicationUrl + 'resources/img/buttons/BTN-O23_Haut.PNG" title\x3d"' +
            jQuery.app.map.button.searchReserve + '"/\x3e\x3c/div\x3e' + ("undefined" !== typeof CG34Arbres && CG34Arbres ? '\x3cdiv style\x3d"display: none;" class\x3d"right" id\x3d"CG34ArbresSearchChantiers" onclick\x3d"CG34Arbres.searchChantiers()"\x3e\x3cimg src\x3d"' + applicationUrl + 'resources/img/buttons/BTN-CG34Arbres_Haut.PNG" title\x3d"' + jQuery.cg34Arbres.button.searchChantiers + '"/\x3e\x3c/div\x3e' : "") + ("undefined" !== typeof Razel && Razel ? '\x3cdiv style\x3d"display: none;" class\x3d"right" id\x3d"RazelSearchChantiers" onclick\x3d"Razel.searchChantiers()"\x3e\x3cimg src\x3d"' +
                applicationUrl + 'resources/img/buttons/BTN-Razel_Haut.PNG" title\x3d"' + jQuery.razel.searchOperations + '"/\x3e\x3c/div\x3e\x3cdiv style\x3d"display: none;" class\x3d"right" id\x3d"RazelSearchOperationNodes" onclick\x3d"Razel.searchOperationNodes()"\x3e\x3cimg src\x3d"' + applicationUrl + 'resources/img/buttons/BTN-Razel_Haut.PNG" title\x3d"' + jQuery.razel.searchNodes + '"/\x3e\x3c/div\x3e\x3cdiv style\x3d"display: none;" class\x3d"right" id\x3d"RazelSearchOperationDMSR" onclick\x3d"Razel.searchOperationDMSR()"\x3e\x3cimg src\x3d"' +
                applicationUrl + 'resources/img/buttons/BTN-Razel_Haut.PNG" title\x3d"' + jQuery.razel.searchDMSR + '"/\x3e\x3c/div\x3e\x3cdiv class\x3d"clear"\x3e\x3c/div\x3e' : "") + "\x3c/div\x3e\x3c/div\x3e" : "popupSearchReserve" == a ? '\x3cdiv id\x3d"' + a + '" class\x3d"popupTemplate"\x3e\x3cdiv style\x3d"height: 35px;"\x3e\x3cdiv class\x3d"popupContentContainer"\x3e\x3cdiv class\x3d"left"\x3e\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 20px; margin-top: -3px;"\x3e\x3cinput type\x3d"button" value\x3d"' + jQuery.app.button.cancel +
            '" onclick\x3d"Dialog.hideDialog(\'popupSearchReserve\', true);" class\x3d"dialogButton buttonCancel" /\x3e\x3cinput type\x3d"button" value\x3d"' + jQuery.app.map.button.search + '" onclick\x3d"Reserve.search();" class\x3d"dialogButton buttonSearch" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"popupSearchReserveLRSConstraintMainContainer"\x3e\x3cdiv class\x3d"separator optionsGroup"\x3e\x3cdiv class\x3d"left"\x3e\x3cinput type\x3d"checkbox" id\x3d"popupSearchReserve_LRSConstraintCheckbox" onchange\x3d"Search.showHideLRSConstraintSearch(\'popupSearchReserve\');" /\x3e\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 10px;"\x3e' +
            jQuery.app.map.featuresListing.LRSConstraintTitle + '\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv id\x3d"popupSearchReserve_LRSConstraintContainer" style\x3d"display: none;"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"popupSearchReserveLimitByConditionContainer"\x3e\x3c/div\x3e\x3cdiv id\x3d"' + a + '_ResponseContainer" class\x3d"searchResponseContainer scrollable dialogBorder"\x3e\x3c/div\x3e\x3c/div\x3e' : "popupSearchFoncier" == a && "undefined" !== typeof Foncier ? '\x3cdiv id\x3d"' +
            a + '" class\x3d"popupTemplate"\x3e\x3cdiv style\x3d"height: 35px;"\x3e\x3cdiv class\x3d"popupContentContainer"\x3e\x3cdiv class\x3d"left"\x3e\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 20px; margin-top: -3px;"\x3e\x3cinput type\x3d"button" value\x3d"' + jQuery.app.button.cancel + '" onclick\x3d"Dialog.hideDialog(\'popupSearchFoncier\', true);" class\x3d"dialogButton dialogButtonCancel" /\x3e\x3cinput type\x3d"button" value\x3d"' + jQuery.app.map.button.search + '" onclick\x3d"Foncier.search();" class\x3d"dialogButton buttonSearch" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e\x3cdiv class\x3d"right" style\x3d"margin-left: 20px; margin-top: -3px;"\x3e\x3cinput type\x3d"button" id\x3d"idAccesDonnes" value\x3d"' +
            jQuery.foncier.accesDonnesSynthese + '" onclick\x3d"Foncier.accesDonnesSynthese();" class\x3d"dialogButton" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"popupSearchFoncierLimitByConditionContainer"\x3e\x3c/div\x3e\x3cdiv id\x3d"searchFoncierResponseContainer" class\x3d"searchResponseContainer scrollable"\x3e\x3ctable id\x3d"searchFoncierGrid"\x3e\x3c/table\x3e\x3cdiv id\x3d"searchFoncierPagination"\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e' :
            "popupFoncierSynthese" == a && "undefined" !== typeof Foncier ? '\x3cdiv id\x3d"' + a + '" class\x3d"popupTemplate"\x3e\x3cdiv style\x3d"height: 35px;"\x3e\x3cdiv class\x3d"popupContentContainer"\x3e\x3cform method\x3d"post" action\x3d"' + applicationUrl + 'foncier/statistics/generateReport?format\x3dHTML" id\x3d"formSynthese" target\x3d"_blank"\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 20px; margin-top: -3px;"\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 20px; margin-top: -3px;"\x3e  Format  \x3c/div\x3e\x3cselect id\x3d"idSelectFormat" style\x3d"margin-left: 30px; margin-top: -3px;"\x3e\x3coption value\x3d"HTML"\x3eHTML\x3c/option\x3e\x3coption value\x3d"PDF"\x3ePDF\x3c/option\x3e\x3coption value\x3d"EXCEL"\x3eEXCEL\x3c/option\x3e\x3c/select\x3e\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-right: 1px; margin-top: -3px;"\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 30px; margin-top: -3px;"\x3e' +
            jQuery.foncier.anneSynthese + '\x3c/div\x3e\x3cselect id\x3d"idSelectAnne" style\x3d"margin-left: 30px; margin-top: -3px;"\x3e\x3coption value\x3d"2016"\x3e2016\x3c/option\x3e\x3coption value\x3d"2015" selected\x3e2015\x3c/option\x3e\x3c/select\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 20px; margin-top: 6px;"\x3e\x3cinput type\x3d"button" id\x3d"idSyntheseAnne" value\x3d"' + jQuery.foncier.voirSyntheseAnne + '" onclick\x3d"Foncier.anneDonnesSynthese();" class\x3d"dialogButton" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e\x3cdiv\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 20px; margin-top: 12px;"\x3e\x3cinput type\x3d"button" id\x3d"idSyntheseDomaine" value\x3d"' +
            jQuery.foncier.voirSyntheseDomaine + '" onclick\x3d"Foncier.donnesSyntheseDomaine();" class\x3d"dialogButton" /\x3e\x26nbsp;\x26nbsp;\x3c/div\x3e\x3c/div\x3e\x3c/form\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e' : "popupSearchComments" == a || "popupSearchAttachments" == a ? CommonCore.getSearchDialogContent(a) : ""
    },
    getFeatureAndLayerForEdit: function() {
        return {
            layerName: MainCore.getLayerNameWithWorkspace(jQuery("#feature_to_edit_LAYER_NAME").val()),
            featureId: jQuery("#feature_to_edit_FID").html()
        }
    },
    disableMeasurement: function() {
        CommonCore.measureLine &&
            (CommonCore.deactivateMeasureLine(), CommonCore.resetLRSMeasurement(), CommonCore.unregisterLRSMeasurementClickEvent(), CommonCore.unregisterLRSMeasurementMouseMoveEvent(), CommonCore.deactivateButton("olControlMeasureLineFeatures"), "measureLine" == CommonCore.buttonClicked && (CommonCore.buttonClicked = ""))
    },
    disableSurfaceMeasurement: function() {
        CommonCore.measureSurface && (CommonCore.deactivateMeasureSurface(), CommonCore.deactivateButton("olControlMeasureSurfaceFeatures"), "measureSurface" == CommonCore.buttonClicked &&
            (CommonCore.buttonClicked = ""))
    },
    resetLRSMeasurement: function() {
        CommonCore.LRSMeasurementIsFirstPoint = !0;
        CommonCore.LRSMeasurementFirstPoint = null;
        CommonCore.LRSMeasurementFirstPointLRS = null;
        CommonCore.LRSMeasurementSecondPointLRS = null;
        jQuery("#LRSMeasurementRoad").html("");
        jQuery("#LRSMeasurementValue").html("");
        CommonCore.resetLRSMeasurementGeometry()
    },
    LRSMeasurementMapClick: function(a) {
        CommonCore.LRSMeasurementIsFirstPoint ? (jQuery("#LRSMeasurementRoad").html(""), jQuery("#LRSMeasurementValue").html(""),
            CommonCore.resetLRSMeasurementGeometry(), CommonCore.LRSMeasurementIsFirstPoint = !1, CommonCore.LRSMeasurementFirstPoint = a, LRSRequest.getLRSForPoints(Array({
                lon: a.lon,
                lat: a.lat,
                height: 0
            }), !0, !1).done(function(a) {
                a.linearPosition && a.linearPosition[0] ? (CommonCore.LRSMeasurementFirstPointLRS = a.linearPosition[0], jQuery("#LRSMeasurementRoad").html(a.linearPosition[0].road.name)) : CommonCore.resetLRSMeasurement()
            }).fail(function() {
                CommonCore.resetLRSMeasurement()
            })) : (CommonCore.LRSMeasurementIsFirstPoint = !0,
            LRSRequest.getLRSForPoints(Array({
                lon: a.lon,
                lat: a.lat,
                height: 0
            }), !0, !1).done(function(a) {
                a.linearPosition && a.linearPosition[0] ? (CommonCore.LRSMeasurementSecondPointLRS = LRS.getLRSByRoadId(a.linearPosition, CommonCore.LRSMeasurementFirstPointLRS.road.id), CommonCore.LRSMeasurementSecondPointLRS ? LRS.getGeometryFromLRS(LRS.getLRSToGeometrySearchObject(CommonCore.LRSMeasurementFirstPointLRS.road.name, CommonCore.LRSMeasurementFirstPointLRS.keyPoint.prNumber, CommonCore.LRSMeasurementFirstPointLRS.relativeAbscisa,
                    CommonCore.LRSMeasurementSecondPointLRS.keyPoint.prNumber, CommonCore.LRSMeasurementSecondPointLRS.relativeAbscisa, !1)).done(function(a) {
                    if (a.roadTopology && a.roadTopology[0] && a.roadTopology[0].topology) CommonCore.onLRSMeasurementComplete(a.roadTopology[0].topology);
                    else CommonCore.resetLRSMeasurement()
                }).fail(function(a) {
                    CommonCore.resetLRSMeasurement()
                }) : CommonCore.resetLRSMeasurement()) : CommonCore.resetLRSMeasurement()
            }).fail(function() {
                CommonCore.resetLRSMeasurement()
            }))
    },
    onMeasureLineTabsChange: function(a) {
        "simpleMeasurementTab" ==
        a ? (CommonCore.activateMeasureLine(), CommonCore.unregisterLRSMeasurementClickEvent(), CommonCore.unregisterLRSMeasurementMouseMoveEvent()) : "LRSMeasurementTab" == a && (CommonCore.deactivateMeasureLine(), CommonCore.registerLRSMeasurementClickEvent(), CommonCore.registerLRSMeasurementMouseMoveEvent())
    },
    appendDialogs: function() {
        for (var a = "", b = 0; b < CommonCore.dialogNamesArray.length; b++) a += CommonCore.getDialogHTML(CommonCore.dialogNamesArray[b]);
        $("body").append(a);
        jQuery("#popupInfoEditFeatureContentTabs").tabs({
            activate: function(a,
                b) {
                if (b.newPanel[0] && "infoFeatureTab" != b.newPanel[0].id && "infoFeatureLinksTab" == b.newPanel[0].id) {
                    var d = CommonCore.getFeatureAndLayerForEdit();
                    Feature.drawFeatureLinks(d.layerName, d.featureId)
                }
            }
        });
        jQuery("#infoEditFeatureTabs").removeClass("ui-widget-header");
        jQuery("#popupInfoEditFeatureListContentTabs").tabs({
            activate: function(a, b) {
                if (b.newPanel[0]) {
                    var d = CommonCore.getFeatureAndLayerForEdit();
                    "popupInfoEditFeatureAttachmentsTab" == b.newPanel[0].id ? (CommonCore.attachmentOrCommentSelected = "attachment",
                        Attachments.fillAttachments(d.layerName, d.featureId, !0), jQuery("#submitAddAttachmentOrComment").val(jQuery.app.attachments.buttonAddTitle)) : "popupInfoEditFeatureCommentsTab" == b.newPanel[0].id && (CommonCore.attachmentOrCommentSelected = "comment", Comments.fillComments(d.layerName, d.featureId, !0), jQuery("#submitAddAttachmentOrComment").val(jQuery.app.comments.buttonAddTitle))
                }
            }
        });
        jQuery("#popupInfoEditFeatureListTabs").removeClass("ui-widget-header");
        jQuery("#popupLineMeasureTabs").tabs({
            activate: function(a,
                b) {
                if (b.newPanel[0]) CommonCore.onMeasureLineTabsChange(b.newPanel[0].id)
            }
        });
        jQuery("#popupLineMeasureTabsUL").removeClass("ui-widget-header")
    },
    changeLanguageHTML: function() {
        languageBar.css("background-image", 'url("' + applicationUrl + "resources/img/language/BTN_LG_" + localeLanguage + '_Actif.png")')
    },
    initLanguageBar: function() {
        CommonCore.isMobile || (languageBar = jQuery("#languageBar"), languageBarComplete = jQuery("#languageBarComplete"), Nigsys.bindClickEvent(languageBar, function(a) {
            a.preventDefault();
            languageBar.hide();
            languageBarComplete.show()
        }), Nigsys.bindClickEvent(languageBarComplete, function(a) {
            a.preventDefault();
            languageBarComplete.hide();
            languageBar.show()
        }), Nigsys.bindClickEvent(jQuery(".languageItemImage"), function(a) {
            a.preventDefault();
            a = a.target.id.replace("languageItemImage_", "");
            a == localeLanguage ? (languageBarComplete.hide(), languageBar.show()) : ImajnetUrl.changeLocale(a)
        }), CommonCore.changeLanguageHTML())
    },
    bindEventsOnGUIModesElements: function() {
        Nigsys.bindClickEvent(jQuery("#windowMode1"), function(a) {
            MapMethodsCore.applyImageLayout({
                index: 0,
                percent: 4,
                layersContainerPosition: "left",
                haveDialogs: !0
            }, !1)
        });
        Nigsys.bindClickEvent(jQuery("#windowMode2"), function(a) {
            MapMethodsCore.applyImageLayout({
                index: 1,
                percent: 2,
                layersContainerPosition: "bottom"
            }, !1)
        });
        Nigsys.bindClickEvent(jQuery("#windowMode3"), function(a) {
            MapMethodsCore.applyImageLayout(null, !1)
        });
        Nigsys.bindClickEvent(jQuery("#windowMode4"), function(a) {
            MapMethodsCore.applyImageLayout({
                index: 2,
                percent: 2,
                layersContainerPosition: "right"
            }, !1)
        });
        Nigsys.bindClickEvent(jQuery("#windowMode5"),
            function(a) {
                MapMethodsCore.applyImageLayout({
                    index: 3,
                    percent: 4,
                    layersContainerPosition: "left"
                }, !1)
            })
    },
    initHTMLContainers: function() {
        CommonCore.appendDialogs();
        header = jQuery("#header");
        container = jQuery(".container");
        container.prop("id", "container");
        CommonCore.mapContainer = jQuery("#map");
        "undefined" !== typeof LRSSchematic && (LRSSchematic.container = jQuery("#LRSSchematic"));
        CommonCore.loadingContainer = jQuery("#loadingContainer");
        "map" == CommonCore.page && (CommonCore.mapMainMenuChooseMap = jQuery("#mapMainMenuChooseMap"),
            CommonCore.mapMainMenuChooseMapItems = jQuery("#mapMainMenuChooseMapItems"), CommonCore.mapMainMenuWindowModes = jQuery("#mapMainMenuWindowModes"), CommonCore.mapMainMenuWindowModesItems = jQuery("#mapMainMenuWindowModesItems"), CommonCore.bindEventsOnMapElements(), CommonCore.bindEventsOnGUIModesElements());
        CommonCore.bindCustomRadio($("input:radio"));
        CommonCore.initLanguageBar()
    },
    bindCustomRadio: function(a, b, c) {
        a.iCheck({
            checkedRadioClass: "checkedRadio",
            uncheckedRadioClass: "uncheckedRadio"
        }).on("ifClicked",
            function(a) {
                "function" === typeof b && b(c, a)
            })
    },
    bindCustomCheckbox: function(a, b, c) {
        a.iCheck({
            checkedCheckboxClass: "checkedCheckbox",
            uncheckedCheckboxClass: "uncheckedCheckbox"
        }).on("ifChanged", function(a) {
            "function" === typeof b && b(c, a)
        })
    },
    updateCustomCheckbox: function(a) {
        a.iCheck("update")
    },
    bindCustomSelect: function(a) {
        a.selectBoxIt()
    },
    refreshCustomSelect: function(a) {
        a && a.data("selectBox-selectBoxIt") && a.data("selectBox-selectBoxIt").refresh()
    },
    activateControl: function(a) {
        "undefined" !== typeof controls &&
            controls && controls[a].activate()
    },
    deactivateControl: function(a) {
        "undefined" !== typeof controls && controls && controls[a].deactivate()
    },
    onMapReady: function() {
        CommonCore.isMobile || LRSSchematic.init()
    },
    getLibsPath: function() {
        return CommonCore.isMobile && !MainCore.isWeb ? clientAppUrl + "../resources/" : applicationUrl + "resources/"
    },
    initCommonElements: function() {
        CommonCore.isMobile && jQuery("#helpButtonLink").prop("href", "http://immergis.fr/help/Manuel_utilisateur_" + themeName + ".pdf");
        if (CommonCore.isMobile || Nigsys.onMobile()) CommonCore.mapMainMenuChooseMap.on("vclick",
            function(a) {
                CommonCore.mapMainMenuChooseMapItems.is(":visible") ? CommonCore.mapMainMenuChooseMapItems.hide() : CommonCore.mapMainMenuChooseMapItems.show()
            });
        else CommonCore.mapMainMenuChooseMap.on("mouseover", function(a) {
            CommonCore.canSetBaseLayer() && CommonCore.mapMainMenuChooseMapItems.show()
        }), CommonCore.mapMainMenuChooseMap.on("mouseout", function(a) {
            CommonCore.mapMainMenuChooseMapItems.hide()
        }), CommonCore.mapMainMenuWindowModes.on("mouseover", function(a) {
            CommonCore.mapMainMenuWindowModesItems.show()
        }).on("mouseout",
            function(a) {
                CommonCore.mapMainMenuWindowModesItems.hide()
            });
        CommonCore.mapContainer.width(Nigsys.getWindowSize().width);
        CommonCore.mapContainer.height(Nigsys.getWindowSize().height)
    },
    getPredefinedZoomLevelsHTML: function() {
        return '\x3cdiv id\x3d"predefinedZoomLevels" class\x3d"imajnetPredefinedZoomLevels"\x3e' + (CommonCore.isMobile ? '\x3cdiv id\x3d"predefinedZoomLevelsValue"\x3e' + $.app.map.button.predefinedZoom.title + "\x3c/div\x3e" : "") + '\x3cdiv id\x3d"predefinedZoomDropDownDiv" class\x3d"expandableToolbarDiv imajnetPredefinedZoomDropDownDiv' +
            (CommonCore.isMobile ? " buttonExpandedDiv" : "") + '"\x3e\x3cdiv id\x3d"predefinedZoomDropDownDivItem1" class\x3d"expandableToolbarDivItem"\x3e' + jQuery.app.map.button.predefinedZoom.title + '\x3c/div\x3e\x3cdiv id\x3d"predefinedZoomDropDownDivItem2" class\x3d"expandableToolbarDivItem"\x3e' + jQuery.app.map.button.predefinedZoom.region + '\x3c/div\x3e\x3cdiv id\x3d"predefinedZoomDropDownDivItem3" class\x3d"expandableToolbarDivItem"\x3e' + jQuery.app.map.button.predefinedZoom.department + '\x3c/div\x3e\x3cdiv id\x3d"predefinedZoomDropDownDivItem4" class\x3d"expandableToolbarDivItem"\x3e' +
            jQuery.app.map.button.predefinedZoom.interTown + '\x3c/div\x3e\x3cdiv id\x3d"predefinedZoomDropDownDivItem5" class\x3d"expandableToolbarDivItem"\x3e' + jQuery.app.map.button.predefinedZoom.town + '\x3c/div\x3e\x3cdiv id\x3d"predefinedZoomDropDownDivItem6" class\x3d"expandableToolbarDivItem"\x3e' + jQuery.app.map.button.predefinedZoom.neighborhood + '\x3c/div\x3e\x3cdiv id\x3d"predefinedZoomDropDownDivItem7" class\x3d"expandableToolbarDivItem"\x3e' + jQuery.app.map.button.predefinedZoom.street + "\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e"
    },
    bindPredefinedZoomLevelsEvents: function() {
        Nigsys.bindClickEvent(jQuery("#predefinedZoomDropDownDivItem1"), function(a) {
            Nigsys.disableEventPropagation(a);
            CommonCore.changePredefinedZoom(jQuery(a.target), "")
        });
        Nigsys.bindClickEvent(jQuery("#predefinedZoomDropDownDivItem2"), function(a) {
            Nigsys.disableEventPropagation(a);
            CommonCore.changePredefinedZoom(jQuery(a.target), 9)
        });
        Nigsys.bindClickEvent(jQuery("#predefinedZoomDropDownDivItem3"), function(a) {
            Nigsys.disableEventPropagation(a);
            CommonCore.changePredefinedZoom(jQuery(a.target),
                10)
        });
        Nigsys.bindClickEvent(jQuery("#predefinedZoomDropDownDivItem4"), function(a) {
            Nigsys.disableEventPropagation(a);
            CommonCore.changePredefinedZoom(jQuery(a.target), 12)
        });
        Nigsys.bindClickEvent(jQuery("#predefinedZoomDropDownDivItem5"), function(a) {
            Nigsys.disableEventPropagation(a);
            CommonCore.changePredefinedZoom(jQuery(a.target), 14)
        });
        Nigsys.bindClickEvent(jQuery("#predefinedZoomDropDownDivItem6"), function(a) {
            Nigsys.disableEventPropagation(a);
            CommonCore.changePredefinedZoom(jQuery(a.target), 16)
        });
        Nigsys.bindClickEvent(jQuery("#predefinedZoomDropDownDivItem7"), function(a) {
            Nigsys.disableEventPropagation(a);
            CommonCore.changePredefinedZoom(jQuery(a.target), 18)
        });
        Nigsys.onMobile() ? (jQuery("#predefinedZoomLevels").corner("4px"), Nigsys.bindClickEvent(jQuery("#predefinedZoomLevels"), CommonCore.showHidePredefinedZoomDropDown)) : jQuery("#predefinedZoomLevels").bind({
            mouseenter: function() {
                ImajnetUI.docking.imajnetMapButtons ? ImajnetUI.showAndPositionInside(ImajnetUI.docking.imajnetMapButtons.mainContainer,
                    jQuery("#predefinedZoomDropDownDiv")) : jQuery("#predefinedZoomDropDownDiv").show()
            },
            mouseleave: function() {
                jQuery("#predefinedZoomDropDownDiv").hide()
            }
        });
        Nigsys.browserIsIE7() || Nigsys.browserIsIE8() ? Nigsys.browserIsIE7() && jQuery("#predefinedZoomDropDownDiv").css("position", "relative") : jQuery("#predefinedZoomDropDownDiv").corner()
    },
    initToolbars: function() {
        "map" == CommonCore.page && (CommonCore.isMobile || (ImajnetMapImplementation.createMapControls(), CommonCore.bindPredefinedZoomLevelsEvents()), CommonCore.addMapCommonControls())
    },
    initImajnetElements: function() {
        CommonCore.devMode && (CommonCore.bingApiKey = "Agn_cMsUjKBHOmbzzQmjejOgWenze-tP8Uu4moKwbp0-_kXf5oaMzCidZKDWFDaZ");
        CommonCore.initCommonElements();
        jQuery(window).resize(function(a, c) {
            if (c) return !1;
            CommonCore.applyContainerDimension(null, !0)
        });
        var a = {
            serverUrl: applicationDomain + "service",
            cartographicServerUrl: Nigsys.removeLastCharacter(applicationDomain),
            username: null,
            password: null,
            containerId: container.prop("id"),
            map: map,
            activateImajnet: !0,
            clipboardActive: !0,
            goToClosestPointOfInterest: !0,
            sessionType: "FULL",
            applicationKey: "QAM+wpe4v6va87UGNb/apH/bDivp/qcEqNMFNTLOjN6jEysZ3shYDQ8iQIVu727TMVie39gcYtMzLojsiJjVWA\x3d\x3d"
        };
        Imajnet.init(a).done(function() {
            ImajnetUserSettings.mapExtent && "undefined" !== typeof ThematicGroupsTreeCore && (CommonCore.groupBounds = CommonCore.getMapBoundingBox(CommonCore.wgs84Crs, ImajnetUserSettings.mapExtent.longitudeWest, ImajnetUserSettings.mapExtent.latitudeSouth, ImajnetUserSettings.mapExtent.longitudeEast, ImajnetUserSettings.mapExtent.latitudeNorth))
        })
    },
    initPlatform: function() {
        ImageControler.currentGraphic =
            Graphic;
        CommonCore.initCommonElements();
        CommonCore.initMap();
        jQuery("#optionsInMenu").show();
        (Nigsys.browserIsIE7() || Nigsys.browserIsIE8()) && jQuery("#optionsInMenu").css("width", "72px");
        jQuery(window).resize(function(a, b) {
            if (a.target && (a.target.className && -1 !== a.target.className.indexOf("ui-dialog") || "mapAndToolbarContainer" == a.target.id || "mapAndToolbar" == a.target.id || "LRSSchematic" == a.target.id)) return !1;
            MapMethodsCore.applyImageLayout(ApplicationStorage.readObject("layout"), !0)
        });
        $(document).keydown(function(a) {
            1 !=
                a.ctrlKey || "107" != a.which && "109" != a.which && "187" != a.which && "189" != a.which || a.preventDefault()
        });
        $(window).on("mousewheel DOMMouseScroll", function(a) {
            1 == a.ctrlKey && a.preventDefault()
        });
        CommonCore.isMobile || (jQuery("#predefinedZoomLevels").corner("bevel tr"), jQuery(document).keyup(function(a) {
            27 == a.keyCode && (CommonCore.buttonClicked = "")
        }))
    },
    setBackEndContainerHeight: function() {
        if (isImajnetMode() || "" == CommonCore.page || "map" != CommonCore.page) {
            var a = Nigsys.getWindowSize();
            container.height(a.height - CommonCore.bodyMargins -
                125)
        }
    },
    addBeforeUnloadEvent: function(a, b) {
        jQuery(window).on("beforeunload", {
            type: a
        }, b)
    },
    bindResizeBackendContainer: function() {
        CommonCore.setBackEndContainerHeight();
        jQuery(window).resize(function(a, b) {
            CommonCore.setBackEndContainerHeight()
        })
    },
    bindCommonEvents: function() {
        CommonCore.addBeforeUnloadEvent(null, function(a) {
            if (isImajnetMode()) ImajnetPolyligne.onFinish();
            else "undefined" !== typeof ImajnetProtocol && ImajnetProtocol.imajnetLogout(!1)
        })
    },
    onPlatformContextMenu: function(a) {
        CommonCore.onMapRightClick(a);
        !CommonCore.currentEditorActiveControl || -1 === CommonCore.currentEditorActiveControl.get("button").indexOf("SplitFeature") && -1 === CommonCore.currentEditorActiveControl.get("button").indexOf("DrawHole") || (CommonCore.currentEditorActiveControl.setActive(!1), CommonCore.currentEditorActiveControl.setActive(!0))
    },
    initCookieWarning: function(a) {
        var b = ApplicationStorage.readObject("cookieWarning", a);
        if (!b || "0" == b) {
            jQuery("body").append(Nigsys.getCookieWarningNotificationInfoOkHTML());
            var b = Nigsys.getWindowSize().width,
                c = 80 * b / 100;
            jQuery("#cookieWarningNotification").width(c).css("left", b / 10);
            Nigsys.bindClickEvent(jQuery("#cookieWarningNotificationOk"), function() {
                ApplicationStorage.writeObject("cookieWarning", "1", a);
                jQuery("#cookieWarningNotification").remove()
            })
        }
    },
    initCommonApplication: function() {
        CommonCore.initProj4js();
        CommonCore.initHTMLContainers();
        CommonCore.bindCommonEvents();
        container && 0 !== container.length && container.append('\x3cdiv class\x3d"popup"\x3e\x3c/div\x3e');
        Nigsys.bindOnHashChange();
        isImajnetMode() ?
            (container.css("background-image", 'url("' + clientAppUrl + 'ImajnetLib/img/imajnetLogoLargeBlue.png")'), Nigsys.showImajnetLoading(), CommonCore.initImajnetElements(), CommonCore.isMobile || (CommonCore.initMap(), ImajnetMap.map = map), jQuery("body").bind("click", function(a) {
                Nigsys.errorNotification && Nigsys.errorNotification.close()
            }), jQuery("#map").bind("contextmenu", function(a) {
                CommonCore.onMapRightClick(a);
                return !1
            })) : (CommonCore.isMobile ? ImajnetProtocol.imajnetLoginSuccess = function() {} : (CommonCore.initCookieWarning(CommonCore.userInfo.username),
                    Nigsys.browserIsIE7() && footer.height(footer.height() + 9), jQuery(document).bind("mousedown selectstart", function(a) {
                        return jQuery(a.target).is("input, textarea, select, option")
                    })), Nigsys.bindClickEvent(jQuery(document), CommonCore.showHideDropDownDiv), Nigsys.bindClickEvent($("#mapMainMenuContributor"), function() {
                    MainMethodsCore.goToPage("/platform-web/mvc/pages/thematicgroups.html")
                }), Nigsys.bindClickEvent($("#mapMainMenuAdministration"), function() {
                    MainMethodsCore.goToPage("/platform-web/mvc/pages/administration.html")
                }),
                Nigsys.bindClickEvent($("#signOutButton"), function() {
                    MainMethodsCore.goToPage("/platform-web/mvc/pages/logout.html")
                }), Nigsys.bindClickEvent($("#contributorMapLinkImage"), function() {
                    MainMethodsCore.goToPage("/platform-web/mvc/pages/map.html")
                }), "map" == CommonCore.page ? jQuery("#map").bind("contextmenu", function(a) {
                    CommonCore.onPlatformContextMenu(a);
                    return !1
                }) : CommonCore.bindResizeBackendContainer(), "undefined" !== typeof MapCore && MapCore.initParseObjects())
    },
    beforeCloseDialog: function(a, b) {
        if ("popup" ==
            a) return ThematicGroupsTree.closePopup(!0, Main.layerSettingsIsGeoserverLayer), !1;
        if ("popupInfo" == a || "popupSearch" == a || "popupNewSearchFromExisting" == a) {
            if (MainMethodsCore.haveUnsavedData(MainMethodsCore.ASK_FOR_SAVE_GRID_EDIT_FEATURE) && !FeaturesListing.isListingMode(a)) return MainMethodsCore.checkIfUnsavedFeaturesForDialog(a, MainMethodsCore.ASK_FOR_SAVE_GRID_EDIT_FEATURE, {
                type: a,
                isFromConfirmation: !0
            }, FeaturesListing.saveFeaturesFromGrid, !0), !1
        } else {
            if ("popupStyleEditor" == a) return StyleEditor.checkIfUnsavedFeatures(!0,
                b), !1;
            if ("popupInfoEditFeature" == a) return Feature.closePopupInfoEditFeature(!0), !1;
            if ("popupAddFeatureOnDraw" == a) return FeatureEdit.closePopupAddFeatureOnDraw(!0, b), !1;
            if ("editLayerMetadataPopup" == a) return ThematicGroupsTree.closeMetadataPopup(!0, b), !1;
            if ("editLayerMetadataEditValuesPopup" == a) return ThematicGroupsTree.closeMetadataValuesPopup(!0, b), !1;
            "popupImajnet" == a && ImajnetAPI.imajnetImage && (ImajnetAPI.imajnetImage.onload = null, ImajnetAPI.imajnetImage = null)
        }
        Dialog.hideDialog(a, !0);
        return !0
    },
    bindAjaxError: function() {
        jQuery(document).ajaxError(function(a,
            b, c, e) {
            if (isImajnetMode()) - 1 !== c.url.indexOf("/service/api/user/userdetails") || 401 != b.status && 403 != b.status || location.reload();
            else {
                if (-1 !== c.url.indexOf("/service/api/user/userdetails") || -1 !== c.url.indexOf(applicationUrl + "app/user")) return !1; - 1 !== c.url.indexOf("springlogin") ? Nigsys.showLoginError(Nigsys.getStatusErrorText(401 == b.status ? 403 : b.status)) : -1 !== c.url.indexOf(geoserverUrl + "j_spring_security_check") ? 404 == b.status && GeoserverSecurity.geoserverLogin(!1) : 403 == b.status && -1 !== c.url.indexOf("/service/") &&
                    (MainMethodsCore.resetInitImajnetDeferred(), ImajnetUser.resetUserData(!1), console.error("Imajnet is logged out."), MainMethodsCore.initImajnet(!1))
            }
        })
    },
    platformOverwriteImajnetFunctions: function() {
        "undefined" !== typeof ImajnetUI && (ImajnetUI.getImageContainerDimesions = function() {
            var a = this.imajnetImageContainerSize;
            if (!ApplicationStorage.readObject("layout")) {
                if (MainCore.mapAndToolbarContainer.height()) {
                    var b = ImajnetUI.getImageAspectRatio();
                    b && (a.height = MainCore.mapAndToolbarContainer.height() - 50, a.width =
                        a.height ? parseInt(a.height * b) - 2 : Nigsys.browserIsIE7() ? 480 : null)
                }
                a.height < this.imajnetImageContainerSize.height && (a.height = this.imajnetImageContainerSize.height);
                a.width < this.imajnetImageContainerSize.width && (a.width = this.imajnetImageContainerSize.width)
            }
            return a
        }, ImajnetUI.onImageResize = function() {
            if (ImajnetUI.imageContainer) {
                var a = 0,
                    b = 0,
                    a = ImajnetUI.imageContainer.width(),
                    b = ImajnetUI.imageContainer.height();
                ImajnetUI.resizeImageElements(a, b, !1)
            }
        }, ImajnetUI.onKeyDown = function(a) {
            CommonCore.imajnetImageIsOpen() &&
                ("imajnetPOI" == a.target.id && (a.preventDefault(), a.stopImmediatePropagation(), a.stopPropagation()), "undefined" !== typeof isImajnetMode && isImajnetMode() && "HTML" != a.target.tagName && "BODY" != a.target.tagName && "DIV" != a.target.tagName && "IMG" != a.target.tagName || ImajnetUI.doOnKeyDown(a))
        });
        "undefined" !== typeof ImajnetAPI && (ImajnetAPI.positionOrderReceived = function(a) {
            CommonCore.imajnetImageIsOpen() && ImajnetAPI.doOnPositionOrderReceived(a)
        });
        "undefined" !== typeof ImajnetMap && (ImajnetMap.onMapClick = function(a,
            b) {
            a && MainMethodsCore.initImajnet(!0).done(function() {
                ImajnetMap.doOnMapClick(a, b)
            }).fail(function() {
                Imajnet.clickMode == Imajnet.CLICK_MODE_ORIENTED_IMAGES && ImajnetClickMode.orientedImagesError()
            })
        });
        "undefined" !== typeof LRSRequest && (LRSRequest.getRoad = function(a, b, c, e) {
            var d = $.Deferred();
            !CommonCore.isMobile || app.isOnline() && !appSettings.settings.offlineMode ? MainMethodsCore.initImajnet(!1).done(function() {
                LRSRequest.onGetRoad(a, b, c, e).done(function(a, b) {
                    d.resolve(a, b)
                }).fail(function() {
                    d.reject(null,
                        e)
                })
            }).fail(function() {
                LRSRequest.onGetRoad(a, b, c, e).done(function(a, b) {
                    d.resolve(a, b)
                }).fail(function() {
                    d.reject(null, e)
                })
            }) : fileSystem.readJsonFile(fileSystem.LRSROADS_DIR + "/" + a + ".json", !1).done(function(a, c) {
                "function" === typeof b && b({
                    pr: a
                }, e);
                d.resolve()
            }).fail(function(a) {
                "function" === typeof c && c(null, e);
                d.resolve(null)
            });
            return d.promise()
        }, LRSRequest.getLRSRoads = function(a, b, c, e) {
            var d = jQuery.Deferred();
            !CommonCore.isMobile || app.isOnline() && !appSettings.settings.offlineMode ? MainMethodsCore.initImajnet(!1).done(function() {
                LRSRequest.onGetLRSRoads(a,
                    b, c, e).done(function(a, b) {
                    d.resolve(a, b)
                }).fail(function() {
                    d.reject()
                })
            }).fail(function() {
                if ("function" === typeof LRSRequest.onGetLRSRoadsError) LRSRequest.onGetLRSRoadsError(b);
                "function" === typeof e && e(b);
                d.reject()
            }) : fileSystem.readJsonFile(fileSystem.getLRSRoadsFilePath(), !1).done(function(a, e) {
                "function" === typeof c && c({
                    roads: a
                }, b);
                d.resolve()
            }).fail(function(a) {
                "function" === typeof e && e(null, b);
                d.resolve(null)
            });
            return d.promise()
        }, LRSRequest.getLRSForPoints = function(a, b, c) {
            var e = jQuery.Deferred();
            MainMethodsCore.initImajnet(!1).done(function() {
                LRSRequest.getLRSForPointRequest(a, b, c).done(function(a) {
                    e.resolve(a)
                }).fail(function() {
                    e.reject()
                })
            }).fail(function() {
                e.reject()
            });
            return e.promise()
        });
        "undefined" !== typeof ImajnetUrl && (ImajnetUrl.goToLocation = function(a) {
            if (isImajnetMode()) this.onGoToLocation(a);
            else "map" == CommonCore.page && MainMethodsCore.initImajnet(!0).done(function() {
                ImajnetUrl.onGoToLocation(a)
            })
        });
        "undefined" !== typeof Imajnet && (Imajnet.onImageResize = function() {
            if (ImajnetUI.imageContainer) {
                var a =
                    ImajnetUI.imageContainer.width(),
                    b = ImajnetUI.imageContainer.height();
                ImajnetUI.resizeImageElements(a, b, !0)
            }
        });
        "undefined" !== typeof Address && (Address.onAddressClick = function(a, b) {
            MainMethodsCore.initImajnet(!0).done(function() {
                Address.zoomToCoordinates(a, b);
                ImajnetAPI.getClosestPosition(b, a, ImajnetSettings.rangeAddress, null, null, {
                    hideIfNoImage: !1
                })
            }).fail(function() {
                ImajnetPlugin.centerMapToPosition({
                    lon: a,
                    lat: b
                })
            })
        });
        "undefined" !== typeof ImajnetUser && (ImajnetUser.resetUserData = function(a) {
            a && MainMethodsCore.resetInitImajnetDeferred();
            ImajnetUser.data = null
        })
    },
    imajnetImageIsOpen: function() {
        var a = ApplicationStorage.readObject("layout");
        return a && 0 != a.index || Dialog.dialogIsOpen(ImajnetUI.imageContainerId)
    },
    onReady: function() {
        Nigsys.initNotification();
        CommonCore.bindAjaxError();
        if (isImajnetMode()) {
            if (CommonCore.initCommonApplication(), Nigsys.browserIsIE7() || Nigsys.browserIsIE8() || Nigsys.browserIsIE9()) OpenLayers.Format.XML.prototype.getElementsByTagNameNS = function(a, b, c) {
                var e = [];
                if (!a) return e;
                if (a.getElementsByTagNameNS) e = a.getElementsByTagNameNS(b,
                    c);
                else {
                    a = a.getElementsByTagName("*");
                    for (var d, f, g = 0, h = a.length; g < h; ++g)
                        if (d = a[g], f = d.prefix ? d.prefix + ":" + c : c, "*" == c || f == d.nodeName) "*" != b && b != d.namespaceURI || e.push(d)
                }
                return e
            }
        } else CommonCore.platformOverwriteImajnetFunctions(), "undefined" !== typeof MainCore && MainCore.getUser();
        CommonCore.functionsOverrides()
    },
    deactivateImajnetButton: function() {
        ImajnetUI.disableToolControls();
        ImajnetUI.deactivateImajnetToolbarButtons();
        CommonCore.deactivateMapClick();
        ImajnetPlugin.unregisterMapEvents();
        ImajnetUI.removeActiveState(ImajnetUI.btnImajnetPluginDiv)
    },
    activateImajnetButton: function() {
        "map" == CommonCore.page && ("undefined" !== typeof ThematicGroupsTree && (ThematicGroupsTree.onTopGroupLayersName = [ImajnetMap.layerName, ImajnetMap.imajnetSurveyTraceLayerName, ImajnetMap.imajnetDragFeaturesLayerName, ImajnetMap.allWFSName, ImajnetMap.imajnetOrientationLayerName]), Imajnet.imajnetIsActive() && (CommonCore.disableCommonControls(), Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage"), CommonCore.activateMapClick()), CommonCore.updateOverviewMap(),
            jQuery("#predefinedZoomLevelsValue").html(jQuery.app.map.button.predefinedZoom.title), ImajnetUI.addActiveState(ImajnetUI.btnImajnetPluginDiv))
    }
};
CommonCore.page = "";
var header = null,
    footer = null,
    languageBar = null,
    lastSegmentMeasurement = 0,
    lon = 50,
    lat = 0,
    zoom = 0,
    panel = null,
    extent = null,
    defaultZoomLevel = 20,
    groupBoundingBox = null,
    mapNavigation, dialogMargins = 0,
    imajnetImageResized = !1,
    mapResized = !1,
    snapTolerance = 1,
    imajnetImageContainerDimensionPercentage = {
        width: .5,
        height: 1
    },
    mapContainerDimensionPercentage = {
        width: .5,
        height: 1
    };

function showHideSearchDropDown() {
    jQuery("#searchDropDownDiv").is(":visible") ? (jQuery("#searchDropDownDiv").hide(), CommonCore.buttonClicked = "") : ImajnetUI.docking.imajnetButtons ? ImajnetUI.showAndPositionInside(ImajnetUI.docking.imajnetButtons.mainContainer, jQuery("#searchDropDownDiv")) : jQuery("#searchDropDownDiv").show()
}

function isImajnetMode() {
    return themeName == IMAJNET_THEME_NAME
}

function getContainerMarginTop() {
    return parseInt(container.css("margin-top").replace("px", ""))
}

function getTimeStamp() {
    var b = new Date;
    return [b.getHours(), b.getMinutes(), b.getSeconds(), b.getMilliseconds()].join(":")
}
jQuery(function() {
    Imajnet.imajnetPath = rootUrl + "ImajnetLib/";
    Imajnet.setLanguage(localeLanguage).done(function() {
        CommonCore.onReady()
    })
});
var Common = {
    onSearchButtonPress: function() {
        if (ImajnetUI.docking.imajnetButtons) {
            var b = null;
            (b = isImajnetMode() ? ImajnetUI.docking.imajnetButtons : ImajnetUI.docking.mapToolsButtons) && ImajnetUI.showAndPositionInside(b.mainContainer, jQuery("#searchDropDownDiv"))
        } else jQuery("#searchDropDownDiv").show()
    },
    bindSearchButtonEvents: function() {
        Nigsys.browserIsIE7() || Nigsys.browserIsIE8() ? Nigsys.browserIsIE7() && jQuery("#searchDropDownDiv").css("position", "relative") : jQuery("#searchDropDownDiv").corner();
        if (Nigsys.onMobile()) jQuery("#searchDropDownButton").on("vclick",
            function(b) {
                b.preventDefault();
                if (jQuery("#searchDropDownDiv").is(":visible")) jQuery("#searchDropDownDiv").hide();
                else Common.onSearchButtonPress()
            });
        else jQuery("#searchDropDownButton").on({
            mouseenter: function() {
                Common.onSearchButtonPress()
            },
            mouseleave: function() {
                jQuery("#searchDropDownDiv").hide()
            }
        })
    }
};
ImajnetPlugin.imajnetLogoutComplete = function() {
    isImajnetMode() && location.reload()
};
ImajnetPlugin.imajnetLoginSuccess = function() {
    isImajnetMode() ? ImajnetWeb.imajnetLoginSuccess() : (ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showRoads = !0, ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showPR = !0, ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showLabels = !0, jQuery("#" + ImajnetUI.newsContainerId).remove())
};
ImajnetPlugin.imajnetLoginError = function(b) {
    if (isImajnetMode()) {
        Nigsys.hideImajnetLoading();
        var a = "";
        ImajnetProtocol.firstLoginTry ? (ImajnetProtocol.firstLoginTry = !1, Nigsys.showLoginNotification(Nigsys.getLoginWithHTML()), "undefined" !== typeof isMobile && isMobile && Main.readStorageObject("sessionExpired") && Main.writeStorageObject("sessionExpired", null)) : a = ImajnetProtocol.getErrorMessage(b);
        Nigsys.showLoginError(a);
        "undefined" !== typeof ImajnetUI && jQuery(document).bind("keydown", ImajnetUI.clickLogin);
        jQuery("#imajnetLoginButton").prop("disabled", !1);
        jQuery("#imajnetLoginRequestAccess").prop("disabled", !1);
        jQuery("#imajnetLoginForgotPassword").prop("disabled", !1)
    } else "undefined" !== typeof ImajnetUI && ImajnetUI.showNotificationInfoOk("", jQuery.imajnet.imajnetNotAvailable + "\x3cbr/\x3e" + ImajnetProtocol.getErrorMessage(b), "center")
};
var imajnetZoomOnScrollHandler = ImajnetZoom.zoomOnScrollHandler;
ImajnetZoom.zoomOnScrollHandler = function(b, a) {
    imajnetZoomOnScrollHandler(b, a) || (ImajnetMapImplementation.deactivateMapNavigation(), isImajnetMode() || CommonCore.removeFeatureInfo())
};
if ("undefined" !== typeof ImajnetSettings) {
    var imajnetSettingsSaveSettings = ImajnetSettings.saveSettings;
    ImajnetSettings.saveSettings = function() {
        imajnetSettingsSaveSettings();
        CommonCore.setScaleUnit()
    }
}
ImajnetUrl.applyUrlParams = function(b) {
    var a = ImajnetUrl.readUrl(b);
    a[this.LOCALE_URL_PARAM_NAME] && a[this.LOCALE_URL_PARAM_NAME] != this.urlParams[this.LOCALE_URL_PARAM_NAME] && ImajnetUrl.changeLocale(a[this.LOCALE_URL_PARAM_NAME]);
    a[this.MAP_URL_PARAM_NAME] || isImajnetMode() && (a[this.MAP_URL_PARAM_NAME] = Nigsys.getCookie("IMAJNET", "SETTINGS_MAP_TYPE"));
    if (a[this.MAP_URL_PARAM_NAME] != this.urlParams[this.MAP_URL_PARAM_NAME]) {
        this.urlParams[this.MAP_URL_PARAM_NAME] = a[this.MAP_URL_PARAM_NAME];
        try {
            window["set" +
                this.urlParams[this.MAP_URL_PARAM_NAME] + "BaseLayer"]()
        } catch (d) {}
        this.changeUrlParam(this.MAP_URL_PARAM_NAME, "emptyBaseLayer" == this.urlParams[this.MAP_URL_PARAM_NAME] ? "" : this.urlParams[this.MAP_URL_PARAM_NAME])
    }
    isImajnetMode() || (a[this.WORKSPACE_URL_PARAM_NAME] && a[this.WORKSPACE_URL_PARAM_NAME] != this.urlParams[this.WORKSPACE_URL_PARAM_NAME] && (MainMethodsCore.onSelectWorkspaceChanged(a[this.WORKSPACE_URL_PARAM_NAME], ThematicGroupsTreeCore.onWorkspaceChange) ? MainCore.selectWorkspace.val(a[this.WORKSPACE_URL_PARAM_NAME]) :
        this.changeUrlParam(this.WORKSPACE_URL_PARAM_NAME, MainMethodsCore.getCurrentWorkspace())), a[this.GROUP_URL_PARAM_NAME] && a[this.GROUP_URL_PARAM_NAME] != this.urlParams[this.GROUP_URL_PARAM_NAME] && (this.urlParams[this.GROUP_URL_PARAM_NAME] = a[this.GROUP_URL_PARAM_NAME], ThematicGroupsTreeCore.fillGroup(a[this.GROUP_URL_PARAM_NAME], {
        noZoomToExtent: !1
    })), "map" == CommonCore.page && a[this.POSITION_URL_PARAM_NAME] && a[this.POSITION_URL_PARAM_NAME] != this.urlParams[this.POSITION_URL_PARAM_NAME] && this.applyCenterFromUrl(c));
    if (a[this.ZOOM_URL_PARAM_NAME] != this.urlParams[this.ZOOM_URL_PARAM_NAME]) {
        this.urlParams[this.ZOOM_URL_PARAM_NAME] = a[this.ZOOM_URL_PARAM_NAME];
        var c = parseInt(this.urlParams[this.ZOOM_URL_PARAM_NAME]);
        isImajnetMode() && (!ImajnetUrl.urlParams[ImajnetUrl.MAP_URL_PARAM_NAME] && c < CommonCore.numZoomLevels || ImajnetUrl.urlParams[ImajnetUrl.MAP_URL_PARAM_NAME] && 18 > c) && c++;
        ImajnetPlugin.zoomMapTo(c)
    }
    a[this.SURVEY_TRACE_URL_PARAM_NAME] != this.urlParams[this.SURVEY_TRACE_URL_PARAM_NAME] && (this.urlParams[this.SURVEY_TRACE_URL_PARAM_NAME] =
        a[this.SURVEY_TRACE_URL_PARAM_NAME], a[this.SURVEY_TRACE_URL_PARAM_NAME] == this.SURVEY_TRACE_ACTIVE_PARAM_VALUE ? SurveyTrace.surveyTraceIsActive = !0 : b && (SurveyTrace.surveyTraceIsActive = !1, ImageControler.currentSurveyTrace.hideTrace()));
    a[this.IMAGE_URL_PARAM_NAME] ? (this.urlParams[this.IMAGE_URL_PARAM_NAME] = a[this.IMAGE_URL_PARAM_NAME], b = {
        id: this.urlParams[this.IMAGE_URL_PARAM_NAME]
    }, ImajnetZoom.left = -1, Nigsys.showLoading(ImajnetUI.imageContainer), ImajnetAPI.setImajnetImage({
        position: b
    }), ImajnetUrl.changeUrlParam(this.IMAGE_URL_PARAM_NAME,
        "")) : a[this.LOCATION_URL_PARAM_NAME] && a[this.LOCATION_URL_PARAM_NAME] != this.urlParams[this.LOCATION_URL_PARAM_NAME] && (this.urlParams[this.LOCATION_URL_PARAM_NAME] = a[this.LOCATION_URL_PARAM_NAME], this.applyImajnetLocation(this.urlParams[this.LOCATION_URL_PARAM_NAME]))
};
ImajnetUser.getUsername = function() {
    return "undefined" !== typeof CommonCore.userInfo && CommonCore.userInfo && CommonCore.userInfo.username ? CommonCore.userInfo.username : ImajnetUser.data ? ImajnetUser.data.login : ""
};
ImajnetUser.getEmail = function() {
    return "undefined" !== typeof CommonCore.userInfo && CommonCore.userInfo && CommonCore.userInfo.email ? CommonCore.userInfo.email : ImajnetUser.data ? ImajnetUser.data.email : ""
};
ImajnetClickMode.orientedImagesReceived = function(b) {
    ImajnetMap.hideImajboxMarker();
    ImajnetMap.hideOrientation();
    b = JSON.parse(b);
    b.positions ? (ImajnetClickMode.positions = b.positions, ImajnetClickMode.addClickMode(!0)) : Dialog.dialogIsOpen(ImajnetUI.imageContainerId) && (ImajnetZoom.left = -1, Nigsys.showLoading(ImajnetUI.imageContainer), ImajnetAPI.setImajnetImage({
        position: null
    }));
    ImajnetClickMode.redrawClickedPointOnMap()
};
ImajnetUI.imajnetImageLayerMouseOut = function(b) {
    Nigsys.browserIsIE()
};
ImajnetLRSSettings.updateSearch = function() {};
var imajnetLRSSettingsupdateReferential = ImajnetLRSSettings.updateReferential;
ImajnetLRSSettings.updateReferential = function() {
    imajnetLRSSettingsupdateReferential();
    "undefined" !== typeof Feature && Feature.updateReferentialSettings()
};
Imajnet.deactivateImajnetControl = function(b, a) {
    if (!Imajnet.imajnetIsActive()) return !1;
    "closestImage" == a ? (Imajnet.clickMode = null, "undefined" !== typeof ImajnetMapImplementation && "function" === typeof ImajnetMapImplementation.activateHoverAndClickFeature && ImajnetMapImplementation.activateHoverAndClickFeature()) : "clickMode" == a ? (ImajnetClickMode.hideOrientedImages(), Imajnet.clickMode = null, "undefined" !== typeof ImajnetMapImplementation && "function" === typeof ImajnetMapImplementation.activateHoverAndClickFeature &&
        ImajnetMapImplementation.activateHoverAndClickFeature()) : "showClipboard" == a ? (ImajnetUI.hideItem(ImajnetUI.clipboardExportContainerId), ImajnetUI.hideItem(ImajnetUI.clipboardContainerId)) : "searchLRS" == a && LRS.closeLRSDialog();
    ImajnetUI.removeActiveState(b)
};
var imajnetLRSSettingssaveLRSSettings = ImajnetLRSSettings.saveLRSSettings;
ImajnetLRSSettings.saveLRSSettings = function() {
    imajnetLRSSettingssaveLRSSettings();
    if ("undefined" !== typeof ImajnetMapImplementation && "function" === typeof ImajnetMapImplementation.onSaveLRSSettings) ImajnetMapImplementation.onSaveLRSSettings()
};
FlatGraphic.drawFeatureImage = function(b) {
    var a = jQuery('div[id\x3d"photogrammetryItem_' + b.featureId + '"]');
    if (b && 0 != a.length) {
        var c = null;
        "undefined" !== typeof Feature && "undefined" !== typeof Feature.featuresData && "undefined" !== typeof MainCore && "function" === typeof CommonCore.getLayerNameWithoutWorkspace && Feature.featuresData[CommonCore.getLayerNameWithoutWorkspace(b.featureId)] && (c = Feature.featuresData[CommonCore.getLayerNameWithoutWorkspace(b.featureId)].getProperties());
        FlatGraphic.onDrawFeatureImage(a,
            b, c)
    }
};
CommonCore.mapScaleControl = null;
CommonCore.wgs84Sphere = new ol.Sphere(6378137);
CommonCore.dragAndDropLayerCounter = 0;
CommonCore.dragAndDropLayers = [];
CommonCore.getMapBoundingBox = function(a, c, d, b, f) {
    if (a == CommonCore.wgs84Crs && CommonCore.customerCrs == CommonCore.wgs84Crs) {
        var e = d;
        d = c;
        c = e;
        e = f;
        f = b;
        b = e
    }
    return ol.proj.transformExtent([c, d, b, f], a, map.projection)
};
CommonCore.getOSMLayer = function() {
    var a = new ol.layer.Tile({
        name: jQuery.imajnet.map.OSM,
        source: new ol.source.OSM,
        isBaseLayer: !0
    });
    a.set("name", ImajnetUrl.OSM_LAYER_PARAM_NAME);
    return a
};
CommonCore.getOCMLayer = function() {
    var a = new ol.layer.Tile({
        name: jQuery.imajnet.map.OCM,
        source: new ol.source.XYZ({
            url: "https://{a-c}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey\x3d25dd076bbef44fab8c6a8e0b3642c257",
            crossOrigin: null
        }),
        isBaseLayer: !0
    });
    a.set("name", ImajnetUrl.OCM_LAYER_PARAM_NAME);
    return a
};
CommonCore.getOTMLayer = function() {
    var a = new ol.layer.Tile({
        name: jQuery.imajnet.map.OCM,
        source: new ol.source.XYZ({
            url: "https://{a-c}.tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey\x3d25dd076bbef44fab8c6a8e0b3642c257",
            crossOrigin: null
        }),
        isBaseLayer: !0
    });
    a.set("name", ImajnetUrl.OTM_LAYER_PARAM_NAME);
    return a
};
CommonCore.getBingLayer = function(a) {
    var c = "";
    a == CommonCore.BING_TYPE_ROAD ? c = ImajnetUrl.BING_ROAD_LAYER_PARAM_NAME : a == CommonCore.BING_TYPE_SATELLITE ? c = ImajnetUrl.BING_SATELLITE_LAYER_PARAM_NAME : a == CommonCore.BING_TYPE_HYBRID && (c = ImajnetUrl.BING_HYBRID_LAYER_PARAM_NAME);
    a = new ol.layer.Tile({
        name: jQuery.imajnet.map["bing" + a],
        source: new ol.source.BingMaps({
            key: CommonCore.bingApiKey,
            imagerySet: a
        }),
        isBaseLayer: !0
    });
    a.set("name", c);
    return a
};
CommonCore.onFeatureMouseMove = function(a) {
    if (a && (CommonCore.lastMouseCoordinateX != a.originalEvent.offsetX || CommonCore.lastMouseCoordinateY != a.originalEvent.offsetY)) {
        CommonCore.lastMouseCoordinateX = a.originalEvent.offsetX;
        CommonCore.lastMouseCoordinateY = a.originalEvent.offsetY;
        var c = CommonCore.mapContainer.offset(),
            d = {
                offsetX: CommonCore.lastMouseCoordinateX,
                offsetY: CommonCore.lastMouseCoordinateY,
                clientX: c.left + CommonCore.lastMouseCoordinateX,
                clientY: c.top + CommonCore.lastMouseCoordinateY
            };
        a = ol.proj.transform(a.coordinate,
            ImajnetMap.map.projection, ImajnetMapImplementation.imajnetProjection);
        LRSRequest.getLRSForPoints(Array({
            lon: a[0],
            lat: a[1],
            height: 0
        }), !0, !0).done(function(a) {
            if (a.linearPosition) {
                var c = a.linearPosition;
                if (mouseOverRoadName) {
                    for (var e = !1, g = 0; g < a.linearPosition.length; g++) a.linearPosition[g].road.name == mouseOverRoadName && (c = a.linearPosition[g], e = !0);
                    if (!e) return
                } else a.linearPosition[0] && (c = a.linearPosition[0]);
                jQuery("#popupFeatureInfoLRS").html(CommonCore.getLRSFieldsForPopup(c));
                jQuery("#popupFeatureInfoLRSPR").html(CommonCore.getLRSFieldsForPopupPR(c));
                jQuery("#popupFeatureInfoLRSPRAbs").html(CommonCore.getLRSFieldsForPopupPRAbs(c));
                Nigsys.positionExistingElement(d, null, "map", jQuery(".popupFeatureInfo"))
            }
        }).fail(function() {
            jQuery("#popupFeatureInfoLRS").html("");
            jQuery("#popupFeatureInfoLRSPR").html("");
            jQuery("#popupFeatureInfoLRSPRAbs").html("")
        })
    }
};
CommonCore.registerFeatureMouseMove = function(a) {
    CommonCore.unregisterFeatureMouseMove();
    mouseOverRoadName = a;
    CommonCore.onFeatureMouseMove();
    map.on("pointermove", CommonCore.onFeatureMouseMove)
};
CommonCore.unregisterFeatureMouseMove = function() {
    map.un("pointermove", CommonCore.onFeatureMouseMove)
};
CommonCore.addPanZoomBarEvents = function() {};
CommonCore.zoomToExtent = function(a) {
    map.getView().fit(a, map.getSize())
};
CommonCore.formatMeasurementLength = function(a, c) {
    var d = 0;
    if (c)
        for (var b = a.getCoordinates(), d = 0, f = map.getView().getProjection(), e = 0, g = b.length - 1; e < g; ++e) var h = ol.proj.transform(b[e], f, CommonCore.wgs84Crs),
            k = ol.proj.transform(b[e + 1], f, CommonCore.wgs84Crs),
            d = d + CommonCore.wgs84Sphere.haversineDistance(h, k);
    else d = a.getLength();
    return Nigsys.getHighestUnit(LRS.transformFromMeters(d, Nigsys.getMeasurementUnit()), Nigsys.getMeasurementUnit())
};
CommonCore.formatMeasurementSuface = function(a, c) {
    var d;
    c ? (d = a.clone().transform(map.getView().getProjection(), CommonCore.wgs84Crs).getLinearRing(0).getCoordinates(), d = Math.abs(CommonCore.wgs84Sphere.geodesicArea(d))) : d = a.getArea();
    return Nigsys.getHighestSquareUnit(LRS.transformFromSquareMeters(d, Nigsys.getMeasurementUnit()), Nigsys.getMeasurementUnit())
};
CommonCore.handleLineMeasurements = function(a) {
    var c = a.feature.getGeometry(),
        d = c.getCoordinates(),
        d = new ol.geom.LineString([d[d.length - 2], d[d.length - 1]]);
    jQuery("#lastSegmentMeasurementText").html(CommonCore.formatMeasurementLength(d, !0));
    jQuery("#popupMeasureContentText").html(CommonCore.formatMeasurementLength(c, !0));
    lastSegmentMeasurement = CommonCore.currentMeasurement = 0;
    CommonCore.lineMeasureComponentsLength = 2;
    a.preventDefault()
};
CommonCore.handleLinePartialMeasurements = function(a) {
    var c = a.getCoordinates();
    CommonCore.currentMeasurement = CommonCore.formatMeasurementLength(a, !0);
    jQuery("#popupMeasureContentText").html(CommonCore.currentMeasurement);
    c.length > CommonCore.lineMeasureComponentsLength ? (a = new ol.geom.LineString([c[c.length - 3], c[c.length - 2]]), jQuery("#lastSegmentMeasurementText").html(CommonCore.formatMeasurementLength(a, !0)), jQuery("#lastSegmentMeasurement").show(), lastSegmentMeasurement = CommonCore.currentMeasurement,
        CommonCore.lineMeasureComponentsLength = c.length) : 2 == CommonCore.lineMeasureComponentsLength && jQuery("#lastSegmentMeasurement").hide()
};
CommonCore.handleSurfaceMeasurements = function(a) {
    jQuery("#popupMeasureSurfaceContentText").html(CommonCore.formatMeasurementSuface(a, !0))
};
CommonCore.disableCommonControls = function(a) {
    Imajnet && (Imajnet.clickMode = null);
    ImajnetUI && ImajnetUI.disableToolControls();
    Dialog.hideDialog("popupMeasure", !0);
    Dialog.hideDialog("popupMeasureSurface", !0);
    CommonCore.zoomBox && CommonCore.zoomBox.setActive(!1);
    jQuery("#popupMeasureContentText").html("");
    jQuery("#popupMeasureSurfaceContentText").html("");
    jQuery("#lastSegmentMeasurement").hide();
    lastSegmentMeasurement = CommonCore.currentMeasurement = 0;
    CommonCore.lineMeasureComponentsLength = 2;
    CommonCore.deactivateButton("olControlZoomInFeatures");
    CommonCore.deactivateButton("olControlZoomOutFeatures");
    CommonCore.deactivateButton("olControlMeasureLineFeatures");
    CommonCore.deactivateButton("olControlMeasureSurfaceFeatures");
    CommonCore.deactivateButton("olControlDisableFeatures");
    CommonCore.deactivateButton("olControlPrintFeatures");
    if ("undefined" !== typeof CG34Arbres && CG34Arbres) CG34Arbres.onClose(!1);
    if ("undefined" !== typeof CG34SH && CG34SH) CG34SH.onClose();
    if ("undefined" !== typeof PolygonFromPoint && PolygonFromPoint) PolygonFromPoint.onClose();
    CommonCore.showHideDropDownDiv(null)
};
CommonCore.addMapCommonControls = function() {
    CommonCore.isMobile && MapMobile.initMapControls();
    var a = jQuery("\x3cdiv/\x3e").addClass("olControlNavigationHistory  olControlNavigationHistoryPreviousItemActive").prop("title", jQuery.app.map.button.previousView).click(function(a) {
            CommonCore.getPreviousView()
        }),
        c = jQuery("\x3cdiv/\x3e").addClass("olControlNavigationHistory  olControlNavigationHistoryNextItemActive").prop("title", jQuery.app.map.button.nextView).click(function(a) {
            CommonCore.getNextView()
        });
    jQuery("#mapControls").append(a,
        c);
    a = jQuery("\x3cdiv/\x3e").addClass("olControlZoomInFeaturesItemInactive").prop("title", jQuery.app.map.button.zoomIn).click(function(a) {
        CommonCore.buttonIsActive("olControlZoomInFeatures") ? (CommonCore.buttonClicked = "", CommonCore.zoomBox.setActive(!1), CommonCore.deactivateButton("olControlZoomInFeatures"), Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage"), CommonCore.activateMapClick()) : (CommonCore.disableCommonControls("zoomIn"), CommonCore.buttonClicked = "zoomIn", map.removeInteraction(CommonCore.zoomBox),
            CommonCore.zoomBox = new ol.interaction.DragZoom({
                condition: ol.events.condition.always,
                out: !1
            }), map.addInteraction(CommonCore.zoomBox), CommonCore.zoomBox.setActive(!0), Imajnet.deactivateImajnetControl(ImajnetUI.btnClickModeDiv, "clickMode"), CommonCore.activateButton("olControlZoomInFeatures"))
    });
    jQuery("#mapControls").append(a);
    a = jQuery("\x3cdiv/\x3e").addClass("olControlZoomOutFeaturesItemInactive").prop("title", jQuery.app.map.button.zoomOut).click(function(a) {
        CommonCore.buttonIsActive("olControlZoomOutFeatures") ?
            (CommonCore.buttonClicked = "", CommonCore.zoomBox.setActive(!1), CommonCore.deactivateButton("olControlZoomOutFeatures"), Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage"), CommonCore.activateMapClick()) : (CommonCore.disableCommonControls("zoomOut"), CommonCore.buttonClicked = "zoomOut", map.removeInteraction(CommonCore.zoomBox), CommonCore.zoomBox = new ol.interaction.DragZoom({
                    condition: ol.events.condition.always,
                    out: !0
                }), map.addInteraction(CommonCore.zoomBox), CommonCore.zoomBox.setActive(!0),
                Imajnet.deactivateImajnetControl(ImajnetUI.btnClickModeDiv, "clickMode"), CommonCore.activateButton("olControlZoomOutFeatures"))
    });
    jQuery("#mapControls").append(a);
    a = jQuery("\x3cdiv/\x3e").addClass("olControlMeasureLineFeaturesItemInactive").prop("title", jQuery.app.map.button.measureLine).click(function(a) {
        CommonCore.buttonIsActive("olControlMeasureLineFeatures") ? (CommonCore.deactivateMeasureLine(), Dialog.hideDialog("popupMeasure", !0), Dialog.hideDialog("popupMeasureSurface", !0), CommonCore.buttonClicked =
            "", CommonCore.deactivateButton("olControlMeasureLineFeatures"), Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage"), CommonCore.activateMapClick()) : (CommonCore.disableCommonControls("measureLine"), CommonCore.buttonClicked = "measureLine", CommonCore.activateMeasureLine(), CommonCore.onMeasureLineTabsChange(0 == Nigsys.tabActiveIndex(jQuery("#popupLineMeasureTabs")) ? "simpleMeasurementTab" : "LRSMeasurementTab"), Dialog.showDialog("popupMeasure", 420, 200, null, null, jQuery.app.map.button.measureLine),
            Imajnet.deactivateImajnetControl(ImajnetUI.btnClickModeDiv, "clickMode"), CommonCore.activateButton("olControlMeasureLineFeatures"))
    });
    jQuery("#mapControls").append(a);
    a = jQuery("\x3cdiv/\x3e").addClass("olControlMeasureSurfaceFeaturesItemInactive").prop("title", jQuery.app.map.button.measureSurface).click(function(a) {
        CommonCore.buttonIsActive("olControlMeasureSurfaceFeatures") ? (CommonCore.buttonClicked = "", CommonCore.deactivateMeasureSurface(), Dialog.hideDialog("popupMeasure", !0), Dialog.hideDialog("popupMeasureSurface", !0), jQuery("#popupMeasureSurfaceContentText").html(""), CommonCore.deactivateButton("olControlMeasureSurfaceFeatures"), Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage"), CommonCore.activateMapClick()) : (CommonCore.disableCommonControls("measureSurface"), CommonCore.buttonClicked = "measureSurface", CommonCore.activateMeasureSurface(), Dialog.showDialog("popupMeasureSurface", 320, 120, null, null, jQuery.app.map.button.measureSurface), Imajnet.deactivateImajnetControl(ImajnetUI.btnClickModeDiv,
            "clickMode"), CommonCore.activateButton("olControlMeasureSurfaceFeatures"))
    });
    jQuery("#mapControls").append(a);
    CommonCore.zoomBox = new ol.interaction.DragZoom({
        condition: ol.events.condition.always
    });
    map.addInteraction(CommonCore.zoomBox);
    CommonCore.zoomBox.setActive(!1);
    !CommonCore.isMobile || app.isOnline() && !appSettings.settings.offlineMode || Reserve.hideSearchReserve();
    CommonCore.measurementLayer = new ol.layer.Vector({
        source: new ol.source.Vector,
        visible: !0,
        zIndex: 231312,
        style: new ol.style.Style({
            fill: new ol.style.Fill({
                color: "rgba(0, 153, 255, 0.2)"
            }),
            stroke: new ol.style.Stroke({
                color: "rgba(0, 153, 255, 1)",
                width: 3
            }),
            image: new ol.style.Circle({
                radius: 5,
                stroke: new ol.style.Stroke({
                    color: "rgba(0, 153, 255, 0.7)"
                }),
                fill: new ol.style.Fill({
                    color: "rgba(0, 153, 255, 0.2)"
                })
            })
        })
    });
    CommonCore.measurementLayer.set("name", "Measurement layer");
    map.addLayer(CommonCore.measurementLayer);
    CommonCore.measureLine = new ol.interaction.Draw({
        type: "LineString",
        source: CommonCore.measurementLayer.getSource(),
        condition: CommonCore.isLeftMouseButton,
        geometryFunction: function(a,
            b) {
            b || (b = new ol.geom.LineString(null));
            b.setCoordinates(a);
            CommonCore.handleLinePartialMeasurements(b);
            return b
        }
    });
    CommonCore.measureLine.on("drawstart", CommonCore.clearMeasurements);
    CommonCore.measureLine.on("drawend", CommonCore.handleLineMeasurements);
    map.addInteraction(CommonCore.measureLine);
    CommonCore.deactivateMeasureLine();
    CommonCore.measureSurface = new ol.interaction.Draw({
        type: "Polygon",
        source: CommonCore.measurementLayer.getSource(),
        condition: CommonCore.isLeftMouseButton,
        geometryFunction: function(a,
            b) {
            b || (b = new ol.geom.Polygon(null));
            b.setCoordinates(a);
            CommonCore.handleSurfaceMeasurements(b);
            return b
        },
        style: new ol.style.Style({
            fill: new ol.style.Fill({
                color: "rgba(0, 153, 255, 0.2)"
            }),
            stroke: new ol.style.Stroke({
                color: "rgba(0, 153, 255, 1)",
                width: 3
            }),
            image: new ol.style.Circle({
                radius: 5,
                stroke: new ol.style.Stroke({
                    color: "rgba(0, 153, 255, 0.7)"
                }),
                fill: new ol.style.Fill({
                    color: "rgba(0, 153, 255, 0.2)"
                })
            })
        })
    });
    CommonCore.measureSurface.on("drawstart", CommonCore.clearMeasurements);
    CommonCore.measureSurface.on("drawend",
        function(a) {
            CommonCore.handleSurfaceMeasurements(a.feature.getGeometry())
        });
    map.addInteraction(CommonCore.measureSurface);
    CommonCore.deactivateMeasureSurface();
    a = new ol.interaction.DragRotateAndZoom({
        condition: ol.events.condition.platformModifierKeyOnly
    });
    map.addInteraction(a);
    a = new ol.interaction.DragAndDrop({
        formatConstructors: [ol.format.GPX, ol.format.GeoJSON, ol.format.IGC, ol.format.KML, ol.format.TopoJSON]
    });
    map.addInteraction(a);
    a.on("addfeatures", function(a) {
        for (var b = 0; b < a.features.length; b++) a.features[b].setStyle(null);
        a = new ol.source.Vector({
            features: a.features
        });
        b = new ol.layer.Vector({
            source: a,
            name: "Drag and drop layer " + CommonCore.dragAndDropLayerCounter,
            style: function(a, b) {
                return CommonCore.dragAndDropStyle(a.getGeometry().getType())
            }
        });
        CommonCore.dragAndDropLayerCounter++;
        map.addLayer(b);
        CommonCore.dragAndDropLayers.push(b);
        CommonCore.zoomToExtent(a.getExtent())
    })
};
CommonCore.dragAndDropStyle = function(a) {
    var c = {
        Point: new ol.style.Style({
            image: new ol.style.Circle({
                fill: new ol.style.Fill({
                    color: "rgba(0,0,255,0.5)"
                }),
                radius: 3,
                stroke: new ol.style.Stroke({
                    color: "#00f",
                    width: 1
                })
            })
        }),
        LineString: new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: "rgba(0,0,255,0.7)",
                width: 3
            })
        }),
        Polygon: new ol.style.Style({
            fill: new ol.style.Fill({
                color: "rgba(0,0,255,0.5)"
            }),
            stroke: new ol.style.Stroke({
                color: "#00f",
                width: 1
            })
        }),
        MultiPoint: new ol.style.Style({
            image: new ol.style.Circle({
                fill: new ol.style.Fill({
                    color: "rgba(0,0,255,0.5)"
                }),
                radius: 3,
                stroke: new ol.style.Stroke({
                    color: "#00f",
                    width: 1
                })
            })
        }),
        MultiLineString: new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: "rgba(0,0,255,0.7)",
                width: 3
            })
        }),
        MultiPolygon: new ol.style.Style({
            fill: new ol.style.Fill({
                color: "rgba(0,0,255,0.5)"
            }),
            stroke: new ol.style.Stroke({
                color: "#00f",
                width: 1
            })
        })
    };
    c[a].text = new ol.style.Text({
        fill: new ol.style.Fill({
            color: "#fff"
        }),
        stroke: new ol.style.Stroke({
            color: "rgba(0, 0, 0, 0.6)",
            width: 3
        })
    });
    return c[a]
};
CommonCore.isLeftMouseButton = function(a) {
    return 1 == a.originalEvent.buttons
};
CommonCore.removeBaseLayers = function() {
    map && 0 < map.getLayers().getLength() && map.getLayers().removeAt(0)
};
CommonCore.addBaseLayers = function(a, c) {
    var d = CommonCore.getBaseLayerName();
    ImajnetUrl.changeUrlParam(ImajnetUrl.MAP_URL_PARAM_NAME, d);
    CommonCore.removeBaseLayers();
    CommonCore.emptyBaseLayer = new ol.layer.Tile({
        isBaseLayer: !0
    });
    CommonCore.emptyBaseLayer.set("name", "emptyBaseLayer");
    a.addLayer(CommonCore.emptyBaseLayer);
    if (CommonCore.canSetBaseLayer()) {
        var b = CommonCore.getOSMLayer();
        d == b.get("name") && a.setBaseLayer(b);
        b = CommonCore.getOCMLayer();
        d == b.get("name") && a.setBaseLayer(b);
        b = CommonCore.getOTMLayer();
        d == b.get("name") && a.setBaseLayer(b);
        CommonCore.bingApiKey && (b = CommonCore.getBingLayer(CommonCore.BING_TYPE_ROAD), d == ImajnetUrl.BING_ROAD_LAYER_PARAM_NAME && a.setBaseLayer(b), b = CommonCore.getBingLayer(CommonCore.BING_TYPE_SATELLITE), d == ImajnetUrl.BING_SATELLITE_LAYER_PARAM_NAME && a.setBaseLayer(b), b = CommonCore.getBingLayer(CommonCore.BING_TYPE_HYBRID), d == ImajnetUrl.BING_HYBRID_LAYER_PARAM_NAME && a.setBaseLayer(b), jQuery("#mapMainMenuChooseMapItems").addClass("mapMainMenuChooseMapItemsWithBing"), jQuery("#bingLayers").show(),
            Nigsys.bindClickEvent(jQuery("#setB_MAP"), function(a) {
                CommonCore.setB_MAPBaseLayer(a)
            }), Nigsys.bindClickEvent(jQuery("#setB_SAT"), function(a) {
                CommonCore.setB_SATBaseLayer(a)
            }), Nigsys.bindClickEvent(jQuery("#setB_HYBRID"), function(a) {
                CommonCore.setB_HYBRIDBaseLayer(a)
            }))
    }
    "undefined" !== typeof CustomBaseLayers && -1 !== applicationDomain.indexOf("wipco.imajbox.com") && CustomBaseLayers.init(d);
    CommonCore.activateImage(jQuery("#set" + (d ? d : "emptyBaseLayer")).get(0));
    setTimeout("CommonCore.removeAttributionLinks()",
        8E3);
    CommonCore.overviewMap = new ol.control.OverviewMap({
        collapseLabel: "",
        label: "",
        layers: [a.layers[0]]
    });
    a.addControl(CommonCore.overviewMap)
};
CommonCore.setOSMBaseLayer = function(a) {
    map.setBaseLayer(CommonCore.getOSMLayer());
    CommonCore.onMapChanged(a);
    CommonCore.onHaveBaseLayer(a)
};
CommonCore.setOCMBaseLayer = function(a) {
    map.setBaseLayer(CommonCore.getOCMLayer());
    CommonCore.onMapChanged(a);
    CommonCore.onHaveBaseLayer(a)
};
CommonCore.setOTMBaseLayer = function(a) {
    map.setBaseLayer(CommonCore.getOTMLayer());
    CommonCore.onMapChanged(a);
    CommonCore.onHaveBaseLayer(a)
};
CommonCore.setB_MAPBaseLayer = function(a) {
    map.setBaseLayer(CommonCore.getBingLayer(CommonCore.BING_TYPE_ROAD));
    CommonCore.onMapChanged(a);
    CommonCore.onHaveBaseLayer(a)
};
CommonCore.setB_SATBaseLayer = function(a) {
    map.setBaseLayer(CommonCore.getBingLayer(CommonCore.BING_TYPE_SATELLITE));
    CommonCore.onMapChanged(a);
    CommonCore.onHaveBaseLayer(a)
};
CommonCore.setB_HYBRIDBaseLayer = function(a) {
    map.setBaseLayer(CommonCore.getBingLayer(CommonCore.BING_TYPE_HYBRID));
    CommonCore.onMapChanged(a);
    CommonCore.onHaveBaseLayer(a)
};
CommonCore.bindEventsOnMapElements = function() {
    Nigsys.bindClickEvent(jQuery("#setemptyBaseLayer"), function(a) {
        map.setBaseLayer(CommonCore.emptyBaseLayer);
        CommonCore.lastBaseLayerName = "emptyBaseLayer";
        CommonCore.onHaveEmptyBaseLayer(a);
        CommonCore.onMapChanged(a)
    });
    Nigsys.bindClickEvent(jQuery("#setOSM"), function(a) {
        CommonCore.setOSMBaseLayer(a)
    });
    Nigsys.bindClickEvent(jQuery("#setOSMMAPNIK"), function(a) {
        setOSMMAPNIKBaseLayer(a)
    });
    Nigsys.bindClickEvent(jQuery("#setOCM"), function(a) {
        CommonCore.setOCMBaseLayer(a)
    });
    Nigsys.bindClickEvent(jQuery("#setOTM"), function(a) {
        CommonCore.setOTMBaseLayer(a)
    })
};
CommonCore.onMapClick = function(a) {
    a.xy || (a.xy = {
        x: a.pageX,
        y: a.pageY
    });
    var c = !1;
    map.forEachFeatureAtPixel(a.pixel, function(a, b) {
        b == ImajnetMap.imajnetDragFeaturesLayer && (c = !0)
    });
    if (!c && Imajnet.imajnetIsActive())
        if ("LRSMeasurement" == CommonCore.mapClickType) CommonCore.onLRSMeasurementMapClick(a);
        else CommonCore.mapClickHandlerDisabled ? CommonCore.mapClickHandlerDisabled = !1 : (a = ol.proj.transform(a.coordinate, ImajnetMap.map.projection, ImajnetMapImplementation.imajnetProjection), ImajnetMap.mapClickHandler({
            lon: a[0],
            lat: a[1]
        }))
};
CommonCore.updateOverviewMap = function() {
    CommonCore.overviewMap && (map.removeControl(CommonCore.overviewMap), CommonCore.overviewMap = new ol.control.OverviewMap({
        collapseLabel: "",
        label: "",
        layers: [map.layers[0]]
    }), map.addControl(CommonCore.overviewMap));
    CommonCore.isEmptyBaseLayer(map.getLayers().item(0).get("name")) && jQuery("#olControlOverviewMapMaximizeButton").hide()
};
CommonCore.activateMapClick = function() {
    if (CommonCore.isMobile) CommonCore.deactivateMapClick(), Nigsys.bindClickEvent(CommonCore.mapContainer, CommonCore.onMapClick);
    else map.on("click", CommonCore.onMapClick)
};
CommonCore.deactivateMapClick = function() {
    CommonCore.isMobile ? Nigsys.unbindClickEvent(CommonCore.mapContainer, CommonCore.onMapClick) : map.un("click", CommonCore.onMapClick)
};
CommonCore.setScaleUnit = function() {
    "feet" == Nigsys.getMeasurementUnit() ? CommonCore.mapScaleControl.setUnits("imperial") : CommonCore.mapScaleControl.setUnits("metric")
};
CommonCore.initMap = function() {
    extent = CommonCore.sphericalMercatorExtent;
    proj4.defs(CommonCore.lambertCrs, "+proj\x3dlcc +lat_1\x3d49 +lat_2\x3d44 +lat_0\x3d46.5 +lon_0\x3d3 +x_0\x3d700000 +y_0\x3d6600000 +ellps\x3dGRS80 +towgs84\x3d0,0,0,0,0,0,0 +units\x3dm +no_defs");
    ol.proj.setProj4 = proj4;
    map = new ol.Map({
        view: new ol.View({
            maxZoom: 25,
            extent: extent,
            zoomFactor: 2
        }),
        interactions: ol.interaction.defaults({
            mouseWheelZoom: !1,
            keyboard: !1
        }).extend([new ol.interaction.MouseWheelZoom({
            duration: 400
        })]),
        target: "map"
    });
    CommonCore.zoomBar = new ol.control.ZoomSlider;
    CommonCore.mapMousePosition = new ol.control.MousePosition({
        projection: ImajnetMap.imajnetCrs,
        coordinateFormat: function(a) {
            return ol.coordinate.format(a, "{y}, {x}", 4)
        }
    });
    CommonCore.mapScaleControl = new ol.control.ScaleLine;
    var a = [new ol.control.Attribution, CommonCore.mapScaleControl, new ol.control.Zoom({
            delta: 1
        }), new ol.control.Rotate, CommonCore.mapMousePosition, CommonCore.zoomBar],
        c;
    for (c in a) map.addControl(a[c]);
    map.layers = map.getLayers().getArray();
    map.projection =
        map.getView().getProjection();
    map.setBaseLayer = function(a) {
        var b = map.getLayers().item(0).get("name"),
            c = a.get("name");
        b != c && (CommonCore.lastBaseLayerName = b, CommonCore.lastBaseLayer = map.getLayers().item(0), CommonCore.currentBaseLayerName = c, CommonCore.removeBaseLayers(), map.getLayers().insertAt(0, a), ImajnetUrl.changeUrlParam(ImajnetUrl.MAP_URL_PARAM_NAME, "emptyBaseLayer" == c ? "" : c), CommonCore.setBaseLayerCookie(c), CommonCore.updateOverviewMap(), CommonCore.removeAttributionLinks(), "emptyBaseLayer" == c ? (b =
            map.getView(), b = {
                zoom: b.getZoom(),
                center: b.getCenter(),
                projection: b.getProjection(),
                maxZoom: 25
            }, map.setView(new ol.View(b)), map.getView().on("change:resolution", ImajnetPlugin.onZoomStart)) : "emptyBaseLayer" == b && (b = map.getView(), (a = b.getZoom()) || (a = ImajnetUrl.getUrlParamValue(ImajnetUrl.ZOOM_URL_PARAM_NAME)), b = {
            zoom: a,
            center: b.getCenter(),
            projection: b.getProjection(),
            maxZoom: CommonCore.baseLayersMaxZoom
        }, map.setView(new ol.View(b)), map.getView().on("change:resolution", ImajnetPlugin.onZoomStart), ImajnetPlugin.zoomMapTo(a >
            CommonCore.baseLayersMaxZoom - 1 ? CommonCore.baseLayersMaxZoom - 1 : a), ImajnetPlugin.onZoomStart()))
    }
};
CommonCore.onMapRightClick = function(a) {
    a.preventDefault();
    CommonCore.resetLRSMeasurement();
    if (CommonCore.zoomBox) try {
        CommonCore.zoomBox.handler.removeBox()
    } catch (d) {}
    for (var c in CommonCore.boxControl)
        if (CommonCore.boxControl[c]) try {
            CommonCore.boxControl[c].box.removeBox()
        } catch (d) {}
    CommonCore.navigation && CommonCore.navigation.dragPan.handler.dragstart(a);
    CommonCore.buttonIsActive("olControlMeasureLineFeatures") ? (jQuery("#popupMeasureContentText").html(""), jQuery("#lastSegmentMeasurementText").html(""),
        lastSegmentMeasurement = CommonCore.currentMeasurement = 0, CommonCore.lineMeasureComponentsLength = 2, CommonCore.deactivateMeasureLine()) : CommonCore.buttonIsActive("olControlMeasureSurfaceFeatures") && (jQuery("#popupMeasureSurfaceContentText").html(""), CommonCore.deactivateMeasureSurface(), CommonCore.activateMeasureSurface())
};
CommonCore.clearMeasurements = function() {
    ImajnetPlugin.removeAllFeatures(CommonCore.measurementLayer)
};
CommonCore.functionsOverrides = function() {
    ol.View.prototype.setResolution = function(a, c) {
        !c && .29 > a && "emptyBaseLayer" !== CommonCore.currentBaseLayerName && null !== CommonCore.currentBaseLayerName || this.set(ol.ViewProperty.RESOLUTION, a)
    }
};
CommonCore.storeCurrentView = function(a) {
    CommonCore.currentMapViewIndex < CommonCore.mapViewsArray.length - 1 && (CommonCore.mapViewsArray = CommonCore.mapViewsArray.slice(0, CommonCore.currentMapViewIndex + 1));
    CommonCore.currentMapViewIndex++;
    CommonCore.mapViewsArray.push(a)
};
CommonCore.getPreviousView = function() {
    if (0 != CommonCore.currentMapViewIndex) {
        CommonCore.currentMapViewIndex--;
        var a = CommonCore.mapViewsArray[CommonCore.currentMapViewIndex];
        CommonCore.isFromNavigationHistory = !0;
        map.getView().setCenter(a.center);
        map.getView().setZoom(a.zoom)
    }
};
CommonCore.getNextView = function() {
    if (CommonCore.currentMapViewIndex != CommonCore.mapViewsArray.length - 1) {
        CommonCore.currentMapViewIndex++;
        var a = CommonCore.mapViewsArray[CommonCore.currentMapViewIndex];
        CommonCore.isFromNavigationHistory = !0;
        map.getView().setCenter(a.center);
        map.getView().setZoom(a.zoom)
    }
};
CommonCore.activateMeasureSurface = function() {
    CommonCore.measureSurface.setActive(!0)
};
CommonCore.deactivateMeasureSurface = function() {
    CommonCore.clearMeasurements();
    CommonCore.measureSurface.setActive(!1)
};
CommonCore.activateMeasureLine = function() {
    CommonCore.measureLine.setActive(!0)
};
CommonCore.deactivateMeasureLine = function() {
    CommonCore.clearMeasurements();
    CommonCore.measureLine.setActive(!1)
};
CommonCore.resetLRSMeasurementGeometry = function() {
    ImajnetPlugin.removeFeatures(ImajnetMap.allWFS, [CommonCore.LRSMeasurementFeatureWrapperPoint]);
    ImajnetPlugin.removeFeatures(ImajnetMap.allWFS, [CommonCore.LRSMeasurementFeatureWrapperFirstPoint]);
    ImajnetPlugin.removeFeatures(ImajnetMap.allWFS, [CommonCore.LRSMeasurementFeatureWrapperSecondPoint]);
    ImajnetPlugin.removeFeatures(ImajnetMap.allWFS, [CommonCore.LRSMeasurementFeatureWrapperLine])
};
CommonCore.addLRSMeasurementPointFeature = function(a) {
    a = ol.proj.transform([parseFloat(a.coordinate[0]), parseFloat(a.coordinate[1])], map.projection, ImajnetMapImplementation.imajnetProjection);
    return ImajnetPlugin.addFeature(ImajnetMap.allWFS, {
        x: a[0],
        y: a[1]
    }, {
        type: "Point",
        fillColor: "#0099ff",
        radius: 6,
        strokeColor: "#ffffff"
    })
};
CommonCore.onLRSMeasurementMapClick = function(a) {
    var c = ol.proj.transform([a.coordinate[0], a.coordinate[1]], map.projection, ImajnetMapImplementation.imajnetProjection);
    CommonCore.LRSMeasurementMapClick({
        lon: c[0],
        lat: c[1]
    });
    CommonCore.LRSMeasurementIsFirstPoint ? CommonCore.LRSMeasurementFeatureWrapperFirstPoint = CommonCore.addLRSMeasurementPointFeature(a) : CommonCore.LRSMeasurementFeatureWrapperSecondPoint = CommonCore.addLRSMeasurementPointFeature(a)
};
CommonCore.onLRSMeasurementComplete = function(a) {
    a = Nigsys.getOLGeometryFromWKTString(a);
    CommonCore.LRSMeasurementFeatureWrapperLine = ImajnetPlugin.addFeature(ImajnetMap.allWFS, a.points.coordinates, {
        type: "LineString",
        strokeColor: "#0099ff",
        strokeWidth: 3
    });
    jQuery("#LRSMeasurementValue").html(CommonCore.formatMeasurementLength(CommonCore.LRSMeasurementFeatureWrapperLine.getFeature().getGeometry(), !0))
};
CommonCore.onLRSMeasurementMouseMoveTimeout = function(a) {
    ImajnetPlugin.removeFeatures(ImajnetMap.allWFS, [CommonCore.LRSMeasurementFeatureWrapperPoint]);
    CommonCore.LRSMeasurementFeatureWrapperPoint = CommonCore.addLRSMeasurementPointFeature(a)
};
CommonCore.LRSMeasurementTimeout = null;
CommonCore.onLRSMeasurementMouseMoveTimeout = function(a) {
    ImajnetPlugin.removeFeatures(ImajnetMap.allWFS, [CommonCore.LRSMeasurementFeatureWrapperPoint]);
    CommonCore.LRSMeasurementFeatureWrapperPoint = CommonCore.addLRSMeasurementPointFeature(a)
};
CommonCore.LRSMeasurementTimeout = null;
CommonCore.onLRSMeasurementMouseMove = function(a) {
    CommonCore.LRSMeasurementTimeout = setTimeout(function() {
        CommonCore.onLRSMeasurementMouseMoveTimeout(a)
    }, 150)
};
CommonCore.registerLRSMeasurementMouseMoveEvent = function() {
    map.on("pointermove", CommonCore.onLRSMeasurementMouseMove)
};
CommonCore.unregisterLRSMeasurementMouseMoveEvent = function() {
    clearTimeout(CommonCore.LRSMeasurementTimeout);
    map.un("pointermove", CommonCore.onLRSMeasurementMouseMove)
};
CommonCore.registerLRSMeasurementClickEvent = function() {
    CommonCore.unregisterLRSMeasurementClickEvent();
    CommonCore.mapClickType = "LRSMeasurement"
};
CommonCore.unregisterLRSMeasurementClickEvent = function() {
    CommonCore.resetLRSMeasurement();
    CommonCore.mapClickType = ""
};
var CustomBaseLayers = {
    NAVER_STREET_LAYER_PARAM_NAME: "NAV_STREET",
    NAVER_SATELLITE_LAYER_PARAM_NAME: "NAV_SATELLITE",
    NAVER_HYBRID_LAYER_PARAM_NAME: "NAV_HYBRID",
    VWORLD_STREET_LAYER_PARAM_NAME: "VWORLD_STREET",
    VWORLD_SATELLITE_LAYER_PARAM_NAME: "VWORLD_SATELLITE",
    VWORLD_HYBRID_LAYER_PARAM_NAME: "VWORLD_HYBRID",
    layerTypes: ["STREET", "SATELLITE", "HYBRID"],
    naverResolutions: [2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, .5, .25],
    naverExtent: [90112, 1192896, 2187264, 2765760],
    init: function(b) {
        proj4.defs("EPSG:5179", "+proj\x3dtmerc +lat_0\x3d38 +lon_0\x3d127.5 +k\x3d0.9996 +x_0\x3d1000000 +y_0\x3d2000000 +ellps\x3dGRS80 +towgs84\x3d0,0,0,0,0,0,0 +units\x3dm +no_defs");
        ol.proj.setProj4 = proj4;
        CustomBaseLayers.naverProjection = new ol.proj.Projection({
            code: "EPSG:5179",
            extent: CustomBaseLayers.naverExtent,
            units: "m"
        });
        for (var a in CustomBaseLayers.layerTypes) {
            var c = CustomBaseLayers["NAVER_" + CustomBaseLayers.layerTypes[a] + "_LAYER_PARAM_NAME"];
            CustomBaseLayers.setBaseLayerHTMLItem(jQuery.imajnet.map.customBaseLayers[c], c)
        }
        for (a in CustomBaseLayers.layerTypes) c = CustomBaseLayers["VWORLD_" + CustomBaseLayers.layerTypes[a] + "_LAYER_PARAM_NAME"], CustomBaseLayers.setBaseLayerHTMLItem(jQuery.imajnet.map.customBaseLayers[c],
            c);
        CustomBaseLayers.setCustomBaseLayer(null, b)
    },
    setBaseLayerHTMLItem: function(b, a) {
        var c = {
                street: "/resources/img/buttons/BTN-BB4-5_Off.PNG",
                satellite: "/resources/img/buttons/BTN-BB4-6_Off.PNG",
                hybrid: "/resources/img/buttons/BTN-BB4-7_Off.PNG"
            }[a.substring(a.indexOf("_") + 1).toLowerCase()],
            c = jQuery('\x3cdiv class\x3d"mapMainMenuChooseMapItem"\x3e\x3cdiv\x3e\x3cimg src\x3d"' + c + '" class\x3d"mapMainMenuChooseMapItemImage" id\x3d"set' + a + '"\x3e\x3c/div\x3e\x3cdiv\x3e' + b + "\x3c/div\x3e\x3c/div\x3e");
        jQuery("#mapMainMenuChooseMapItems").append(c);
        jQuery("#set" + a).on("click", function(b) {
            CustomBaseLayers.setCustomBaseLayer(b, a)
        })
    },
    setCustomBaseLayer: function(b, a) {
        -1 !== a.indexOf("NAV_") ? CustomBaseLayers.setNaverLayer(a) : -1 !== a.indexOf("VWORLD_") && CustomBaseLayers.setVWorldLayer(a);
        b && (CommonCore.onMapChanged(b), CommonCore.onHaveBaseLayer(b))
    },
    setNaverLayer: function(b) {
        map.setBaseLayer(CustomBaseLayers.getNaverLayer({
            NAV_STREET: "bl_vc_bg/ol_vc_an",
            NAV_SATELLITE: "bl_st_bg/ol_st_an",
            NAV_HYBRID: "bl_st_bg/ol_st_rd/ol_st_an"
        }[b], b))
    },
    getNaverLayer: function(b,
        a) {
        var c = new ol.layer.Tile({
            title: a,
            type: "base",
            source: new ol.source.XYZ({
                projection: CustomBaseLayers.naverProjection,
                tileSize: MapCore.tileSize,
                tileGrid: new ol.tilegrid.TileGrid({
                    extent: CustomBaseLayers.naverExtent,
                    origin: [CustomBaseLayers.naverExtent[0], CustomBaseLayers.naverExtent[1]],
                    resolutions: CustomBaseLayers.naverResolutions
                }),
                tileUrlFunction: function(a, c, d) {
                    return null == a ? void 0 : "http://onetile" + (Math.floor(3 * Math.random()) + 1) + ".map.naver.net/get/160/0/0/" + (a[0] + 1) + "/" + a[1] + "/" + a[2] + "/" + b
                },
                attributions: [new ol.Attribution({
                    html: ['\x3ca href\x3d"http://map.naver.com"\x3e\x3cimg src\x3d"http://static.naver.net/maps2/logo_naver_s.png"\x3e\x3c/a\x3e']
                })]
            })
        });
        c.set("name", a);
        return c
    },
    setVWorldLayer: function(b) {
        map.setBaseLayer(CustomBaseLayers.getVWorldLayer({
            VWORLD_STREET: "Base",
            VWORLD_SATELLITE: "Satellite",
            VWORLD_HYBRID: "Hybrid"
        }[b], b))
    },
    getVWorldLayer: function(b, a) {
        var c = new ol.layer.Tile({
            title: a,
            visible: !0,
            type: "base",
            source: new ol.source.XYZ({
                url: "http://xdworld.vworld.kr:8080/2d/" +
                    b + "/201301/{z}/{x}/{y}." + ("Satellite" != b ? "png" : "jpeg"),
                attributions: [new ol.Attribution({
                    html: ['\x26copy; \x3ca href\x3d"http://map.vworld.kr"\x3eV-World Map\x3c/a\x3e']
                })]
            })
        });
        c.set("name", a);
        return c
    }
};
ImajnetPlugin.onImajnetDeactivated = function() {
    ImajnetMapImplementation.dragFeature && (ImajnetMapImplementation.dragFeature.setActive(!1), map.removeControl(ImajnetMapImplementation.dragFeature), ImajnetMapImplementation.dragFeature = null);
    ImajnetUI.removeActiveState(ImajnetUI.btnImajnetPluginDiv)
};
ImajnetMapImplementation = {
    imajnetProjection: new ol.proj.Projection({
        code: CommonCore.wgs84Crs
    }),
    dragBoxFeature: null,
    dragFeature: null,
    imajnetWFSProtocol1: null,
    imajnetWFSProtocol2: null,
    protocol2FeaturesCache: null,
    protocol1FeaturesLoaded: !1,
    selectFeatureControl: null,
    clickFeature: null,
    imajnetLRSLayer: null,
    imajnetLRSLayerName: "Imajnet LRS",
    selectedFeaturesArray: [],
    addImajnetFeatures: function(a, b) {
        if (a) {
            for (var c = 0; c < b.length; c++) b[c].setStyle(ImajnetMapImplementation.getDefaultStyle());
            a.getSource().addFeatures(b)
        } else console.error("Trying to add features to null layer.")
    },
    addProtocol1FeaturesToLayer: function(a, b) {
        try {
            if (a && ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showLabels) {
                var c = (new ol.format.GeoJSON).readFeatures(a);
                c[0] ? (ImajnetMapImplementation.removeOldFeatures(!0, !0), ImajnetMapImplementation.addImajnetFeatures(ImajnetMapImplementation.imajnetLRSLayer, c), ImajnetMapImplementation.protocol2FeaturesCache ? ImajnetMapImplementation.addImajnetFeatures(ImajnetMapImplementation.imajnetLRSLayer, ImajnetMapImplementation.protocol2FeaturesCache) : ImajnetMapImplementation.protocol1FeaturesLoaded = !0) : ImajnetMap.setImajboxMarkerPosition({
                    position: ImajnetMap.currentPosition
                }, !1)
            }
        } catch (e) {
            console.error("Roads read features error: " + e)
        }
    },
    addProtocol2FeaturesToLayer: function(a) {
        try {
            if (a && ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showLabels) {
                var b = (new ol.format.GeoJSON).readFeatures(a);
                b[0] && (ImajnetMapImplementation.protocol1FeaturesLoaded ? (ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showRoads || ImajnetMapImplementation.removeOldFeatures(!1, !0), ImajnetMapImplementation.addImajnetFeatures(ImajnetMapImplementation.imajnetLRSLayer,
                    b)) : ImajnetMapImplementation.protocol2FeaturesCache = b)
            }
        } catch (c) {
            console.error("PR read features error: " + c)
        }
    },
    createVectorLayerProtocol: function(a, b, c) {
        return ImajnetPlugin.getMapExtent() ? (new ol.format.WFS).writeGetFeature({
            geometryName: CommonCore.geometryPropertyName,
            featurePrefix: "feature",
            featureTypes: [b],
            featureNS: c,
            outputFormat: "application/json",
            srsName: CommonCore.sphericalMercatorCrs,
            bbox: ImajnetPlugin.getMapExtent(),
            filter: ol.format.filter.Bbox({
                geometryName: CommonCore.geometryPropertyName,
                extent: ImajnetPlugin.getMapExtent()
            })
        }) : null
    },
    initImajnetWMS: function() {
        ImajnetLRSSettings.LRSSettings && ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showRoads ? ImajnetMap.roadLayer || (ImajnetMap.roadLayer = ImajnetPlugin.addWMSLayerToMap(ImajnetMap.roadLayerName, ImajnetMap.LRSUrl)) : (ImajnetPlugin.removeLayerFromMap(ImajnetMap.roadLayer), ImajnetMap.roadLayer = null);
        ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showPR ? ImajnetMap.prLayer || (ImajnetMap.prLayer = ImajnetPlugin.addWMSLayerToMap(ImajnetMap.prLayerName,
            ImajnetMap.LRSUrl)) : (ImajnetPlugin.removeLayerFromMap(ImajnetMap.prLayer), ImajnetMap.prLayer = null)
    },
    initImajnetWFS: function() {
        ImajnetMapImplementation.protocol2FeaturesCache = null;
        var a = !1,
            b = !1;
        ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showLabels && (a = ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showLabels, b = ImajnetLRSSettings.LRSSettings.display.addressAndLRS.showRoads);
        if (a || b) {
            ImajnetMapImplementation.imajnetWFSProtocol1 && (ImajnetMapImplementation.imajnetWFSProtocol1 = null);
            if (!b) ImajnetMapImplementation.removeOldFeatures(!0, !1), ImajnetMapImplementation.protocol1FeaturesLoaded = !0;
            else if (11 < ImajnetPlugin.getCurrentZoomLevel()) try {
                ImajnetMapImplementation.protocol1FeaturesLoaded = !1;
                var c = Imajnet.cartographicServerUrl + "/carto/" + ImajnetMap.key + "/wfs";
                ImajnetMapImplementation.imajnetWFSProtocol1 = ImajnetMapImplementation.createVectorLayerProtocol(c, ImajnetMap.roadWFSLayerName, Nigsys.getProtocolString() + "//imajnet.net");
                if (!ImajnetMapImplementation.imajnetWFSProtocol1) return;
                Nigsys.doAjaxRequest("POST", c, (new XMLSerializer).serializeToString(ImajnetMapImplementation.imajnetWFSProtocol1),
                    ImajnetMapImplementation.addProtocol1FeaturesToLayer)
            } catch (e) {}
            ImajnetMapImplementation.imajnetWFSProtocol2 && (ImajnetMapImplementation.imajnetWFSProtocol2 = null);
            if (!a) ImajnetMapImplementation.removeOldFeatures(!1, !0);
            else if (15 < ImajnetPlugin.getCurrentZoomLevel()) try {
                c = Imajnet.cartographicServerUrl + "/carto/" + ImajnetMap.key + "/wfs", ImajnetMapImplementation.imajnetWFSProtocol2 = ImajnetMapImplementation.createVectorLayerProtocol(c, ImajnetMap.prWFSLayerName, Nigsys.getProtocolString() + "//imajnet.net", ImajnetMapImplementation.addProtocol2FeaturesToLayer),
                    ImajnetMapImplementation.imajnetWFSProtocol2 && Nigsys.doAjaxRequest("POST", c, (new XMLSerializer).serializeToString(ImajnetMapImplementation.imajnetWFSProtocol2), ImajnetMapImplementation.addProtocol2FeaturesToLayer)
            } catch (e) {}
        } else ImajnetMapImplementation.removeOldFeatures(!0, !0)
    },
    getDefaultStyle: function() {
        return new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: Nigsys.convertToHexFromRgba("#EE9900", .5),
                width: 6
            }),
            image: new ol.style.Circle({
                radius: 8,
                fill: new ol.style.Fill({
                    color: Nigsys.convertToHexFromRgba("#EE9900",
                        .5)
                }),
                stroke: new ol.style.Stroke({
                    color: Nigsys.convertToHexFromRgba("#EE9900", .8),
                    width: 4
                })
            })
        })
    },
    getSelectedStyle: function() {
        return new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: Nigsys.convertToHexFromRgba("#00FF00"),
                width: 6
            }),
            image: new ol.style.Circle({
                radius: 8,
                fill: new ol.style.Fill({
                    color: Nigsys.convertToHexFromRgba("#00FF00", .5)
                }),
                stroke: new ol.style.Stroke({
                    color: Nigsys.convertToHexFromRgba("#00FF00", .8),
                    width: 4
                })
            })
        })
    },
    getDefaultImajnetWFSStyle: function() {
        return new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: Nigsys.convertToHexFromRgba("#EE9900",
                    .5),
                width: 6
            }),
            image: new ol.style.Circle({
                radius: 8
            })
        })
    },
    applyLayerFeaturesStyle: function(a, b) {
        for (var c = a.getSource().getFeatures(), e = 0; e < c.length; e++) c[e].getStyle() && c[e].getStyle().externalGraphic || c[e].setStyle(b)
    },
    featureIsSection: function(a) {
        return a.getId() && -1 !== a.getId().indexOf(ImajnetMap.roadWFSLayerName + ".")
    },
    featureIsPR: function(a) {
        return a.getId() && -1 !== a.getId().indexOf(ImajnetMap.prWFSLayerName + ".")
    },
    onSaveLRSSettings: function() {
        ImajnetMapImplementation.initImajnetWMS();
        ImajnetMapImplementation.initImajnetWFS();
        "function" === typeof ImajnetMap.setImajboxLayerOnTop && ImajnetMap.setImajboxLayerOnTop()
    },
    removeOldFeatures: function(a, b) {
        if (ImajnetMapImplementation.imajnetLRSLayer)
            for (var c = ImajnetMapImplementation.imajnetLRSLayer.getSource().getFeatures(), e = 0; e < c.length; e++) !ImajnetMapImplementation.featureIsSection(c[e]) && !ImajnetMapImplementation.featureIsPR(c[e]) || !a && ImajnetMapImplementation.featureIsSection(c[e]) || !b && ImajnetMapImplementation.featureIsPR(c[e]) || ImajnetMapImplementation.imajnetLRSLayer.getSource().removeFeature(c[e])
    },
    onSectionFeatureMouseOver: function(a, b) {
        CommonCore.removeFeatureInfo();
        jQuery("#map").append(CommonCore.getFeatureInfoPopupContentBlue(jQuery.app.map.popupFeatureInfo.roadSections, [{
            key: "roadName",
            value: a.get("roadname")
        }, {
            key: "roadShortName",
            value: a.get("roadshortname")
        }, {
            key: "sectionName",
            value: a.get("sectionname")
        }, {
            key: "roadType",
            value: a.get("roadtype")
        }]));
        CommonCore.registerFeatureMouseMove(a.get("roadname"));
        Nigsys.positionExistingElement(b.mapBrowserEvent.originalEvent, null, "map", jQuery(".popupFeatureInfo"));
        for (var c = ImajnetMapImplementation.imajnetLRSLayer.getSource().getFeatures(), e = 0; e < c.length; e++) c[e].get("roadid") !== a.get("roadid") || c[e].get("fid") == a.get("fid") || ImajnetMapImplementation.featureIsPR(c[e]) || (c[e].setStyle(new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: "#000000",
                width: 3
            })
        })), c[e].changed(), c[e].set("isSelected", !0))
    },
    onPRFeatureMouseOver: function(a, b) {
        CommonCore.removeFeatureInfo();
        jQuery("#map").append(CommonCore.getFeatureInfoPopupContentPR(jQuery.app.map.popupFeatureInfo.pr, [{
            key: "pr",
            value: a.get("number")
        }, {
            key: "roadName",
            value: a.get("roadname")
        }, {
            key: "roadShortName",
            value: a.get("roadshortname")
        }, {
            key: "roadType",
            value: a.get("roadtype")
        }]));
        CommonCore.registerFeatureMouseMove(a.get("roadname"));
        Nigsys.positionExistingElement(b.mapBrowserEvent.originalEvent, null, "map", jQuery(".popupFeatureInfo"))
    },
    createImajnetDragMarkerFeatureControl: function() {
        if (ImajnetMap.allWFS) {
            if (!ImajnetMapImplementation.dragFeature) map.on("pointermove", function(a) {
                ImajnetMapImplementation.clickFeature.getFeatures().clear();
                var b = map.forEachFeatureAtPixel(a.pixel, function(a, b) {
                    return b && b.get("name") == ImajnetMap.allWFSName ? a : null
                });
                a = a.map.getTargetElement();
                b && "Imajbox Marker" == b.get("type") ? a.style.cursor = "pointer" : a.style.cursor = "auto"
            });
            map.removeInteraction(ImajnetMapImplementation.dragFeature);
            ImajnetMapImplementation.dragFeature = new ol.interaction.Modify({
                features: new ol.Collection([ImajnetMapImplementation.dragBoxFeature]),
                style: ImajnetMapImplementation.dragBoxFeature.getStyle(),
                condition: ol.events.condition.singleclick,
                pixelTolerance: 12
            });
            ImajnetMapImplementation.dragFeature.on("modifystart", function() {
                ImajnetMap.hideOrientation()
            });
            ImajnetMapImplementation.dragFeature.on("modifyend", function(a, b) {
                var c = ol.proj.transform(a.mapBrowserEvent.coordinate, ImajnetMap.map.projection, ImajnetMapImplementation.imajnetProjection);
                ImajnetMap.onMapClick({
                    lon: c[0],
                    lat: c[1]
                }, !0)
            });
            map.addInteraction(ImajnetMapImplementation.dragFeature);
            ImajnetMapImplementation.dragFeature.setActive(!0)
        }
    },
    isWFSLayerForSelectFeatureControl: function(a) {
        return a instanceof
        ol.layer.Vector && a.get("name") != ImajnetMap.imajnetSurveyTraceLayerName && a.get("name") != ImajnetMap.imajnetImageSwitcherLayerName && a.get("name") != ImajnetMap.imajnetOrientationLayerName
    },
    layersForSelectFeatureControl: function() {
        for (var a = 0; a < map.layers.length; a++)
            if (ImajnetMapImplementation.isWFSLayerForSelectFeatureControl(map.layers[a])) return !0;
        return !1
    },
    getMapLayersForSelectFeatureControl: function() {
        for (var a = [], b = map.getLayers().getArray(), c = 0; c < b.length; c++) ImajnetMapImplementation.isWFSLayerForSelectFeatureControl(b[c]) &&
            a.push(b[c]);
        return a
    },
    setFeatureStyle: function(a, b) {
        a.setStyle(b);
        a.changed()
    },
    createSelectFeatureControl: function() {
        var a = ImajnetMapImplementation.getMapLayersForSelectFeatureControl();
        if (0 == a.length) ImajnetMapImplementation.deactivateHoverAndClickFeature();
        else {
            if (ImajnetMapImplementation.selectFeatureControl) try {
                ImajnetMapImplementation.selectFeatureControl.set("layers", a)
            } catch (c) {} else ImajnetMapImplementation.selectFeatureControl = new ol.interaction.Select({
                condition: ol.events.condition.pointerMove,
                layers: a,
                multi: !1,
                filter: function(a, b) {
                    a.set("layer", b);
                    return !0
                },
                beforefeaturehighlighted: function(a, b) {
                    console.log(a, b)
                }
            }), ImajnetMapImplementation.selectFeatureControl.on("select", function(a, b) {
                if (!CommonCore.isMobile && ("exportFeatures" != CommonCore.buttonClicked || "featuresExport" != Export.exportOption))
                    if (0 < a.selected.length) {
                        var d = a.selected[0];
                        ImajnetMapImplementation.selectedFeaturesArray.push(d);
                        ImajnetMapImplementation.featureIsSection(d) ? (ImajnetMapImplementation.onSectionFeatureMouseOver(d,
                                a), ImajnetMapImplementation.setFeatureStyle(d, ImajnetMapImplementation.getSelectedStyle()), d.set("isSelected", !0)) : ImajnetMapImplementation.featureIsPR(d) ? (ImajnetMapImplementation.onPRFeatureMouseOver(d, a), ImajnetMapImplementation.setFeatureStyle(d, ImajnetMapImplementation.getSelectedStyle()), d.set("isSelected", !0)) : (d = ImajnetMapImplementation.getFeatureWrapperByFeature(d)) && d.getType() != ImajnetMap.MARKER_TYPE_IMAJBOX && d.getType() != ImajnetMap.FEATURE_TYPE_IMAGE_ORIENTATION && d.getType() != ImajnetMap.FEATURE_TYPE_LARGE_IMAGE_ORIENTATION &&
                            ImajnetPlugin.highlightFeatureOnImage(d)
                    } else {
                        ImajnetMapImplementation.selectedFeaturesArray.push(a.deselected[0]);
                        for (var f in ImajnetMapImplementation.selectedFeaturesArray) {
                            d = ImajnetMapImplementation.selectedFeaturesArray[f];
                            CommonCore.removeFeatureInfo();
                            CommonCore.unregisterFeatureMouseMove();
                            if (ImajnetMapImplementation.featureIsSection(d) || ImajnetMapImplementation.featureIsPR(d))
                                for (var h = ImajnetMapImplementation.imajnetLRSLayer.getSource().getFeatures(), g = 0; g < h.length; g++) h[g].get("isSelected") &&
                                    (ImajnetMapImplementation.setFeatureStyle(h[g], ImajnetMapImplementation.getDefaultStyle()), h[g].set("isSelected", !1));
                            if (d = ImajnetMapImplementation.getFeatureWrapperByFeature(d)) {
                                if (d.getType() == ImajnetMap.MARKER_TYPE_IMAJBOX || d.getType() == ImajnetMap.FEATURE_TYPE_IMAGE_ORIENTATION || d.getType() == ImajnetMap.FEATURE_TYPE_LARGE_IMAGE_ORIENTATION) {
                                    ImajnetMapImplementation.selectedFeaturesArray.length = 0;
                                    return
                                }
                                ImajnetPlugin.unHighlightFeatureOnImage(d);
                                ImajnetMapImplementation.selectedFeaturesArray.length =
                                    0;
                                return
                            }
                        }
                        ImajnetMapImplementation.selectedFeaturesArray.length = 0
                    }
            }), map.addInteraction(ImajnetMapImplementation.selectFeatureControl);
            var b = a.slice();
            b.push(ImajnetMap.imajnetDragFeaturesLayer);
            if (ImajnetMapImplementation.clickFeature) try {
                ImajnetMapImplementation.clickFeature.setProperties({
                    layers: a
                })
            } catch (c) {} else ImajnetMapImplementation.clickFeature = new ol.interaction.Select({
                addCondition: ol.events.condition.click,
                toggleCondition: ol.events.condition.click,
                layers: b,
                removeCondition: ol.events.condition.pointerMove,
                style: ImajnetMapImplementation.getSelectedStyle(),
                filter: function(a, b) {
                    a.set("layer", b);
                    return !0
                }
            }), ImajnetMapImplementation.clickFeature.on("select", function(a, b) {
                if (0 < a.selected.length) {
                    var d = a.selected[0];
                    if (!(CommonCore.isMobile || CommonCore.buttonIsActive("olControlInfoFeatures") || CommonCore.buttonIsActive("olControlGetFeatures") || CommonCore.buttonIsActive("olControlModifyFeature") || "drawFeature" == CommonCore.buttonClicked))
                        if (CommonCore.mapClickType)
                            if ("CG34Arbres" == CommonCore.mapClickType) CG34Arbres.onMapClick(event);
                            else if ("feature" == CommonCore.mapClickType) Feature.onMapClick(event);
                    else {
                        if ("polygonFromPoint" == CommonCore.mapClickType) PolygonFromPoint.onMapClick(event)
                    } else {
                        var f = ImajnetMapImplementation.getFeatureWrapperByFeature(d);
                        if (f) {
                            if (f.getType() == ImajnetMap.MARKER_TYPE_IMAJBOX || f.getType() == ImajnetMap.FEATURE_TYPE_IMAGE_ORIENTATION || f.getType() == ImajnetMap.FEATURE_TYPE_LARGE_IMAGE_ORIENTATION) {
                                ImajnetMeasurement.onMeasurementClick(f);
                                return
                            }
                            if (f.getType() == ImajnetMap.FEATURE_TYPE_POLYLIGNE) {
                                ImajnetMeasurement.onClick(f);
                                return
                            }
                            if (f.getType() == ImajnetMap.FEATURE_TYPE_ORIENTED_IMAGES) {
                                if (!Imajnet.imajnetOrientedImagesIsActive()) return; - 1 < f.getId() && ImajnetClickMode.moveImageToPosition(f.getId());
                                return
                            }
                        }
                        d.getProperties() && d.getId() && ((f = d.layer.get("name")) || (f = MainCore.getLayerNameWithWorkspace(CommonCore.getLayerNameFromFeatureId(d.getId()))), Feature.highlightFeature(f, d.getId(), {
                            mustZoomToFeature: !0,
                            editFeature: !0,
                            editIsDisabledByInfo: !0
                        }))
                    }
                }
            }), map.addInteraction(ImajnetMapImplementation.clickFeature);
            ImajnetMapImplementation.activateHoverAndClickFeature()
        }
    },
    activateHoverAndClickFeature: function() {
        Imajnet.imajnetClosestPositionIsActive() || Imajnet.imajnetOrientedImagesIsActive() || (ImajnetMapImplementation.selectFeatureControl && ImajnetMapImplementation.selectFeatureControl.setActive(!0), ImajnetMapImplementation.clickFeature && ImajnetMapImplementation.clickFeature.setActive(!0))
    },
    deactivateHoverAndClickFeature: function() {
        ImajnetMapImplementation.selectFeatureControl && (ImajnetMapImplementation.selectFeatureControl.setActive("false"), map.removeControl(ImajnetMapImplementation.selectFeatureControl),
            CommonCore.removeFeatureInfo(), jQuery("#" + ImajnetMapImplementation.selectFeatureControl.div.id).remove());
        ImajnetMapImplementation.clickFeature && (ImajnetMapImplementation.clickFeature.setActive("false"), map.removeControl(ImajnetMapImplementation.clickFeature), jQuery("#" + ImajnetMapImplementation.clickFeature.div.id).remove())
    },
    getFeatureWrapperByFeature: function(a) {
        for (var b = 0, c = ImajnetMap.featureWrappers.length; b < c; ++b)
            if (ImajnetMap.featureWrappers[b].feature == a) return ImajnetMap.featureWrappers[b];
        return null
    },
    addImajnetSettingsButtons: function() {
        jQuery(ImajnetUI.imajnetToolbarButtons.div).append('\x3cdiv id\x3d"imajnetSettingsButton" class\x3d"imajnetSettingsButton" title\x3d"' + jQuery.imajnet.settings.settings + '"\x3e\x3cdiv id\x3d"imajnetSettingsDropDownDiv" class\x3d"expandableToolbarDiv"\x3e\x3cdiv class\x3d"expandableToolbarDivItem" onclick\x3d"ImajnetSettings.showImajnetSettings(); jQuery(\'.buttonExpandedDiv\').hide();"\x3e' + jQuery.imajnet.settings.settings + "\x3c/div\x3e\x3cdiv class\x3d\"expandableToolbarDivItem\" onclick\x3d\"ImajnetLRSSettings.showImajnetLRSSettings(); jQuery('#imajnetWebShowRoadsAndPR').remove(); jQuery('.buttonExpandedDiv').hide();\"\x3e" +
            jQuery.imajnet.settings.LRSSettings + '\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"imajnetHelpButton" class\x3d"imajnetSettingsButton" title\x3d"' + jQuery.imajnet.menuHelp + '"\x3e\x3cdiv id\x3d"imajnetHelpDropDownDiv" class\x3d"expandableToolbarDiv"\x3e\x3cdiv  class\x3d"expandableToolbarDivItem" onclick\x3d"ImajnetUI.showHelp(); jQuery(\'.buttonExpandedDiv\').hide();"\x3e' + jQuery.imajnet.menuHelp + '\x3c/div\x3e\x3cdiv  class\x3d"expandableToolbarDivItem" onclick\x3d"ImajnetUI.showAboutImajnet(); jQuery(\'.buttonExpandedDiv\').hide();"\x3e' +
            jQuery.imajnet.menuAboutImajnet + "\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e");
        jQuery("#imajnetSettingsButton").bind({
            mouseenter: function() {
                if (!Imajnet.imajnetIsActive()) return !1;
                jQuery("#imajnetSettingsDropDownDiv").show()
            },
            mouseleave: function() {
                if (!Imajnet.imajnetIsActive()) return !1;
                jQuery("#imajnetSettingsDropDownDiv").hide()
            }
        });
        jQuery("#imajnetHelpButton").bind({
            mouseenter: function() {
                if (!Imajnet.imajnetIsActive()) return !1;
                jQuery("#imajnetHelpDropDownDiv").show()
            },
            mouseleave: function() {
                if (!Imajnet.imajnetIsActive()) return !1;
                jQuery("#imajnetHelpDropDownDiv").hide()
            }
        });
        Nigsys.browserIsIE7() || Nigsys.browserIsIE8() || (jQuery("#imajnetSettingsDropDownDiv").corner(), jQuery("#imajnetHelpDropDownDiv").corner())
    },
    createMapControls: function() {
        ImajnetUI.docking.imajnetMapButtons = new ImajnetDocking(jQuery("#map"), CommonCore.getPredefinedZoomLevelsHTML() + '\x3cdiv id\x3d"mapControls"\x3e\x3c/div\x3e', "Right", "imajnetMapButtons", {
            width: dockingRightContainerSize,
            height: 226,
            right: 0,
            top: 240
        });
        CheckDockingCookie("imajnetMapButtons");
        if (CommonCore.imajnetIsActive()) {
            var a =
                '\x3cdiv id\x3d"searchDropDownButton" title\x3d"' + jQuery.imajnet.button.search + '"\x3e\x3cdiv id\x3d"searchDropDownDiv" class\x3d"buttonExpandedDiv"\x3e\x3cdiv id\x3d"searchLRSLink"\x3e' + jQuery.imajnet.map.popupSearchLRS.title + '\x3c/div\x3e\x3cdiv id\x3d"searchAddressLink"\x3e' + jQuery.imajnet.map.popupSearchAddress.title + '\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"imajnetControlsButtons"\x3e\x3c/div\x3e';
            ImajnetUI.docking.imajnetButtons = new ImajnetDocking(jQuery("#map"), a, "Right", "imajnetButtons", {
                width: dockingRightContainerSize,
                height: 132,
                right: 0,
                top: 40
            });
            CheckDockingCookie("imajnetButtons");
            Nigsys.bindClickEvent(jQuery("#searchLRSLink"), function(a) {
                LRS.openLRSDialog();
                jQuery(".buttonExpandedDiv").hide()
            });
            Nigsys.bindClickEvent(jQuery("#searchAddressLink"), function(a) {
                Address.openSearchDialog();
                jQuery(".buttonExpandedDiv").hide()
            });
            ImajnetUI.btnClosestImageDiv = jQuery("\x3cdiv/\x3e").addClass("olControlImajnetClosestImageItemInactive").prop("title", jQuery.imajnet.button.closestImage).click(function(a) {
                if (Imajnet.clickMode ==
                    Imajnet.CLICK_MODE_CLOSEST_IMAGE) return !1;
                CommonCore.disableCommonControls();
                Imajnet.activateImajnetControl(ImajnetUI.btnClosestImageDiv, "closestImage");
                CommonCore.activateMapClick()
            });
            jQuery("#imajnetControlsButtons").append(ImajnetUI.btnClosestImageDiv);
            ImajnetUI.btnClickModeDiv = jQuery("\x3cdiv/\x3e").addClass("olControlImajnetClickModeItemInactive").prop("title", jQuery.imajnet.button.clickMode).click(function(a) {
                if (Imajnet.clickMode == Imajnet.CLICK_MODE_ORIENTED_IMAGES) return !1;
                CommonCore.disableCommonControls();
                CommonCore.activateMapClick();
                Imajnet.deactivateImajnetControl(ImajnetUI.btnClickModeDiv, "clickMode");
                Imajnet.activateImajnetControl(ImajnetUI.btnClickModeDiv, "clickMode")
            });
            jQuery("#imajnetControlsButtons").append(ImajnetUI.btnClickModeDiv);
            ImajnetUI.btnEnableClipboardDiv = jQuery("\x3cdiv/\x3e").addClass("olControlImajnetClipboardItemInactive").prop("title", jQuery.imajnet.map.clipboard.enableClipboard).click(function(a) {
                ImajnetUI.buttonIsActive(ImajnetUI.btnEnableClipboardDiv) ? Imajnet.deactivateImajnetControl(ImajnetUI.btnEnableClipboardDiv,
                    "showClipboard") : Imajnet.activateImajnetControl(ImajnetUI.btnEnableClipboardDiv, "showClipboard")
            });
            jQuery("#imajnetControlsButtons").append(ImajnetUI.btnEnableClipboardDiv);
            Common.bindSearchButtonEvents();
            Imajnet.imajnetIsActive() || ImajnetUI.deactivateImajnetToolbarButtons()
        }
    }
};
"undefined" !== typeof ImajnetPlugin && (ImajnetPlugin.featuresForProjection = {}, ImajnetPlugin.stylesForProjection = null, ImajnetPlugin.cachedProjections = {}, ImajnetPlugin.setLayerZIndex = function(a, b) {
        a.setZIndex(b)
    }, ImajnetPlugin.addImajnetLayerToMap = function() {
        var a = "en" == localeLanguage ? "eu" : localeLanguage,
            a = new ol.layer.Tile({
                name: ImajnetMap.layerName,
                source: new ol.source.TileImage({
                    urls: ImajnetMap.getImajnetTileUrls()
                }),
                type: "png",
                isBaseLayer: !1,
                displayInLayerSwitcher: !1,
                displayOutsideMaxExtent: !1,
                attribution: '\x3ca href\x3d"http://www.imajing.' +
                    a + '" target\x3d"_blank"\x3e\x26#169; ' + (new Date).getFullYear() + " Imajing\x3c/a\x3e"
            });
        0 == map.getLayers().getLength() ? (a.set("isBaseLayer", !0), map.getLayers().insertAt(0, a)) : map.addLayer(a);
        return a
    }, ImajnetPlugin.getMapExtent = function() {
        if (map.getView().getResolution()) return map.getView().calculateExtent(map.getSize())
    }, ImajnetPlugin.centerMapToPosition = function(a, b) {
        var c = ol.proj.transform([parseFloat(a.lon), parseFloat(a.lat)], ImajnetMapImplementation.imajnetProjection, map.projection);
        if (b) {
            var d =
                ImajnetPlugin.getMapExtent();
            if (!d || ol.extent.containsCoordinate(d, c)) return
        }
        map.getView().setCenter(c)
    }, ImajnetPlugin.getMapScale = function() {
        var a = map.getView(),
            b = a.getResolution(),
            a = a.getProjection().getUnits();
        return 25.4 / .28 * ol.proj.METERS_PER_UNIT[a] * 39.37 * b
    }, ImajnetPlugin.zoomMapTo = function(a) {
        a && map.getView().setZoom(parseInt(a))
    }, ImajnetPlugin.zoomMapToFeatureWrapper = function(a, b) {
        var c = a.getFeature();
        if (c) {
            var d = 17 < ImajnetPlugin.getCurrentZoomLevel() ? ImajnetPlugin.getCurrentZoomLevel() : 17;
            map.getView().fit(c.getGeometry(), map.getSize(), {
                maxZoom: d
            })
        }
    }, ImajnetPlugin.getMapResolution = function() {
        return map.getResolution()
    }, ImajnetPlugin.getCurrentZoomLevel = function() {
        return Math.round(map.getView().getZoom())
    }, ImajnetPlugin.addWMSLayerToMap = function(a, b) {
        var c = new ol.layer.Tile({
            singleTile: !1,
            opacity: 1,
            buffer: 0,
            name: a,
            source: new ol.source.TileWMS({
                params: {
                    LAYERS: a,
                    STYLES: "",
                    TRANSPARENT: !0,
                    FORMAT: "image/png",
                    TILED: !0,
                    VERSION: "1.3.0"
                },
                urls: "string" === typeof b ? Array(b) : b
            })
        });
        c.set("name",
            a);
        c.setOpacity(1);
        map.addLayer(c);
        return c
    }, ImajnetPlugin.addVectorLayerToMap = function(a, b, c) {
        b = 1;
        a == ImajnetMap.imajnetSurveyTraceLayerName ? (b = .5, c = {
                displayInLayerSwitcher: !1
            }) : a == ImajnetMap.imajnetImageSwitcherLayerName ? (b = .5, c = {
                displayInLayerSwitcher: !1
            }) : a == ImajnetMap.dragFeaturesLayerName ? (b = 1, c = {
                displayInLayerSwitcher: !1,
                rendererOptions: {
                    zIndexing: !0,
                    yOrdering: !1
                }
            }) : a == ImajnetMap.imajnetDragFeaturesLayerName ? c = {
                zIndex: 100
            } : a == ImajnetMapImplementation.imajnetLRSLayerName ? c = {
                zIndex: 95
            } : ImajnetMap.allWFSName &&
            (b = 1, c = {
                displayInLayerSwitcher: !1,
                style: ImajnetMapImplementation.getDefaultStyle()
            });
        var d = new ol.layer.Vector({
            name: a,
            source: new ol.source.Vector,
            updateWhileInteracting: !0
        });
        d.setOpacity(b);
        c.style && d.setStyle(c.style);
        d.set("displayInLayerSwitcher", c.displayInLayerSwitcher);
        ImajnetPlugin.addZIndexToLayer(a, d);
        map.addLayer(d);
        return d
    }, ImajnetPlugin.addZIndexToLayer = function(a, b) {
        var c = 0;
        switch (a) {
            case ImajnetMap.allWFSName:
                c = 100;
                break;
            case ImajnetMap.imajnetOrientationLayerName:
                c = 99;
                break;
            case ImajnetMap.imajnetDragFeaturesLayerName:
                c =
                    98;
                break;
            case ImajnetMapImplementation.imajnetLRSLayerName:
                c = 97
        }
        b.setZIndex(c)
    }, ImajnetPlugin.addMarkerLayerToMap = function(a) {
        var b = null;
        a == ImajnetMap.photogrammetryPositionsLayerName && (b = {
            displayInLayerSwitcher: !1
        });
        a = new ol.layer.Vector({
            name: a,
            source: new ol.source.Vector
        });
        a.set("displayInLayerSwitcher", b.displayInLayerSwitcher);
        map.addLayer(a);
        return a
    }, ImajnetPlugin.removeLayerFromMap = function(a, b) {
        a && map.removeLayer(a)
    }, ImajnetPlugin.removeAllMarkerFeatures = function(a) {
        markerLayer.getSource().clear()
    },
    ImajnetPlugin.removeAllMarkersFromLayer = function(a) {
        a && a.getSource().clear()
    }, ImajnetPlugin.setMarkerOpacity = function(a, b, c) {
        b.feature && b.feature.getStyle() && b.feature.getStyle().getImage() ? (b.feature.getStyle().getImage().setOpacity(c), b.feature.changed()) : console.error("Cannot set opacity!")
    }, ImajnetPlugin.addMarker = function(a, b) {
        if (b.type == ImajnetMap.markerType.IMAJBOX) {
            var c = ImajnetPlugin.addImajboxMarker(a, b);
            ImajnetMapImplementation.createImajnetDragMarkerFeatureControl();
            return c
        }
        var c = ol.proj.transform([parseFloat(b.lon),
                parseFloat(b.lat)
            ], ImajnetMapImplementation.imajnetProjection, map.projection),
            d = {
                src: b.imagePath,
                size: [b.size.width, b.size.height]
            };
        b.type == ImajnetMap.markerType.CLICK_POSITION_ON_MAP && (d.anchor = [.5, 1]);
        d = new ol.style.Style({
            image: new ol.style.Icon(d)
        });
        c = new ol.Feature({
            geometry: new ol.geom.Point(c)
        });
        c.setStyle(d);
        a.getSource().addFeature(c);
        d = new FeatureWrapper;
        d.setFeature(c);
        return d
    }, ImajnetPlugin.addImajboxMarker = function(a, b) {
        var c = ol.proj.transform([parseFloat(b.lon), parseFloat(b.lat)], ImajnetMapImplementation.imajnetProjection,
                map.projection),
            d = new ol.style.Style({
                image: new ol.style.Icon({
                    src: b.imagePath
                })
            });
        ImajnetMapImplementation.dragBoxFeature = new ol.Feature({
            geometry: new ol.geom.Point(c)
        });
        ImajnetMapImplementation.dragBoxFeature.setStyle(d);
        ImajnetMapImplementation.dragBoxFeature.set("type", "Imajbox Marker");
        ImajnetMapImplementation.dragBoxFeature.changed();
        a.getSource().addFeature(ImajnetMapImplementation.dragBoxFeature);
        c = new FeatureWrapper;
        c.setFeature(ImajnetMapImplementation.dragBoxFeature);
        return c
    }, ImajnetPlugin.afterImajnetLayersAddedToMap =
    function() {
        ImajnetMapImplementation.imajnetLRSLayer = ImajnetPlugin.addVectorLayerToMap(ImajnetMapImplementation.imajnetLRSLayerName, 1);
        ImajnetMapImplementation.initImajnetWFS();
        ImajnetMapImplementation.createSelectFeatureControl()
    }, ImajnetPlugin.removeMarker = function(a, b) {
        a.getSource().removeFeature(b.feature);
        a.setVisible(!1);
        a.setVisible(!0);
        a.getSource().changed();
        b.type == ImajnetMap.MARKER_TYPE_IMAJBOX && ImajnetMapImplementation.dragFeature.setActive(!1)
    }, ImajnetPlugin.removeMarkerFeatures = function(a,
        b) {
        for (var c = 0, d = b.length; c < d; ++c) this.removeMarker(a, b[c])
    }, ImajnetPlugin.addFeature = function(a, b, c) {
        var d = new ol.style.Style({
                stroke: new ol.style.Stroke({
                    color: Nigsys.convertToHexFromRgba(c.strokeColor, c.strokeOpacity),
                    width: c.strokeWidth
                }),
                fill: new ol.style.Fill({
                    color: Nigsys.convertToHexFromRgba(c.fillColor || c.strokeColor, c.fillOpacity)
                })
            }),
            e = null;
        if ("Point" == c.type) d = new ol.style.Style({
            image: new ol.style.Circle({
                radius: c.radius ? c.radius : 5,
                fill: new ol.style.Fill({
                    color: Nigsys.convertToHexFromRgba(c.fillColor ||
                        c.strokeColor, c.fillOpacity)
                }),
                stroke: new ol.style.Stroke({
                    color: Nigsys.convertToHexFromRgba(c.strokeColor, c.strokeOpacity),
                    width: c.strokeWidth
                })
            })
        }), e = new ol.geom.Point(ol.proj.transform([parseFloat(b.x), parseFloat(b.y)], ImajnetMapImplementation.imajnetProjection, map.projection));
        else if ("LineString" == c.type) {
            c = 0;
            for (e = b.length; c < e; ++c) b[c] = ol.proj.transform([parseFloat(b[c].x), parseFloat(b[c].y)], ImajnetMapImplementation.imajnetProjection, map.projection);
            e = new ol.geom.LineString(b)
        } else if ("Polygon" ==
            c.type) {
            c = 0;
            for (e = b.length; c < e; ++c) b[c] = ol.proj.transform([parseFloat(b[c].x), parseFloat(b[c].y)], ImajnetMapImplementation.imajnetProjection, map.projection);
            e = new ol.geom.Polygon([b])
        } else if ("MultiPolygon" == c.type) {
            for (c = 0; c < b.length; c++)
                for (var e = 0, f = b[c].length; e < f; ++e) b[c][e] = ol.proj.transform([parseFloat(b[c][e].x), parseFloat(b[c][e].y)], ImajnetMapImplementation.imajnetProjection, map.projection);
            e = new ol.geom.MultiPolygon([b])
        }
        b = new ol.Feature(e);
        b.setStyle(d);
        a.getSource().addFeature(b);
        a = new FeatureWrapper;
        a.setFeature(b);
        return a
    }, ImajnetPlugin.removeFeatures = function(a, b) {
        if (a && b && !(1 > b.length)) {
            var c = a.getSource().getFeatures();
            if (c.length) {
                for (var d = 0, e = c.length; d < e; ++d)
                    for (var f = 0, g = b.length; f < g; ++f) b[f] && c[d] == b[f].feature && a.getSource().removeFeature(b[f].feature);
                a.getSource().changed()
            }
        }
    }, ImajnetPlugin.removeAllFeatures = function(a) {
        a && (a.getSource().clear(), a.getSource().changed())
    }, ImajnetPlugin.selectMarker = function(a, b) {
        ImajnetPlugin.setMarkerOpacity(a, b, .6)
    }, ImajnetPlugin.unselectMarker =
    function(a, b) {
        ImajnetPlugin.setMarkerOpacity(a, b, 1)
    }, ImajnetPlugin.selectFeature = function(a, b) {
        ImajnetMapImplementation.selectFeatureControl.getFeatures().push(b.feature);
        ImajnetMapImplementation.selectFeatureControl.dispatchEvent({
            type: "select",
            selected: [b.feature],
            deselected: []
        });
        b.getFeature().getStyle().getStroke().setColor(Nigsys.convertToHexFromRgba(Nigsys.defaultObjectsColor, .5))
    }, ImajnetPlugin.unselectFeature = function(a, b) {
        ImajnetMapImplementation.selectFeatureControl.getFeatures().clear();
        ImajnetMapImplementation.selectFeatureControl.dispatchEvent({
            type: "select",
            selected: [],
            deselected: [b.feature]
        });
        b.getFeature().getStyle().getStroke().setColor(Nigsys.convertToHexFromRgba(Nigsys.defaultObjectsColor))
    }, ImajnetPlugin.onFeatureMouseOver = function() {}, ImajnetPlugin.onFeatureMouseOut = function() {}, ImajnetPlugin.onMoveEnd = function(a) {
        ImajnetMap.imajnetOrientationLayer.setVisible(!0);
        CommonCore.isFromNavigationHistory || CommonCore.storeCurrentView({
            center: map.getView().getCenter(),
            zoom: map.getView().getZoom()
        });
        CommonCore.isFromNavigationHistory = !1;
        if (currentZoomLevel != map.getView().getZoom()) currentZoomLevel = map.getView().getZoom();
        else ImajnetPlugin.onDragEnd()
    }, ImajnetPlugin.onDragEnd = function() {
        CommonCore.disableGeneralView();
        ImajnetWeb.dragEndHandler();
        try {
            ImajnetMapImplementation.initImajnetWFS()
        } catch (a) {}
        CommonCore.unregisterFeatureMouseMove()
    }, ImajnetPlugin.onZoomStart = function(a) {
        a && ImajnetMapImplementation.selectFeatureControl && (ImajnetMap.imajnetOrientationLayer.setVisible(!1), ImajnetMapImplementation.selectFeatureControl.getFeatures().clear());
        ImajnetPlugin.getCurrentZoomLevel() > CommonCore.baseLayersMaxZoom - 1 && "emptyBaseLayer" !== CommonCore.currentBaseLayerName ? map.setBaseLayer(CommonCore.emptyBaseLayer) : ImajnetPlugin.getCurrentZoomLevel() <= CommonCore.baseLayersMaxZoom - 1 && "emptyBaseLayer" !== CommonCore.lastBaseLayerName && "emptyBaseLayer" == CommonCore.currentBaseLayerName && map.setBaseLayer(CommonCore.lastBaseLayer);
        CommonCore.disableGeneralView();
        CommonCore.addPanZoomBarEvents();
        a && ImajnetMap.mapZoomEndHandler();
        CommonCore.unregisterFeatureMouseMove();
        map.updateSize()
    }, ImajnetPlugin.registerMapEvents = function() {
        currentZoomLevel = map.getView().getZoom();
        map.getView().on("change:resolution", ImajnetPlugin.onZoomStart);
        map.on("moveend", ImajnetPlugin.onMoveEnd)
    }, ImajnetPlugin.unregisterMapEvents = function() {
        map.un("moveend", ImajnetPlugin.onMoveEnd);
        map.getView().un("change:resolution", ImajnetPlugin.onZoomStart)
    }, ImajnetPlugin.clearCachedProjections = function(a) {
        jQuery.each(ImajnetPlugin.cachedProjections, function(b, c) {
            delete c[a]
        })
    }, ImajnetPlugin.getFeaturesForProjection =
    function(a, b, c, d) {
        var e = jQuery.Deferred();
        if (ImajnetPlugin.cachedProjections[d][a]) return ImajnetPlugin.featuresForProjection[a].features = ImajnetPlugin.cachedProjections[d][a].features, e.resolve();
        MainCore.getFeatureAjaxPostRequest(b, !0, null, null, null, {
            layerName: a,
            filter: c
        }).done(function(b) {
            ImajnetPlugin.featuresForProjection[a] || (ImajnetPlugin.featuresForProjection[a] = {}, ImajnetPlugin.featuresForProjection[a].layerName = a);
            ImajnetPlugin.featuresForProjection[a].features = b;
            ImajnetPlugin.cachedProjections[d][a] ||
                (ImajnetPlugin.cachedProjections[d][a] = {});
            ImajnetPlugin.cachedProjections[d][a].features = b;
            e.resolve()
        }).fail(function() {
            e.resolve()
        });
        return e.promise()
    }, ImajnetPlugin.getLayerStyleForProjection = function(a, b) {
        var c = jQuery.Deferred();
        if (ImajnetPlugin.cachedProjections[b][a]) return ImajnetPlugin.featuresForProjection[a].styles = ImajnetPlugin.cachedProjections[b][a].styles, ImajnetPlugin.featuresForProjection[a].styleName = ImajnetPlugin.cachedProjections[b][a].styleName, c.resolve();
        StyleEditor.getLayerStyleName(a).done(function(d) {
            StyleEditor.doGeoserverRequest("GET",
                null, null, null, null, {
                    layerStyle: d
                }).done(function() {
                var e = StyleEditor.getLayerStyleObject(d);
                ImajnetPlugin.featuresForProjection[a] || (ImajnetPlugin.featuresForProjection[a] = {});
                ImajnetPlugin.featuresForProjection[a].styles = e;
                ImajnetPlugin.featuresForProjection[a].styleName = d;
                ImajnetPlugin.cachedProjections[b][a] || (ImajnetPlugin.cachedProjections[b][a] = {});
                ImajnetPlugin.cachedProjections[b][a].styles = e;
                ImajnetPlugin.cachedProjections[b][a].styleName = d;
                c.resolve()
            }).fail(function() {
                c.resolve()
            })
        });
        return c.promise()
    }, ImajnetPlugin.getStylesArray = function(a, b) {
        var c = [];
        if (!a || !a.rules) return MainCore.stylesArray;
        var d = Feature.featuresData[CommonCore.getLayerNameWithoutWorkspace(b)];
        if (!d) return null;
        Feature.makeOL2Compatible(d);
        for (var e = 0; e < a.rules.length; e++)
            if (a.rules[e].minScaleDenominator = null, a.rules[e].maxScaleDenominator = null, a.rules[e].evaluate(d)) {
                var f = a.rules[e].symbolizer.Line;
                f || (a.rules[e].symbolizer.Polygon ? f = {
                    strokeColor: a.rules[e].symbolizer.Polygon.strokeColor ? a.rules[e].symbolizer.Polygon.strokeColor : a.rules[e].symbolizer.Polygon.fillColor,
                    strokeWidth: a.rules[e].symbolizer.Polygon.strokeWidth,
                    strokeDashstyle: a.rules[e].symbolizer.Polygon.strokeDashstyle
                } : a.rules[e].symbolizer.Point ? (f = a.rules[e].symbolizer.Point, f.graphic && !f.graphicName && (f.graphicName = "square"), f.externalGraphic && -1 == f.externalGraphic.indexOf("http") && (f.externalGraphic = StyleEditor.getImagePathFromGeoserverPath(f.externalGraphic), f.strokeWidth = 0)) : f = {
                    strokeColor: "#808080",
                    strokeWidth: 1
                });
                f.fill && !f.fillColor && (f.fillColor = "#808080");
                f.stroke && (f.strokeColor || (f.strokeColor = "#000000"), f.strokeWidth || (f.strokeWidth = 1));
                f.label && f.graphic && delete f.label;
                c.push(f);
                a.rules[e].symbolizer.Text && (f = a.rules[e].symbolizer.Text, f.pointRadius = 0, c.push(f))
            }
        Feature.removeOL2Compatible(d);
        return c
    }, ImajnetPlugin.drawUserProjections = function(a) {
        return jQuery.Deferred().resolve(null).promise()
    }, ImajnetPlugin.getFeatureIdFromWrapper = function(a) {
        return a.id
    }, ImajnetPlugin.onImageChange = function(a) {}, ImajnetPlugin.getProjectionCandidates = function(a) {
        return jQuery.Deferred().resolve(null).promise()
    },
    ImajnetPlugin.getProjectionCandidates = function(a) {
        return jQuery.Deferred().resolve(null).promise()
    }, ImajnetPlugin.onImajnetDeactivated = function() {
        ImajnetMapImplementation.dragFeature && (ImajnetMapImplementation.dragFeature.setActive(!1), map.removeControl(ImajnetMapImplementation.dragFeature), ImajnetMapImplementation.dragFeature = null);
        ImajnetUI.removeActiveState(ImajnetUI.btnImajnetPluginDiv);
        var a = MainCore.getNodeObjectFromLayerProperty(["data.layer.externalLayer.name"], Array(ImajnetMap.prLayerName));
        a && a.data && a.data.select && a.select(!1);
        (a = MainCore.getNodeObjectFromLayerProperty(["data.layer.externalLayer.name"], Array(ImajnetMap.roadLayerName))) && a.data && a.data.select && a.select(!1)
    }, ImajnetPlugin.onImajnetActivated = function() {
        CommonCore.activateImajnetButton()
    }, ImajnetPlugin.getMapSize = function() {
        var a = map.getSize();
        return a ? {
            w: a[0],
            h: a[1]
        } : null
    }, ImajnetPlugin.showImajnetItem = function(a, b, c) {
        Dialog.showDialog(a, b, c)
    }, ImajnetPlugin.hideImajnetItem = function(a) {
        Dialog.hideDialog(a)
    }, ImajnetPlugin.addActiveState =
    function(a) {
        a.addClass("opacity60")
    }, ImajnetPlugin.removeActiveState = function(a) {
        a.removeClass("opacity60")
    }, ImajnetPlugin.redrawLayer = function(a) {
        a == ImajnetMap.imajnetLayer && a.getSource().setUrl(ImajnetProtocol.getUsernameForUrl(Imajnet.serverUrl + '/api/tile/{"tile":{"x":{x},"y":{y},"zoom":{z}},"timeframe":' + JSON.stringify(ImajnetTimeframe.getTimeframe()) + "}"));
        a.getSource().refresh()
    });
ImajnetWeb = {
    initMenu: function() {
        if (isImajnetMode()) {
            var a = "",
                b;
            for (b in ImajnetSettings.imajnetLanguages) Imajnet.locale != ImajnetSettings.imajnetLanguages[b] && (a += '\x3cimg src\x3d"' + Imajnet.imajnetPath + "img/" + ImajnetSettings.imajnetLanguages[b] + '.png" onclick\x3d"ImajnetUrl.changeLocale(\'' + ImajnetSettings.imajnetLanguages[b] + '\');" onmouseover\x3d"jQuery(this).addClass(\'opacity60\');" onmouseout\x3d"jQuery(this).removeClass(\'opacity60\');" width\x3d"22" height\x3d"22" class\x3d"localeImage" title\x3d"' +
                jQuery.imajnet.locale[ImajnetSettings.imajnetLanguages[b]] + '" /\x3e');
            jQuery("#imajnetSettingsMenuLocale").html(a);
            jQuery(".menu").menu({
                position: {
                    at: "left bottom"
                },
                icons: {
                    submenu: "ui-icon-triangle-1-s"
                },
                role: null,
                blur: function(a, b) {
                    jQuery("#imajnetDockingRightContainer_header").height(28);
                    "imajnetSettingsMenu" == a.target.id && (jQuery("#focusTarget").blur(), a.handleObj && "mouseleave" == a.handleObj.origType && ImajnetUI.closeAllMenus())
                },
                focus: function(a, b) {
                    "imajnetSettingsMenu" == a.target.id && jQuery("#imajnetDockingRightContainer_header").height(200)
                }
            });
            jQuery(".menu").show();
            jQuery("#imajnetPOI").bind("keydown", function(a) {
                Nigsys.disableEventPropagation(a)
            });
            jQuery("#imajnetAddress").on("keydown", function(a) {
                if (13 == a.keyCode) return Address.openSearchDialog(), jQuery("#searchAddressInput").val(jQuery("#imajnetAddress").val()), jQuery("#searchAddress").click(), !1;
                Nigsys.disableEventPropagation(a)
            })
        }
    },
    initImajnetHeader: function() {
        var a = "";
        if ("admin" == ImajnetUser.data.role.name || "imajnet-admin" == ImajnetUser.data.role.name) a = '\x3cli\x3e\x3ca href\x3d"javascript: void(0);"\x3e' +
            jQuery.imajnet.management.title + '\x3c/a\x3e\x3cul class\x3d"menuItem"\x3e\x3cli\x3e\x3ca id\x3d"menuShowSequenceDetailsButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.management.sequenceDetails + '\x3c/a\x3e\x3c/li\x3e\x3cli\x3e\x3ca id\x3d"menuShowReimportSequenceButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.management.reimportSequence.title + '\x3c/a\x3e\x3c/li\x3e\x3cli\x3e\x3ca id\x3d"menuShowDeleteSequenceButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.management.deleteSequence.title +
            '\x3c/a\x3e\x3c/li\x3e\x3cli\x3e\x3ca id\x3d"menuShowCreatePOIButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.management.createPOI + "\x3c/a\x3e\x3c/li\x3e\x3c/ul\x3e\x3c/li\x3e";
        a = '\x3cul id\x3d"imajnetSettingsMenu" class\x3d"menu"\x3e' + (Nigsys.onMobile() ? "" : '\x3cli class\x3d"left headerDockingButton" style\x3d"width: 30px;"\x3e\x3cdiv id\x3d"imajnetDockingButton_header" class\x3d"imageDockingButton ui-icon ui-icon-pin-w"\x3e\x3c/div\x3e\x3c/li\x3e') + '\x3cli style\x3d"margin-left: 0;"\x3e\x3ca href\x3d"javascript: void(0);"\x3e' +
            jQuery.imajnet.menuHelp + '\x3c/a\x3e\x3cul class\x3d"menuItem"\x3e\x3cli\x3e\x3ca id\x3d"menuHelpButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.menuHelp + '\x3c/a\x3e\x3c/li\x3e\x3cli\x3e\x3ca id\x3d"menuAboutImajnetButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.menuAboutImajnet + '\x3c/a\x3e\x3c/li\x3e\x3cli\x3e\x3ca id\x3d"menuNewsButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.menuNews + '\x3c/a\x3e\x3c/li\x3e\x3c/ul\x3e\x3c/li\x3e\x3cli\x3e\x3ca href\x3d"javascript: void(0);"\x3e' +
            jQuery.imajnet.menuSettings + '\x3c/a\x3e\x3cul class\x3d"menuItem"\x3e\x3cli\x3e\x3ca id\x3d"menuSettingsButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.menuSettings + '\x3c/a\x3e\x3c/li\x3e\x3cli\x3e\x3ca id\x3d"menuLRSSettingsButton" href\x3d"javascript: void(0);"\x3e' + jQuery.imajnet.LRSSettings + "\x3c/a\x3e\x3c/li\x3e\x3c/ul\x3e\x3c/li\x3e" + a + '\x3cli style\x3d"margin-left: 20px;"\x3e\x3cdiv class\x3d"left"\x3e' + jQuery.imajnet.poi.label + ':\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 3px;"\x3e\x3cselect id\x3d"imajnetPOI" onchange\x3d"ImajnetMap.POIChanged(jQuery(this));"\x3e\x3c/select\x3e\x3c/div\x3e\x3c/li\x3e\x3cli style\x3d"margin-left: 15px;"\x3e\x3cdiv class\x3d"left"\x3e' +
            jQuery.imajnet.address.label + ':\x3c/div\x3e\x3cdiv class\x3d"left" style\x3d"margin-left: 3px;"\x3e\x3cinput type\x3d"text" id\x3d"imajnetAddress" value\x3d"" /\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/li\x3e\x3cli style\x3d"float: right; border: 0; margin-right: 2px;"\x3e\x3cdiv\x3e\x3cinput type\x3d"button" id\x3d"logoutButton" value\x3d"' + jQuery.imajnet.security.logout + '" style\x3d"cursor: pointer;' + (Nigsys.browserIsIE7() ? " font-size: 15px;" : "") + '" /\x3e\x3c/div\x3e\x3c/li\x3e\x3cli id\x3d"imajnetSettingsMenuLocale" style\x3d"float: right; margin: 0 3px 0 0;"\x3e\x3cdiv\x3e\x3c/div\x3e\x3c/li\x3e\x3c/ul\x3e\x3cdiv class\x3d"clear"\x3e\x3c/div\x3e';
        ImajnetUI.docking.header = new ImajnetDocking(jQuery("body"), a, "Top", "header", {
            width: 28,
            height: container.width(),
            left: 0,
            top: 0
        });
        a = jQuery("#logoutButton");
        a.val(a.val() + "(" + ImajnetUser.getUsername() + ")");
        Nigsys.bindClickEvent(jQuery("#menuHelpButton"), ImajnetUI.showHelp);
        Nigsys.bindClickEvent(jQuery("#menuAboutImajnetButton"), ImajnetUI.showAboutImajnet);
        Nigsys.bindClickEvent(jQuery("#menuNewsButton"), function() {
            ImajnetNews.init(!1);
            ImajnetUI.closeAllMenus()
        });
        Nigsys.bindClickEvent(jQuery("#menuSettingsButton"),
            ImajnetSettings.showImajnetSettings);
        Nigsys.bindClickEvent(jQuery("#menuLRSSettingsButton"), ImajnetLRSSettings.showImajnetLRSSettings);
        Nigsys.bindClickEvent(a, function() {
            ImajnetProtocol.imajnetLogout(!0)
        });
        if ("admin" == ImajnetUser.data.role.name || "imajnet-admin" == ImajnetUser.data.role.name) Nigsys.bindClickEvent(jQuery("#menuShowSequenceDetailsButton"), ImajnetUI.showSequenceDetails), Nigsys.bindClickEvent(jQuery("#menuShowReimportSequenceButton"), ImajnetUI.showReimportSequence), Nigsys.bindClickEvent(jQuery("#menuShowDeleteSequenceButton"),
            ImajnetUI.showDeleteSequence), Nigsys.bindClickEvent(jQuery("#menuShowCreatePOIButton"), ImajnetUI.showCreatePOI)
    },
    imajnetLoginSuccess: function() {
        Nigsys.initModalOverlay("body");
        this.initImajnetHeader();
        Nigsys.addIddleTimeout();
        CommonCore.devMode || (CommonCore.bingApiKey = ImajnetUser.data.bingKey || "");
        "undefined" !== typeof ImajnetMap && (CommonCore.addBaseLayers(ImajnetMap.map, !0), CommonCore.initToolbars());
        CommonCore.initCookieWarning(ImajnetUser.data.login);
        "undefined" !== typeof ImajnetUI && ImajnetUI && ImajnetUI.addMobileCss();
        ImajnetWeb.initMenu();
        CommonCore.setScaleUnit()
    },
    dragEndHandler: function() {
        isImajnetMode() && CommonCore.removeFeatureInfo()
    },
    initTimeframeContainer: function() {
        var a = '\x3cdiv id\x3d"imajnetTimeframeContainer"\x3e\x3cdiv id\x3d"timeframeUnselectableContainer"\x3e\x3cdiv\x3e\x3cdiv class\x3d"left timeframeLabel"\x3e' + jQuery.imajnet.timeframe.from + '\x3c/div\x3e\x3cdiv class\x3d"left"\x3e\x3cinput type\x3d"text" id\x3d"imajnetTimeframeFromDate" onchange\x3d"ImajnetTimeframe.setTimeframeFrom(jQuery(this));" size\x3d"17" /\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv style\x3d"margin-top: 5px;"\x3e\x3cdiv class\x3d"left timeframeLabel"\x3e' +
            jQuery.imajnet.timeframe.to + '\x3c/div\x3e\x3cdiv class\x3d"left"\x3e\x3cinput type\x3d"text" id\x3d"imajnetTimeframeToDate" onchange\x3d"ImajnetTimeframe.setTimeframeTo(jQuery(this));" size\x3d"17" /\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3cdiv id\x3d"setTimeframeContainer"\x3e\x3cdiv class\x3d"clearLeft"\x3e\x3c/div\x3e\x3c/div\x3e\x3cdiv id\x3d"resetTimeframeButtonContainer"\x3e\x3cinput id\x3d"resetTimeframeButton" type\x3d"button" value\x3d"' + jQuery.imajnet.timeframe.reset +
            '" /\x3e\x3c/div\x3e\x3c/div\x3e\x3c/div\x3e';
        ImajnetUI.docking.imajnetTimeframe = new ImajnetDocking(isImajnetMode() ? jQuery("#map") : MainCore.mapDockingContainer, a, "Top", "imajnetTimeframe", {
            width: 86,
            height: 250,
            left: 150,
            top: 0,
            notResizable: !0
        });
        Nigsys.bindClickEvent(jQuery("#resetTimeframeButton"), function() {
            jQuery("#imajnetTimeframeFromDate").val("");
            jQuery("#imajnetTimeframeToDate").val("");
            ImajnetTimeframe.setTimeframe(ImajnetTimeframe.getTimeframeFromInput())
        });
        a = ImajnetTimeframe.getTimeframe();
        Nigsys.appendDateTimePickerToElement("#imajnetTimeframeFromDate",
            "xsd:date", a ? a.from : "", !1, {
                onClose: function() {
                    ImajnetTimeframe.setTimeframe(ImajnetTimeframe.getTimeframeFromInput())
                }
            });
        jQuery("#imajnetTimeframeFromDate").datepicker("option", "minDate", new Date(2010, 0, 1)).datepicker("option", "maxDate", 0);
        Nigsys.appendDateTimePickerToElement("#imajnetTimeframeToDate", "xsd:date", a ? a.to : "", !1, {
            onClose: function() {
                ImajnetTimeframe.setTimeframe(ImajnetTimeframe.getTimeframeFromInput())
            }
        });
        jQuery("#imajnetTimeframeToDate").datepicker("option", "minDate", new Date(2010, 0,
            1)).datepicker("option", "maxDate", 0);
        ImajnetTimeframe.setTimeframeText(a);
        CheckDockingCookie("imajnetTimeframe");
        jQuery("#imajnetTimeframeFromDate").keydown(function(a) {
            return !1
        });
        jQuery("#imajnetTimeframeToDate").keydown(function(a) {
            return !1
        })
    }
};
FlatGraphic.init = function() {
    this.svg = this.initSVG("popupImajnetControlsLayer", this.svg);
    if (!Nigsys.isPolyligneMode()) jQuery(this.svg.canvas).on("click", ImajnetUI.onImageClick)
};
var imajnetMapmapZoomEndHandler = ImajnetMap.mapZoomEndHandler;
ImajnetMap.mapZoomEndHandler = function() {
    imajnetMapmapZoomEndHandler();
    ImajnetUrl.changeUrlParam(ImajnetUrl.ZOOM_URL_PARAM_NAME, ImajnetPlugin.getCurrentZoomLevel(), !0);
    CommonCore.removeFeatureInfo()
};
var imajnetMapregisterToMap = ImajnetMap.registerToMap;
ImajnetMap.registerToMap = function() {
    imajnetMapregisterToMap();
    ImajnetMapImplementation.initImajnetWMS()
};
(function(d) {
    function e(a) {
        var b = a || window.event,
            c = [].slice.call(arguments, 1),
            f = 0,
            e = 0,
            g = 0;
        return a = d.event.fix(b), a.type = "mousewheel", b.wheelDelta && (f = b.wheelDelta / 120), b.detail && (f = -b.detail / 3), g = f, void 0 !== b.axis && b.axis === b.HORIZONTAL_AXIS && (g = 0, e = -1 * f), void 0 !== b.wheelDeltaY && (g = b.wheelDeltaY / 120), void 0 !== b.wheelDeltaX && (e = -1 * b.wheelDeltaX / 120), c.unshift(a, f, e, g), (d.event.dispatch || d.event.handle).apply(this, c)
    }
    var c = ["DOMMouseScroll", "mousewheel"];
    if (d.event.fixHooks)
        for (var h = c.length; h;) d.event.fixHooks[c[--h]] =
            d.event.mouseHooks;
    d.event.special.mousewheel = {
        setup: function() {
            if (this.addEventListener)
                for (var a = c.length; a;) this.addEventListener(c[--a], e, !1);
            else this.onmousewheel = e
        },
        teardown: function() {
            if (this.removeEventListener)
                for (var a = c.length; a;) this.removeEventListener(c[--a], e, !1);
            else this.onmousewheel = null
        }
    };
    d.fn.extend({
        mousewheel: function(a) {
            return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
        },
        unmousewheel: function(a) {
            return this.unbind("mousewheel", a)
        }
    })
})(jQuery);
Raphael.registerFont({
    w: 180,
    face: {
        "font-family": "Vinci Sans",
        "font-weight": 400,
        "font-stretch": "normal",
        "units-per-em": "360",
        "panose-1": "2 0 0 0 0 0 0 0 0 0",
        ascent: "277",
        descent: "-83",
        "x-height": "2",
        bbox: "-11 -272 303 77",
        "underline-thickness": "18",
        "underline-position": "0",
        "unicode-range": "U+0020-U+007E"
    },
    glyphs: {
        " ": {
            w: 82
        },
        a: {
            d: "108,-78v-26,7,-68,1,-68,31v0,39,62,24,68,-2r0,-29xm113,-24v-9,14,-25,26,-50,26v-32,0,-52,-18,-53,-47v-2,-52,61,-45,98,-57v12,-54,-60,-51,-74,-20r-20,-14v13,-18,32,-32,64,-34v86,-5,48,101,66,168r-26,4v-3,-9,-5,-15,-5,-26",
            w: 161,
            k: {
                y: 4,
                v: 4
            }
        },
        b: {
            d: "21,-1v13,-70,3,-161,6,-240r30,-1r0,99v9,-15,27,-27,50,-27v47,1,64,36,64,84v0,49,-18,87,-68,88v-24,1,-42,-11,-51,-25v-1,10,-3,17,-6,25xm98,-145v-20,0,-34,13,-41,28r0,69v7,15,19,25,39,25v34,0,43,-29,44,-62v1,-33,-10,-60,-42,-60",
            w: 182,
            k: {
                "\\": 29,
                x: 4
            }
        },
        c: {
            d: "12,-84v-8,-80,100,-117,136,-52r-22,12v-27,-43,-84,-15,-84,40v0,33,15,61,46,61v20,0,34,-12,41,-27r22,11v-12,23,-30,42,-64,41v-50,-2,-70,-36,-75,-86",
            w: 160
        },
        d: {
            d: "12,-84v-6,-68,70,-111,114,-69r0,-88r30,-1v3,79,-7,172,6,241r-26,3v-3,-8,-4,-15,-5,-25v-10,14,-26,26,-51,25v-48,-1,-64,-38,-68,-86xm86,-23v20,0,33,-10,40,-25r0,-77v-9,-13,-20,-19,-39,-20v-32,-1,-45,30,-45,62v1,32,13,60,44,60",
            w: 182
        },
        e: {
            d: "43,-69v-3,50,74,62,89,20r22,10v-10,24,-31,42,-65,41v-50,-1,-72,-35,-77,-86v-9,-88,117,-119,141,-38v3,10,5,23,5,35xm125,-106v1,-49,-73,-49,-80,-7v-2,6,-3,14,-3,21",
            w: 169
        },
        f: {
            d: "31,-168v-12,-61,34,-93,84,-65r-10,22v-17,-10,-49,-10,-44,22r0,21r42,0r-1,24r-41,0r0,144r-30,0r0,-144r-28,0r0,-24r28,0",
            w: 105,
            k: {
                "\\": -22,
                ")": -22,
                "-": 22,
                "?": -18,
                ".": 22,
                c: 7,
                d: 7,
                e: 7,
                g: 7,
                o: 7,
                q: 7,
                ",": 25,
                a: 4,
                T: -25,
                V: -25,
                W: -25,
                Y: -25,
                X: -22
            }
        },
        g: {
            d: "12,-84v0,-83,90,-106,144,-67v-7,92,33,226,-71,226v-35,0,-57,-15,-69,-38r21,-15v14,37,95,40,89,-16r0,-30v-11,14,-22,23,-46,24v-45,0,-68,-36,-68,-84xm86,-26v20,0,33,-12,40,-26r0,-84v-37,-24,-88,1,-84,52v3,33,13,58,44,58",
            w: 181
        },
        h: {
            d: "131,-113v2,-49,-66,-34,-74,-3r0,116r-30,0r0,-241r30,-1r0,98v23,-40,104,-34,104,31r0,113r-30,0r0,-113",
            w: 183,
            k: {
                T: 18,
                v: 4,
                y: 4
            }
        },
        i: {
            d: "57,-169r0,169r-30,0r0,-168xm59,-218v0,10,-7,16,-17,16v-11,1,-18,-6,-18,-16v0,-10,7,-17,18,-16v10,0,17,6,17,16",
            w: 83
        },
        j: {
            d: "-11,54v21,-10,39,-23,38,-55r0,-167r30,-1v-9,92,33,224,-57,245xm59,-218v0,10,-7,16,-17,16v-11,1,-18,-6,-18,-16v0,-10,7,-17,18,-16v10,0,17,6,17,16",
            w: 83
        },
        k: {
            d: "57,-242r0,153r73,-80v9,2,25,-2,31,3r-58,62r65,104r-33,1r-53,-83r-25,28r0,54r-30,0r0,-241",
            w: 168,
            k: {
                "-": 18,
                c: 4,
                d: 4,
                e: 4,
                g: 4,
                o: 4,
                q: 4
            }
        },
        l: {
            d: "57,-242r0,242r-30,0r0,-241",
            w: 83
        },
        m: {
            d: "54,-139v13,-35,92,-45,101,0v18,-43,106,-44,106,26r0,113r-30,0r0,-113v1,-49,-63,-34,-72,-3r0,116r-30,0r0,-113v1,-49,-64,-33,-72,-3r0,116r-30,0r0,-168r27,-1r0,30",
            w: 284,
            k: {
                T: 18,
                v: 4,
                y: 4
            }
        },
        n: {
            d: "131,-113v2,-49,-66,-34,-74,-3r0,116r-30,0r0,-168r27,-1r0,30v19,-45,107,-42,107,26r0,113r-30,0r0,-113",
            w: 184,
            k: {
                T: 18,
                v: 4,
                y: 4
            }
        },
        o: {
            d: "133,-84v0,-34,-12,-61,-45,-61v-33,0,-46,29,-46,61v0,32,12,61,46,61v33,0,45,-28,45,-61xm12,-84v0,-51,25,-86,76,-86v51,0,76,36,76,86v0,50,-25,86,-76,86v-51,0,-76,-35,-76,-86",
            w: 175,
            k: {
                "\\": 29,
                x: 4
            }
        },
        p: {
            d: "104,2v-22,0,-37,-9,-47,-21r0,93r-30,1r0,-243r27,-1r0,28v11,-17,28,-29,54,-29v47,0,63,37,63,84v0,50,-17,88,-67,88xm98,-145v-20,0,-34,14,-41,28r0,70v7,14,20,24,39,24v34,0,43,-29,44,-62v1,-33,-10,-60,-42,-60",
            w: 182,
            k: {
                "\\": 29,
                x: 4
            }
        },
        q: {
            d: "12,-84v-7,-83,90,-106,144,-68r0,226r-30,1r0,-97v-8,14,-24,24,-46,24v-49,-1,-64,-38,-68,-86xm87,-23v20,0,32,-10,39,-25r0,-88v-39,-23,-88,0,-84,52v3,32,13,62,45,61",
            w: 182
        },
        r: {
            d: "113,-142v-26,0,-46,9,-56,28r0,114r-30,0r0,-168r26,-1r0,30v11,-19,33,-31,63,-31",
            w: 115,
            k: {
                "-": 29,
                ".": 32,
                c: 4,
                d: 4,
                e: 4,
                g: 4,
                o: 4,
                q: 4,
                ",": 36
            }
        },
        s: {
            d: "40,-82v-44,-25,-18,-98,37,-88v33,-1,48,12,60,31r-20,15v-8,-25,-71,-33,-71,3v11,42,91,13,92,73v2,66,-114,62,-126,9r23,-11v3,30,73,40,73,4v0,-29,-46,-24,-68,-36",
            w: 148
        },
        t: {
            d: "109,-4v-34,15,-78,3,-78,-43r0,-97r-28,0r0,-24r28,0r0,-39r30,-4r0,43r42,0r-1,24r-41,0r0,96v-2,26,24,29,42,21",
            w: 113,
            k: {
                "-": 25,
                c: 4,
                d: 4,
                e: 4,
                g: 4,
                o: 4,
                q: 4
            }
        },
        u: {
            d: "80,2v-80,0,-52,-99,-57,-170r30,0r0,111v-2,53,67,36,74,4r0,-115r30,0v2,57,-5,121,6,168r-26,2v-2,-8,-5,-18,-5,-28v-9,17,-26,28,-52,28",
            w: 183
        },
        v: {
            d: "33,-169r44,143r45,-143r31,1r-59,168r-34,0r-58,-168",
            w: 154,
            k: {
                "-": 7,
                ".": 25,
                ",": 25
            }
        },
        w: {
            d: "147,-168r36,144r34,-145r31,1r-47,168r-38,0r-37,-145r-39,145r-37,0r-46,-168r30,-1r34,145r37,-144r42,0",
            w: 251,
            k: {
                "/": 4,
                ".": 20,
                ",": 18
            }
        },
        x: {
            d: "149,-168r-54,83r56,85r-32,1r-41,-64r-41,64r-33,-1r57,-85r-55,-83r32,-1r40,63r40,-63",
            w: 155,
            k: {
                "-": 18,
                c: 4,
                d: 4,
                e: 4,
                g: 4,
                o: 4,
                q: 4
            }
        },
        y: {
            d: "33,-169r44,143r45,-143r31,1r-79,210v-12,21,-32,33,-64,35r-5,-23v33,-4,50,-20,56,-52r-59,-170",
            w: 154,
            k: {
                "-": 7,
                ".": 25,
                ",": 25
            }
        },
        z: {
            d: "16,-168r118,0r1,23r-86,121r91,0r-2,24r-123,0r-1,-23r85,-121r-84,0",
            w: 152,
            k: {
                "-": 25,
                c: 10,
                d: 10,
                e: 10,
                g: 10,
                o: 10,
                q: 10
            }
        },
        "@": {
            d: "97,-87v0,35,33,53,51,26r0,-60v-26,-12,-51,4,-51,34xm34,-89v-4,87,90,125,160,86r7,20v-17,10,-41,16,-68,15v-76,-2,-120,-43,-120,-121v0,-72,41,-121,115,-121v75,0,109,41,115,114v5,55,-56,93,-87,54v-30,33,-93,7,-84,-45v-4,-56,61,-73,101,-47v4,32,-14,89,19,89v23,0,30,-24,30,-51v-1,-60,-32,-95,-94,-94v-61,1,-91,40,-94,101",
            w: 255,
            k: {
                ",": 14
            }
        },
        "#": {
            d: "69,-168r0,42r41,0r0,-42r25,0r0,42r32,0r0,21r-32,0r0,38r32,0r0,22r-32,0r0,45r-25,0r0,-45r-41,0r0,45r-24,0r0,-45r-33,0r0,-22r33,0r0,-38r-33,0r0,-21r33,0r0,-42r24,0xm69,-67r41,0r0,-38r-41,0r0,38"
        },
        ".": {
            d: "54,-16v0,11,-7,18,-18,18v-10,0,-19,-8,-19,-18v0,-10,10,-17,19,-17v10,0,18,7,18,17",
            w: 71,
            k: {
                T: 36,
                V: 29,
                W: 29,
                Y: 43,
                v: 25,
                y: 25,
                "*": 40,
                w: 20
            }
        },
        ",": {
            d: "58,-32r-29,79r-25,0r24,-79r30,0",
            w: 71
        },
        ":": {
            d: "54,-16v0,11,-7,18,-18,18v-10,0,-19,-8,-19,-18v0,-10,10,-17,19,-17v10,0,18,7,18,17xm54,-153v0,11,-7,18,-18,18v-10,0,-19,-8,-19,-18v0,-10,10,-17,19,-17v10,0,18,7,18,17",
            w: 71
        },
        ";": {
            d: "54,-32r-29,79r-25,0r24,-79r30,0xm54,-153v0,11,-7,18,-18,18v-10,0,-19,-8,-19,-18v0,-10,10,-17,19,-17v10,0,18,7,18,17",
            w: 71
        },
        "-": {
            d: "26,-96r96,0r0,24r-96,0r0,-24",
            w: 148,
            k: {
                T: 43,
                V: 14,
                W: 11,
                Y: 40,
                X: 18,
                x: 18,
                A: 7,
                z: 18,
                Z: 18
            }
        },
        _: {
            d: "0,12r235,0r0,24r-235,0r0,-24",
            w: 235
        },
        "(": {
            d: "63,76v-44,-62,-71,-173,-39,-267v10,-30,23,-57,39,-81r25,4v-28,43,-50,102,-50,170v0,67,23,127,50,170",
            w: 83,
            k: {
                j: -25
            }
        },
        ")": {
            d: "21,76v44,-62,71,-173,39,-267v-10,-30,-23,-57,-39,-81r-25,4v28,43,50,102,50,170v0,67,-23,127,-50,170",
            w: 83
        },
        "[": {
            d: "92,-247r-34,0r0,298r34,0r0,23r-61,0r0,-344r61,0r0,23",
            w: 93,
            k: {
                j: -22
            }
        },
        "]": {
            d: "2,-247r34,0r0,298r-34,0r0,23r61,0r0,-344r-61,0r0,23",
            w: 93
        },
        "{": {
            d: "33,-62v1,-18,-11,-23,-27,-24r0,-23v17,-1,28,-5,27,-24v-18,-58,-29,-162,61,-134r-4,21v-24,-4,-47,-2,-45,26v3,42,38,111,-14,122v51,12,17,80,14,121v-1,27,20,32,45,27r4,22v-39,12,-78,-4,-76,-48v1,-30,14,-56,15,-86",
            w: 95,
            k: {
                j: -18
            }
        },
        "}": {
            d: "63,-62v-1,-18,11,-23,27,-24r0,-23v-17,-1,-28,-5,-27,-24v18,-58,29,-162,-61,-134r4,21v24,-4,47,-2,45,26v-3,42,-38,111,14,122v-51,12,-17,80,-14,121v1,27,-20,32,-45,27r-4,22v39,12,78,-4,76,-48v-1,-30,-14,-56,-15,-86",
            w: 95
        },
        "!": {
            d: "61,-234r-2,179r-28,0r-1,-179r31,0xm64,-15v0,21,-37,22,-37,0v0,-11,9,-18,18,-18v11,0,18,8,19,18",
            w: 90
        },
        "?": {
            d: "88,-176v3,-38,-48,-42,-66,-22r-15,-22v36,-29,111,-19,111,43v0,41,-21,58,-52,69r0,51r-29,0r0,-71v29,-5,48,-18,51,-48xm51,2v-9,0,-19,-7,-18,-17v-1,-9,9,-19,18,-18v11,-1,19,8,19,18v0,11,-9,17,-19,17",
            w: 124,
            k: {
                "/": 14,
                ".": 27,
                ",": 32
            }
        },
        "'": {
            d: "56,-234r-2,93r-23,0r-2,-93r27,0",
            w: 85
        },
        '"': {
            d: "111,-234r-2,93r-23,0r-2,-93r27,0xm56,-234r-2,93r-23,0r-2,-93r27,0",
            w: 140
        },
        "/": {
            d: "136,-234r-110,235r-26,-1r110,-235",
            w: 135,
            k: {
                A: 25,
                s: 22,
                r: 14,
                q: 22,
                p: 14,
                o: 22,
                n: 14,
                m: 14,
                g: 22,
                e: 22,
                d: 22,
                c: 22,
                a: 18,
                "/": 47
            }
        },
        "\\": {
            d: "0,-234r110,235r26,-1r-110,-235",
            w: 135,
            k: {
                V: 7,
                "\\": 45
            }
        },
        A: {
            d: "2,0r73,-234r40,0r74,234r-32,1r-18,-64r-87,0r-19,64xm131,-89r-36,-119r-35,119r71,0",
            w: 190,
            k: {
                "\\": 18,
                "-": 7,
                ",": -18,
                T: 22,
                V: 11,
                W: 5,
                Y: 18,
                v: 5,
                y: 5,
                "*": 18,
                w: 4
            }
        },
        B: {
            d: "182,-64v3,75,-79,64,-151,64r0,-234v67,1,145,-12,145,58v0,34,-21,48,-44,57v28,5,49,22,50,55xm145,-172v0,-41,-43,-36,-83,-36r0,77v43,2,83,0,83,-41xm150,-65v0,-43,-44,-42,-88,-40r0,79v43,0,88,6,88,-39",
            w: 198
        },
        C: {
            d: "14,-117v-8,-103,109,-156,174,-88r-18,18v-13,-14,-27,-23,-52,-23v-52,0,-73,39,-73,93v0,54,20,92,73,93v27,1,39,-8,52,-23r19,18v-18,19,-36,31,-72,31v-71,0,-97,-47,-103,-119",
            w: 200,
            k: {
                c: 4,
                d: 4,
                e: 4,
                g: 4,
                o: 4,
                q: 4,
                v: 14,
                y: 14,
                C: 4,
                G: 4,
                O: 4,
                Q: 4
            }
        },
        D: {
            d: "210,-117v0,73,-32,116,-104,117r-75,0r0,-234r75,0v71,1,104,45,104,117xm178,-117v0,-72,-40,-99,-116,-91r0,182v76,8,116,-18,116,-91",
            w: 223
        },
        E: {
            d: "157,-234r-1,26r-94,0r0,77r81,0r0,26r-81,0r0,79r97,0r0,26r-128,0r0,-234r126,0",
            w: 173,
            k: {
                "-": 7
            }
        },
        F: {
            d: "157,-234r-1,26r-94,0r0,81r81,0r0,26r-81,0r0,101r-31,0r0,-234r126,0",
            w: 166,
            k: {
                "/": 7,
                "-": 11,
                ".": 47,
                c: 7,
                d: 7,
                e: 7,
                g: 7,
                o: 7,
                q: 7,
                ",": 58,
                x: 14,
                A: 11,
                z: 22,
                s: 7
            }
        },
        G: {
            d: "14,-117v0,-108,124,-155,192,-86r-18,18v-13,-15,-36,-25,-62,-25v-55,1,-81,35,-81,93v0,55,21,92,73,93v44,1,63,-32,61,-78r-54,0r0,-27r84,0r0,129r-25,0v-1,-12,1,-28,0,-37v-11,26,-34,39,-69,39v-69,0,-101,-46,-101,-119",
            w: 229
        },
        H: {
            d: "62,-234r0,102r111,0r0,-102r31,0r0,234r-31,0r0,-106r-111,0r0,106r-31,0r0,-234r31,0",
            w: 234
        },
        I: {
            d: "62,-234r0,234r-31,0r0,-234r31,0",
            w: 92
        },
        J: {
            d: "62,-234v-3,79,10,171,-5,240v-5,25,-28,38,-49,48r-15,-24v21,-11,38,-24,38,-56r0,-208r31,0",
            w: 92
        },
        K: {
            d: "62,-234r0,122r108,-123v10,1,25,-1,33,2r-85,95r89,138r-35,1r-75,-114r-35,40r0,73r-31,0r0,-234r31,0",
            w: 204,
            k: {
                "-": 14,
                v: 11,
                y: 11,
                w: 7,
                C: 11,
                G: 11,
                O: 11,
                Q: 11
            }
        },
        L: {
            d: "62,-234r0,208r91,0r-1,26r-121,0r0,-234r31,0",
            w: 155,
            k: {
                "-": 32,
                T: 36,
                V: 25,
                W: 14,
                Y: 36,
                v: 16,
                y: 16,
                "*": 61,
                w: 11,
                C: 14,
                G: 14,
                O: 14,
                Q: 14,
                U: 7
            }
        },
        M: {
            d: "139,0r-80,-209r3,209r-31,0r0,-234r50,0r77,208r77,-208r50,0r0,234r-30,0r1,-209r-79,209r-38,0",
            w: 316
        },
        N: {
            d: "78,-234r108,208r2,0v-5,-64,-1,-139,-2,-208r31,0r0,234r-49,0r-109,-209v5,65,1,140,2,209r-30,0r0,-234r47,0",
            w: 247
        },
        O: {
            d: "14,-117v0,-73,33,-119,102,-119v69,0,103,47,103,119v0,72,-32,119,-103,119v-70,0,-101,-47,-102,-119xm188,-117v0,-54,-21,-93,-72,-93v-51,0,-72,38,-71,93v0,54,19,93,71,93v53,0,72,-40,72,-93",
            w: 232,
            k: {
                T: 7,
                Y: 4,
                X: 11
            }
        },
        P: {
            d: "177,-165v0,63,-52,81,-115,73r0,92r-31,0r0,-234v74,-2,146,-4,146,69xm145,-164v0,-44,-39,-46,-83,-44r0,90v43,5,83,1,83,-46",
            w: 185,
            k: {
                "/": 18,
                "-": 7,
                ".": 50,
                ",": 47,
                A: 11
            }
        },
        Q: {
            d: "219,-117v1,47,-16,82,-42,101v15,15,31,29,43,48r-28,9r-39,-45v-82,23,-141,-28,-139,-113v2,-73,33,-119,102,-119v69,0,102,47,103,119xm188,-117v0,-54,-21,-93,-72,-93v-51,0,-72,38,-71,93v0,54,19,93,71,93v53,0,72,-40,72,-93",
            w: 232,
            k: {
                T: 7,
                Y: 4,
                X: 11
            }
        },
        R: {
            d: "177,-165v0,39,-18,59,-46,69r53,96r-33,1r-49,-91v-14,0,-27,0,-40,-2r0,92r-31,0r0,-234v74,-2,147,-4,146,69xm145,-164v0,-44,-39,-46,-83,-44r0,90v43,5,83,1,83,-46",
            w: 194,
            k: {
                "-": 11
            }
        },
        S: {
            d: "43,-122v-51,-30,-27,-121,41,-114v37,4,59,16,72,41r-25,12v-9,-35,-90,-38,-86,7v6,64,111,36,111,113v0,81,-125,84,-147,22r24,-14v10,18,22,31,51,31v38,0,52,-36,33,-59v-17,-20,-51,-25,-74,-39",
            w: 169
        },
        T: {
            d: "166,-234r-1,26r-65,0r0,208r-31,0r0,-208r-64,0r0,-26r161,0",
            w: 171,
            k: {
                "/": 32,
                "#": 14,
                t: 7,
                "-": 43,
                ".": 36,
                c: 25,
                d: 25,
                e: 25,
                g: 25,
                o: 25,
                q: 25,
                ",": 36,
                a: 27,
                v: 25,
                y: 25,
                x: 23,
                w: 25,
                C: 7,
                G: 7,
                O: 7,
                Q: 7,
                A: 22,
                z: 25,
                s: 25,
                "\x26": 11,
                u: 34,
                m: 29,
                n: 29,
                p: 29,
                r: 29,
                f: 7
            }
        },
        U: {
            d: "99,2v-105,3,-64,-141,-72,-236r30,0r0,149v1,36,12,62,49,61v87,-3,55,-126,61,-210r31,0r0,234r-27,0v-1,-14,1,-31,1,-41v-12,29,-34,42,-73,43",
            w: 227
        },
        V: {
            d: "186,-234r-72,234r-38,0r-72,-234r31,-1r61,209r60,-209",
            w: 190,
            k: {
                "/": 25,
                "-": 22,
                ".": 29,
                c: 14,
                d: 14,
                e: 14,
                g: 14,
                o: 14,
                q: 14,
                ",": 32,
                a: 7,
                A: 11,
                s: 7,
                u: 7,
                m: 4,
                n: 4,
                p: 4,
                r: 4
            }
        },
        W: {
            d: "37,-235r45,209r49,-208r45,0r50,208r44,-209r33,1r-55,234r-45,0r-50,-207r-49,207r-44,0r-56,-234",
            w: 304,
            k: {
                "/": 22,
                "-": 11,
                ".": 29,
                c: 7,
                d: 7,
                e: 7,
                g: 7,
                o: 7,
                q: 7,
                ",": 22,
                a: 7,
                A: 5,
                s: 7
            }
        },
        X: {
            d: "41,-234r55,95r56,-95r34,0r-72,118r72,116r-36,1r-54,-94r-54,94r-36,-1r72,-116r-72,-118r35,0",
            w: 193,
            k: {
                t: 7,
                "-": 18,
                c: 7,
                d: 7,
                e: 7,
                g: 7,
                o: 7,
                q: 7,
                v: 14,
                y: 14,
                w: 11,
                C: 11,
                G: 11,
                O: 11,
                Q: 11,
                u: 7
            }
        },
        Y: {
            d: "2,-234r31,-1r61,124r58,-124r32,1r-76,152r0,82r-30,0r0,-82",
            w: 186,
            k: {
                "/": 32,
                "#": 18,
                "-": 40,
                ".": 43,
                c: 25,
                d: 25,
                e: 25,
                g: 25,
                o: 25,
                q: 25,
                ",": 43,
                a: 22,
                v: 4,
                y: 4,
                x: 11,
                w: 4,
                C: 4,
                G: 4,
                O: 4,
                Q: 4,
                A: 18,
                z: 14,
                s: 25,
                "\x26": 11,
                u: 18,
                m: 22,
                n: 22,
                p: 22,
                r: 22
            }
        },
        Z: {
            d: "161,-234r2,23r-118,185r121,0r-1,26r-155,0r-1,-23r118,-185r-115,0r1,-26r148,0",
            w: 176,
            k: {
                "-": 43,
                c: 11,
                d: 11,
                e: 11,
                g: 11,
                o: 11,
                q: 11,
                v: 11,
                y: 11,
                w: 11,
                C: 11,
                G: 11,
                O: 11,
                Q: 11
            }
        },
        "*": {
            d: "61,-98r2,-55r-45,24r-8,-16r47,-21r-47,-20r8,-17r45,24r-2,-55r20,0r-2,55r45,-24r8,17r-47,20r47,21r-8,16r-45,-24r2,55r-20,0",
            w: 141,
            k: {
                ".": 40,
                ",": 40,
                A: 18
            }
        },
        "\x26": {
            d: "139,-71v4,-8,7,-21,6,-33r26,1v-1,18,-4,40,-12,54v13,16,31,29,42,47r-32,4r-28,-29v-28,45,-136,37,-133,-32v2,-34,23,-50,45,-62v-40,-26,-37,-115,30,-115v35,0,57,19,57,54v-1,33,-21,49,-44,65xm40,-60v-2,45,68,45,83,13r-52,-56v-13,10,-30,19,-31,43xm82,-210v-41,1,-30,59,-5,74v32,-9,48,-71,5,-74",
            w: 179,
            k: {
                T: 18,
                V: 7,
                Y: 25
            }
        },
        0: {
            d: "43,-117v0,46,5,93,47,93v42,0,47,-47,47,-93v0,-46,-6,-89,-47,-93v-42,4,-47,47,-47,93xm14,-117v0,-67,20,-119,76,-119v56,0,76,52,76,119v0,67,-19,119,-76,119v-57,0,-76,-52,-76,-119"
        },
        1: {
            d: "33,-26r50,0r0,-179r-58,34r-11,-22r69,-41r31,0r0,208r45,0r-1,26r-125,0r0,-26"
        },
        2: {
            d: "16,-197v19,-54,143,-53,137,21v-6,75,-67,100,-102,150r108,0r-1,26r-139,0r-1,-24v27,-44,66,-73,93,-115v19,-29,9,-74,-29,-71v-21,1,-34,10,-41,25"
        },
        3: {
            d: "121,-173v0,-48,-69,-46,-80,-12r-25,-12v11,-23,35,-39,69,-39v41,0,66,20,68,60v2,33,-23,49,-48,57v30,6,50,22,52,57v4,77,-121,83,-142,24r25,-11v12,36,87,33,85,-15v-2,-40,-38,-45,-82,-43r0,-26v41,1,78,0,78,-40"
        },
        4: {
            d: "144,-139r0,52r25,0r-2,25r-23,0r0,62r-31,0r0,-62r-104,0r-1,-24r103,-149v10,2,23,0,31,4r-98,144r69,0r0,-52r31,0"
        },
        5: {
            d: "130,-69v2,-51,-57,-53,-98,-40r-3,-4r0,-121r121,0r-2,26r-91,0r0,67v61,-6,101,15,105,72v5,80,-117,94,-142,31r24,-11v8,15,22,25,43,25v29,1,42,-16,43,-45"
        },
        6: {
            d: "138,-72v0,-52,-68,-56,-90,-23v0,39,9,71,47,71v27,0,43,-19,43,-48xm16,-111v0,-94,67,-162,138,-102v3,4,6,9,8,14r-24,12v-12,-28,-65,-31,-79,-1v-7,15,-13,37,-13,65v40,-36,126,-18,121,51v-3,45,-27,74,-72,74v-60,0,-79,-46,-79,-113"
        },
        7: {
            d: "53,0v8,-86,39,-151,75,-208r-109,0r1,-26r138,0r1,24v-37,58,-68,120,-75,210r-31,0"
        },
        8: {
            d: "17,-57v0,-33,21,-51,46,-62v-21,-12,-41,-26,-41,-59v0,-38,27,-58,68,-58v40,0,67,19,67,58v0,33,-20,47,-41,59v25,11,46,29,46,62v0,41,-30,59,-72,59v-43,0,-73,-18,-73,-59xm90,-23v47,3,52,-63,14,-75v-5,-3,-9,-6,-14,-8v-19,9,-42,20,-42,47v0,24,17,34,42,36xm90,-210v-40,0,-50,55,-16,70v5,3,10,6,16,9v18,-11,36,-19,37,-46v0,-20,-17,-33,-37,-33"
        },
        9: {
            d: "45,-162v0,52,68,56,90,23v0,-39,-9,-71,-47,-71v-27,-0,-43,19,-43,48xm167,-123v0,94,-67,162,-138,102v-3,-4,-6,-9,-8,-14r24,-12v12,28,65,31,79,1v7,-15,13,-37,13,-65v-40,36,-126,18,-121,-51v3,-45,27,-74,72,-74v60,-0,79,46,79,113"
        },
        $: {
            d: "129,-120v43,21,21,93,-25,91r0,44r-23,0r0,-44v-27,-5,-44,-17,-55,-41r23,-12v6,30,72,42,75,3v-11,-44,-97,-14,-96,-79v1,-32,23,-47,53,-51r0,-43r23,0r0,43v23,4,39,17,49,33r-20,15v-10,-38,-100,-22,-68,17v16,13,45,14,64,24"
        },
        "|": {
            d: "56,-270r0,344r-25,0r0,-344r25,0",
            w: 87
        },
        "+": {
            d: "102,-148r0,52r52,0r0,24r-52,0r0,52r-25,0r0,-52r-51,0r0,-24r51,0r0,-52r25,0"
        },
        "\x3d": {
            d: "154,-127r0,24r-128,0r0,-24r128,0xm154,-66r0,24r-128,0r0,-24r128,0"
        },
        "\x3c": {
            d: "154,-129r-100,45r100,45r-4,24r-125,-58r0,-22r125,-58"
        },
        "\x3e": {
            d: "25,-129r100,45r-100,45r4,24r125,-58r0,-22r-125,-58"
        },
        "~": {
            d: "121,-60v-31,0,-70,-51,-81,-2r-22,-3v-2,-38,47,-54,74,-30v15,12,48,20,47,-11r23,4v-3,23,-14,42,-41,42"
        },
        "^": {
            d: "102,-234r59,114r-19,9r-52,-102r-52,102r-19,-9r59,-114r24,0"
        },
        "%": {
            d: "102,-170v0,38,-12,67,-45,67v-32,0,-44,-29,-44,-67v0,-39,12,-66,44,-66v32,0,45,27,45,66xm58,-217v-32,0,-32,92,-1,94v32,-2,31,-91,1,-94xm236,-64v0,37,-13,66,-45,66v-32,0,-44,-29,-44,-66v0,-39,11,-67,44,-67v33,0,45,29,45,67xm192,-112v-32,0,-32,92,-1,94v32,-2,31,-91,1,-94xm196,-234r-124,234r-21,0r124,-234r21,0",
            w: 250
        },
        "`": {
            d: "72,-249r49,47r-14,15r-51,-43"
        },
        "": {
            w: 82
        }
    }
});