<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"
    xmlns:beans="http://www.springframework.org/schema/beans" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/security
    http://www.springframework.org/schema/security/spring-security-2.0.4.xsd">
   
    <http auto-config="true"  access-denied-page="/accessDenied.do?type=directdenied"  lowercase-comparisons="false">
    			
		<intercept-url pattern="/css/**"  			filters="none" />
		<intercept-url pattern="/images/**"  	filters="none" />
		<intercept-url pattern="/extLib/**"  		filters="none" />
		<intercept-url pattern="/js/**"  			filters="none" />  
		<intercept-url pattern="/lib/**"  			filters="none" />  
        
		<form-login login-page="/intro.do"
						default-target-url="/main/index.do"
						always-use-default-target ="true"
					    authentication-failure-url="/intro.do?fail=true" />
		
		<logout logout-success-url="/intro.do" />
		<!-- 중복로그인 방지  -->
		 <concurrent-session-control max-sessions="1" exception-if-maximum-exceeded="false"  expired-url="/accessDenied.do?type=duplication" />
	</http>
	
	
	<!-- 사용자 패스워드 암호화 처리   -->
	<authentication-provider user-service-ref="jdbcUserService">
		<password-encoder hash="sha-256" />
	</authentication-provider>
	
	<!--
	** AUTHOR_CODE는 반드시 ROLE_로 시작되어야 한다.
	<jdbc-user-service id="jdbcUserService" data-source-ref="dataSource"
		users-by-username-query="SELECT USER_ID, PASSWORD, ENABLED, USER_NAME FROM USERS WHERE USER_ID = ?"
		authorities-by-username-query="SELECT USER_ID, AUTHORITY FROM AUTHORITIES WHERE USER_ID = ?" />
	-->
	<!-- customizing user table, authorities table -->	 
	<beans:bean id="jdbcUserService" class="egovframework.rte.fdl.security.userdetails.jdbc.EgovJdbcUserDetailsManager" >
		<beans:property name="usersByUsernameQuery" value="SELECT USER_ID, PASSWORD, ENABLED, USER_NAME, USER_TEL, USER_DEPT, PW_DATE, (SELECT G2_VALUE FROM USV_CODEDDOMAINS WHERE G2_DOMAINID = '5001' AND G2_CODE = USER_DEPT ) AS USER_DEPT_NAME, INIT_EXTENT FROM USV_USERS WHERE USER_ID =? "/>
		<beans:property name="authoritiesByUsernameQuery" value="SELECT USER_ID, AUTHOR_CODE, COMP_AUTH FROM USV_USER_AUTHOR WHERE USER_ID = ?  AND COMP_AUTH='2' "/>
		<beans:property name="roleHierarchy" ref="roleHierarchy" />
		<beans:property name="dataSource" ref="dataSource" />
		<beans:property name="mapClass" value="egovframework.com.security.EgovUserDetailsMapping" />
	</beans:bean>
	
	<!-- SecuredObjectDAO 빈에 내장된 SQL을 사용하지 않을 경우 아래와 같이 변경 필요.  -->
	<beans:bean id="securedObjectDAO" class="egovframework.rte.fdl.security.securedobject.impl.SecuredObjectDAO" >
		<beans:property name="dataSource" ref="dataSource"/>
		<beans:property name="sqlHierarchicalRoles">
		<beans:value>
			<!-- SELECT a.child_role child, a.parent_role parent
			FROM ROLES_HIERARCHY a LEFT JOIN ROLES_HIERARCHY b on (a.child_role = b.parent_role) -->
			SELECT a.CHILD_AUTHOR AS child, a.PARENT_AUTHOR AS parent
			FROM USV_AUTHOR_HIERARCHY  a LEFT JOIN USV_AUTHOR_HIERARCHY  b on (a.CHILD_AUTHOR = b.PARENT_AUTHOR)
		</beans:value>
	</beans:property>
	<beans:property name="sqlRolesAndUrl">
		<beans:value>
			<!-- SELECT a.resource_pattern url, b.authority authority
			FROM SECURED_RESOURCES a, SECURED_RESOURCES_ROLE b
			WHERE a.resource_id = b.resource_id
			AND a.resource_type = 'url' ORDER BY a.sort_order -->
			SELECT a.ROLE_PTTRN url, b.AUTHOR_CODE authority
			FROM USV_ROLE_INFO a, USV_AUTHOR_ROLE b
			WHERE a.ROLE_CODE = b.ROLE_CODE
			AND a.ROLE_TY = 'url' ORDER BY a.ROLE_SORT 
		</beans:value>
	</beans:property>
	<beans:property name="sqlRolesAndMethod">
		<beans:value>
<!-- 	    SELECT a.resource_pattern method, b.authority authority
			FROM SECURED_RESOURCES a, SECURED_RESOURCES_ROLE b
			WHERE a.resource_id = b.resource_id
			AND a.resource_type = 'method' ORDER BY a.sort_order -->
			SELECT a.ROLE_PTTRN AS method, b.AUTHOR_CODE AS authority
			FROM USV_ROLE_INFO a, USV_AUTHOR_ROLE b
			WHERE a.ROLE_CODE = b.ROLE_CODE
			AND a.ROLE_TY = 'method' ORDER BY a.ROLE_SORT 
		</beans:value>
	</beans:property>
	<beans:property name="sqlRolesAndPointcut">
		<beans:value>
		<!-- 	SELECT a.resource_pattern pointcut, b.authority authority
			FROM SECURED_RESOURCES a, SECURED_RESOURCES_ROLE b
			WHERE a.resource_id = b.resource_id
			AND a.resource_type = 'pointcut' ORDER BY a.sort_order -->
			SELECT a.ROLE_PTTRN AS pointcut, b.AUTHOR_CODE AS authority
			FROM USV_ROLE_INFO a, USV_AUTHOR_ROLE b
			WHERE a.ROLE_CODE = b.ROLE_CODE
			AND a.ROLE_TY = 'pointcut' ORDER BY a.ROLE_SORT 
		</beans:value>
	</beans:property>		
	</beans:bean>
	
	<beans:bean id="securedObjectService" class="egovframework.rte.fdl.security.securedobject.impl.SecuredObjectServiceImpl">
		<beans:property name="securedObjectDAO" ref="securedObjectDAO" />
	</beans:bean>
	
	<!-- DB에서 계층 역할을 관리할 경우 -->
	<beans:bean id="roleHierarchy"  class="org.springframework.security.userdetails.hierarchicalroles.RoleHierarchyImpl" >
		<!-- XML 사용 
		<beans:property name="hierarchy">
			<beans:value>
				ROLE_ADMIN > ROLE_USER
				ROLE_USER > ROLE_RESTRICTED
				ROLE_RESTRICTED > IS_AUTHENTICATED_FULLY
				IS_AUTHENTICATED_REMEMBERED > IS_AUTHENTICATED_ANONYMOUSLY
			</beans:value>
		</beans:property>
		-->
		<!-- DB 사용 -->
		<beans:property name="hierarchy" ref="hierarchyStrings"/>
	</beans:bean>

	<beans:bean id="hierarchyStrings"  class="egovframework.rte.fdl.security.userdetails.hierarchicalroles.HierarchyStringsFactoryBean"  init-method="init">
		<beans:property name="securedObjectService" ref="securedObjectService"/>
	</beans:bean>

	<beans:bean id="filterSecurityInterceptor"  class="org.springframework.security.intercept.web.FilterSecurityInterceptor">
		<custom-filter before="FILTER_SECURITY_INTERCEPTOR" />
		<beans:property name="authenticationManager" ref="_authenticationManager" />
		<beans:property name="accessDecisionManager" ref="_accessManager" />
		<beans:property name="objectDefinitionSource" ref="databaseObjectDefinitionSource" />
	</beans:bean>
	
	<beans:bean id="databaseObjectDefinitionSource"  class="org.springframework.security.intercept.web.EgovReloadableDefaultFilterInvocationDefinitionSource">
		<beans:constructor-arg ref="antUrlPathMatcher" />
		<!--  <beans:constructor-arg ref="regexUrlPathMatcher" /> 위에 path-type="regex"  이면 활성화 -->
		<beans:constructor-arg ref="requestMap" />		
		<beans:property name="securedObjectService" ref="securedObjectService"/>
	</beans:bean>

	<!--  url  -->
	<beans:bean id="requestMap"  class="egovframework.rte.fdl.security.intercept.ResourcesMapFactoryBean"  init-method="init">
		<beans:property name="securedObjectService" ref="securedObjectService"/>
		<beans:property name="resourceType" value="url"/>
	</beans:bean>
	
	<beans:bean id="antUrlPathMatcher" class="org.springframework.security.util.AntUrlPathMatcher" />
	<beans:bean id="regexUrlPathMatcher" class="org.springframework.security.util.RegexUrlPathMatcher" />
	
	<!-- method -->
	<beans:bean id="methodDefinitionSourceAdvisor" class="org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor">
		<beans:constructor-arg value="methodSecurityInterceptor" />
		<beans:constructor-arg ref="delegatingMethodDefinitionSource" />
	</beans:bean>
	
	<beans:bean id="methodSecurityInterceptor" class="org.springframework.security.intercept.method.aopalliance.MethodSecurityInterceptor">
		<beans:property name="validateConfigAttributes" value="false" />
		<beans:property name="authenticationManager" ref="_authenticationManager"/>
		<beans:property name="accessDecisionManager" ref="_accessManager"/>
		<beans:property name="objectDefinitionSource" ref="delegatingMethodDefinitionSource" />
	</beans:bean>

	<beans:bean id="delegatingMethodDefinitionSource" class="org.springframework.security.intercept.method.DelegatingMethodDefinitionSource">
		<beans:property name="methodDefinitionSources">
			<beans:list>
				<beans:ref bean="methodDefinitionSources"/>
				<beans:bean class="org.springframework.security.annotation.SecuredMethodDefinitionSource" />
				<beans:bean class="org.springframework.security.annotation.Jsr250MethodDefinitionSource" />
			</beans:list>
		</beans:property>
	</beans:bean>
	
	<beans:bean id="methodDefinitionSources"  class="org.springframework.security.intercept.method.MapBasedMethodDefinitionSource">
		<beans:constructor-arg ref="methodMap" />
	</beans:bean>
	
	<beans:bean id="methodMap"  class="egovframework.rte.fdl.security.intercept.ResourcesMapFactoryBean"  init-method="init">
		<beans:property name="securedObjectService" ref="securedObjectService"/>
		<beans:property name="resourceType" value="method"/>
	</beans:bean>
	
	<!-- pointcut -->
	<!-- if no map, there is a error that "this map must not be empty; it must contain at least one entry" -->
	<!--
	<beans:bean id="protectPointcutPostProcessor" class="org.springframework.security.intercept.method.ProtectPointcutPostProcessor">
		<beans:constructor-arg ref="methodDefinitionSources" />
		<beans:property name="pointcutMap" ref="pointcutMap"/>
	</beans:bean>

	<beans:bean id="pointcutMap"  class="egovframework.rte.fdl.security.intercept.ResourcesMapFactoryBean"  init-method="init">
		<beans:property name="securedObjectService" ref="securedObjectService"/>
		<beans:property name="resourceType" value="pointcut"/>	
	</beans:bean>
	-->
		
	<!-- ajax 필터 추가.. : ajax에서 세션체크 버전이 낮아 안됨.. ㅠㅠ  
	<beans:bean id="ajaxSessionTimeoutFilter"  class="egovframework.com.cmm.filter.AjaxSessionTimeoutFilter">
	    <custom-filter after="EXCEPTION_TRANSLATION_FILTER"  />
		<beans:property name="ajaxHeader" value="AJAX"  />
	 </beans:bean>
   -->
</beans:beans>